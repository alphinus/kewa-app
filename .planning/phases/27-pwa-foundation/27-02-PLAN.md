---
phase: 27-pwa-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - public/sw.js
  - public/sw-cache.js
autonomous: true

must_haves:
  truths:
    - "App shell (HTML, CSS, JS, fonts) loads from cache when device is offline"
    - "Existing push notification subscription, delivery, and click handling continue to work after service worker expansion"
    - "Static assets are served cache-first, pages are served network-first with cache fallback"
  artifacts:
    - path: "public/sw.js"
      provides: "Main service worker with push handlers AND importScripts for caching"
      contains: "importScripts"
    - path: "public/sw-cache.js"
      provides: "Caching logic: install, activate, fetch handlers with cache-first/network-first strategies"
      min_lines: 60
  key_links:
    - from: "public/sw.js"
      to: "public/sw-cache.js"
      via: "importScripts('/sw-cache.js')"
      pattern: "importScripts.*sw-cache"
    - from: "public/sw-cache.js"
      to: "Cache API"
      via: "caches.open/caches.match"
      pattern: "caches\\.(open|match)"
    - from: "public/sw.js"
      to: "Push API"
      via: "push/notificationclick/pushsubscriptionchange listeners"
      pattern: "addEventListener\\('push"
---

<objective>
Expand the existing push notification service worker to also handle offline caching. Add a separate sw-cache.js file imported via importScripts() to keep push and caching logic cleanly separated.

Purpose: Enables offline app shell access. Cached pages and static assets load when device is offline. Push notifications continue working unchanged.
Output: Updated sw.js with importScripts, new sw-cache.js with caching strategies
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-pwa-foundation/27-CONTEXT.md
@.planning/phases/27-pwa-foundation/27-RESEARCH.md
@public/sw.js
@src/contexts/PushContext.tsx
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sw-cache.js caching module</name>
  <files>public/sw-cache.js</files>
  <action>
Create `public/sw-cache.js` with the following caching logic. This file is loaded by sw.js via importScripts().

```javascript
/**
 * KEWA Service Worker - Caching Module
 * Handles offline caching with cache-first (static) and network-first (pages) strategies
 * Phase: 27-pwa-foundation
 *
 * Loaded by sw.js via importScripts('/sw-cache.js')
 */

const CACHE_VERSION = 'kewa-v1'
const NETWORK_TIMEOUT = 3000 // 3 seconds before falling back to cache
```

**Install handler:**
- Opens the cache with CACHE_VERSION name
- No pre-caching (runtime caching only, per CONTEXT.md)
- Calls `self.skipWaiting()` to activate immediately

**Activate handler:**
- Deletes old cache versions (any cache name that starts with 'kewa-' but is not CACHE_VERSION)
- Calls `self.clients.claim()` to take control of open tabs

**Fetch handler:**
- ONLY handle same-origin requests: `if (url.origin !== self.location.origin) return` (early return, do not call event.respondWith for cross-origin)
- SKIP requests to: `/api/` paths (let API calls go through normally -- network-first for API is Phase 28's concern with IndexedDB, for now just pass through), `/manifest.webmanifest`, browser extension URLs
- For **navigation requests** (`request.mode === 'navigate'`): Use network-first with timeout pattern:
  1. Race between fetch and a 3-second timeout
  2. On success: clone response, cache it, return original
  3. On timeout/failure: try cache match
  4. If neither: return a basic Response with status 503 and text "Offline" (minimal fallback, no HTML page)

- For **static assets** (URLs ending in `.js`, `.css`, `.woff`, `.woff2`, `.ttf`, `.png`, `.jpg`, `.jpeg`, `.svg`, `.ico`, `.webp` OR URLs containing `/_next/static/`): Use cache-first pattern:
  1. Try cache match first
  2. If cached: return cached response
  3. If not cached: fetch from network, clone, cache the response, return original
  4. On fetch failure: return undefined (browser handles missing assets)

- For **everything else**: Pass through to network (no caching)

**Helper functions:**
- `isStaticAsset(url)`: Returns true if URL pathname matches static asset extensions or contains `/_next/static/`
- `networkFirstWithTimeout(request)`: Implements the timeout race pattern
- `cacheFirst(request)`: Implements cache-first with network fallback

**Critical constraints:**
- Do NOT add `self.addEventListener('fetch', ...)` if already defined. Since sw-cache.js is imported, it adds its own fetch listener which coexists with the main sw.js. Service workers support multiple listeners on the same event -- the first to call `event.respondWith()` wins.
- Do NOT cache responses with `status !== 200` (avoid caching error pages)
- Do NOT cache `POST` requests
- Only cache `GET` requests
  </action>
  <verify>
    - File exists at `public/sw-cache.js`
    - Contains CACHE_VERSION, install, activate, fetch event listeners
    - Contains networkFirstWithTimeout and cacheFirst functions
    - Does NOT contain push/notification handlers (those stay in sw.js)
  </verify>
  <done>
    - sw-cache.js implements cache-first for static assets and network-first with 3s timeout for navigation
    - Only same-origin GET requests are cached
    - Old cache versions are cleaned up on activate
    - API requests are passed through without caching
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand sw.js with importScripts</name>
  <files>public/sw.js</files>
  <action>
Update `public/sw.js` to import the caching module. Add `importScripts('/sw-cache.js')` as the FIRST line of the file (before any existing code). This ensures caching handlers are registered before push handlers, but since both use addEventListener, order within the file doesn't matter for event handling -- they coexist.

The updated sw.js structure:

```javascript
/**
 * KEWA Service Worker
 * Handles push notifications and offline caching
 * Phase: 24-push-notifications (push), 27-pwa-foundation (caching)
 */

// Load caching module (install/activate/fetch handlers)
importScripts('/sw-cache.js')

// Push event: display notification
self.addEventListener('push', (event) => {
  // ... existing code unchanged ...
})

// Notification click: navigate to entity URL
self.addEventListener('notificationclick', (event) => {
  // ... existing code unchanged ...
})

// Subscription change: update backend
self.addEventListener('pushsubscriptionchange', (event) => {
  // ... existing code unchanged ...
})
```

Do NOT modify the push, notificationclick, or pushsubscriptionchange handlers. They remain exactly as they are. Only add the importScripts line and update the file header comment.
  </action>
  <verify>
    - `head -5 public/sw.js` shows importScripts('/sw-cache.js') near the top
    - `grep "addEventListener('push'" public/sw.js` still finds the push handler
    - `grep "addEventListener('notificationclick'" public/sw.js` still finds the click handler
    - `grep "addEventListener('pushsubscriptionchange'" public/sw.js` still finds the subscription change handler
    - `npx next build` succeeds (sw.js is static, not compiled, but build should complete)
  </verify>
  <done>
    - sw.js imports sw-cache.js via importScripts
    - All three push notification handlers remain unchanged
    - Service worker now handles both push notifications and offline caching
  </done>
</task>

</tasks>

<verification>
1. `public/sw.js` starts with importScripts('/sw-cache.js')
2. `public/sw-cache.js` exists with install/activate/fetch handlers
3. All three push event listeners remain in sw.js unchanged
4. `npx next build` succeeds
5. No duplicate event listener registrations between sw.js and sw-cache.js
</verification>

<success_criteria>
- Service worker loads both push and caching modules
- Static assets (.js, .css, fonts, images) served cache-first after first visit
- Navigation requests served network-first with 3-second timeout, cache fallback
- API requests pass through without service worker caching
- Push notification handlers are byte-for-byte identical to Phase 24 implementation
- Old cache versions cleaned up on service worker activate
</success_criteria>

<output>
After completion, create `.planning/phases/27-pwa-foundation/27-02-SUMMARY.md`
</output>
