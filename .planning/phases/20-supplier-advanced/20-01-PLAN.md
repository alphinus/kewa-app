---
phase: 20-supplier-advanced
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/054_inventory_movements.sql
  - supabase/migrations/055_purchase_order_allocations.sql
  - supabase/migrations/056_inventory_views_functions.sql
  - src/types/suppliers.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "inventory_movements table accepts readings with tank level, property, and movement type"
    - "purchase_order_allocations table links PO to multiple properties with quantity splits"
    - "current_inventory_levels view returns latest level per property with projected empty date"
    - "get_reorder_alerts function returns properties below threshold with urgency classification"
    - "delivery_price_history view returns unit price (CHF/tonne) per delivery"
    - "seasonal_consumption view returns monthly aggregates per property"
    - "TypeScript types exist for InventoryMovement, PurchaseOrderAllocation, and all analytics shapes"
    - "recharts is installed and importable"
  artifacts:
    - path: "supabase/migrations/054_inventory_movements.sql"
      provides: "inventory_movements table with indexes and updated_at trigger"
      contains: "CREATE TABLE IF NOT EXISTS inventory_movements"
    - path: "supabase/migrations/055_purchase_order_allocations.sql"
      provides: "purchase_order_allocations table with validation trigger"
      contains: "CREATE TABLE IF NOT EXISTS purchase_order_allocations"
    - path: "supabase/migrations/056_inventory_views_functions.sql"
      provides: "Views and functions for analytics"
      contains: "CREATE VIEW current_inventory_levels"
    - path: "src/types/suppliers.ts"
      provides: "Extended types for inventory and allocations"
      contains: "InventoryMovement"
    - path: "package.json"
      provides: "recharts dependency"
      contains: "recharts"
  key_links:
    - from: "supabase/migrations/054_inventory_movements.sql"
      to: "properties table"
      via: "REFERENCES properties(id)"
      pattern: "property_id UUID.*REFERENCES properties"
    - from: "supabase/migrations/054_inventory_movements.sql"
      to: "deliveries table"
      via: "REFERENCES deliveries(id)"
      pattern: "delivery_id UUID.*REFERENCES deliveries"
    - from: "supabase/migrations/055_purchase_order_allocations.sql"
      to: "purchase_orders table"
      via: "REFERENCES purchase_orders(id)"
      pattern: "purchase_order_id UUID.*REFERENCES purchase_orders"
    - from: "supabase/migrations/056_inventory_views_functions.sql"
      to: "inventory_movements table"
      via: "SELECT FROM inventory_movements"
      pattern: "FROM inventory_movements"
---

<objective>
Create database schema for inventory tracking and multi-property order allocations, analytics views and functions, extend TypeScript types, and install recharts.

Purpose: Foundation layer for all Phase 20 features. Subsequent plans build API routes, UI components, and dashboard pages on top of these tables, views, and types.
Output: 3 migration files, extended types file, recharts installed.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/migrations/051_purchase_orders.sql
@supabase/migrations/052_deliveries.sql
@src/types/suppliers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create inventory_movements and purchase_order_allocations tables</name>
  <files>
    supabase/migrations/054_inventory_movements.sql
    supabase/migrations/055_purchase_order_allocations.sql
  </files>
  <action>
    Create migration 054_inventory_movements.sql:
    - Table `inventory_movements` with columns:
      - id UUID PK default gen_random_uuid()
      - property_id UUID NOT NULL REFERENCES properties(id)
      - building_id UUID REFERENCES buildings(id)
      - movement_type TEXT NOT NULL CHECK (movement_type IN ('delivery', 'reading', 'adjustment'))
      - movement_date DATE NOT NULL
      - tank_level DECIMAL(12,2) NOT NULL (current level in tonnes)
      - tank_capacity DECIMAL(12,2) (total tank capacity in tonnes)
      - level_percentage DECIMAL(5,2) GENERATED ALWAYS AS (CASE WHEN tank_capacity > 0 THEN (tank_level / tank_capacity) * 100 ELSE NULL END) STORED
      - days_since_last DECIMAL(8,2)
      - consumption_amount DECIMAL(12,2) (amount consumed since last reading)
      - daily_usage_rate DECIMAL(8,4) (consumption_amount / days_since_last)
      - delivery_id UUID REFERENCES deliveries(id) (for movement_type='delivery')
      - notes TEXT
      - created_by UUID REFERENCES users(id)
      - created_at TIMESTAMPTZ DEFAULT NOW()
      - updated_at TIMESTAMPTZ DEFAULT NOW()
    - Constraint: building_requires_property CHECK (building_id IS NULL OR property_id IS NOT NULL)
    - Constraint: delivery_requires_delivery_id CHECK (movement_type != 'delivery' OR delivery_id IS NOT NULL)
    - Indexes: property_id, movement_date DESC, delivery_id
    - updated_at trigger using existing update_updated_at() function
    - Comments on table and key columns

    Create migration 055_purchase_order_allocations.sql:
    - Table `purchase_order_allocations` with columns:
      - id UUID PK default gen_random_uuid()
      - purchase_order_id UUID NOT NULL REFERENCES purchase_orders(id) ON DELETE CASCADE
      - property_id UUID NOT NULL REFERENCES properties(id)
      - building_id UUID REFERENCES buildings(id)
      - allocated_quantity DECIMAL(12,2) NOT NULL CHECK (allocated_quantity > 0)
      - allocated_amount DECIMAL(12,2) NOT NULL CHECK (allocated_amount >= 0)
      - delivered BOOLEAN DEFAULT FALSE
      - delivery_id UUID REFERENCES deliveries(id)
      - notes TEXT
      - created_at TIMESTAMPTZ DEFAULT NOW()
      - updated_at TIMESTAMPTZ DEFAULT NOW()
    - Constraint: building_requires_property CHECK (building_id IS NULL OR property_id IS NOT NULL)
    - Validation trigger: validate_allocation_totals() — on INSERT or UPDATE, check SUM(allocated_amount) for this PO does not exceed purchase_orders.total_amount. Raise exception if exceeded.
    - Indexes: purchase_order_id, property_id
    - updated_at trigger
    - Comments

    Follow existing migration conventions from 051/052 (header comment, section separators, IF NOT EXISTS).
  </action>
  <verify>
    Run `npx supabase db reset` or verify SQL syntax with `npx supabase db lint` if available. Check tables are created without errors.
  </verify>
  <done>
    inventory_movements table exists with all columns, constraints, indexes. purchase_order_allocations table exists with validation trigger. Both tables have updated_at triggers and proper FK references.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create analytics views, reorder function, extend types, install recharts</name>
  <files>
    supabase/migrations/056_inventory_views_functions.sql
    src/types/suppliers.ts
    package.json
  </files>
  <action>
    Create migration 056_inventory_views_functions.sql with:

    1. View `current_inventory_levels`:
       ```sql
       CREATE VIEW current_inventory_levels AS
       SELECT DISTINCT ON (property_id)
         property_id,
         movement_date,
         tank_level,
         tank_capacity,
         level_percentage,
         daily_usage_rate,
         CASE WHEN daily_usage_rate > 0 THEN
           movement_date + (tank_level / daily_usage_rate)::INTEGER
         ELSE NULL END AS projected_empty_date
       FROM inventory_movements
       ORDER BY property_id, movement_date DESC, created_at DESC;
       ```

    2. View `delivery_price_history`:
       ```sql
       CREATE VIEW delivery_price_history AS
       SELECT
         d.id AS delivery_id,
         d.delivery_date,
         d.property_id,
         po.supplier_id,
         d.quantity_received,
         d.quantity_unit,
         po.total_amount,
         CASE WHEN d.quantity_received > 0 THEN po.total_amount / d.quantity_received ELSE NULL END AS unit_price,
         to_char(d.delivery_date, 'YYYY-MM') AS year_month,
         EXTRACT(YEAR FROM d.delivery_date)::INTEGER AS year,
         EXTRACT(MONTH FROM d.delivery_date)::INTEGER AS month,
         EXTRACT(QUARTER FROM d.delivery_date)::INTEGER AS quarter
       FROM deliveries d
       JOIN purchase_orders po ON d.purchase_order_id = po.id
       ORDER BY d.delivery_date DESC;
       ```

    3. View `seasonal_consumption`:
       ```sql
       CREATE VIEW seasonal_consumption AS
       SELECT
         property_id,
         year,
         month,
         quarter,
         COUNT(*) AS delivery_count,
         SUM(quantity_received) AS total_quantity,
         AVG(quantity_received) AS avg_quantity_per_delivery,
         AVG(unit_price) AS avg_unit_price
       FROM delivery_price_history
       GROUP BY property_id, year, month, quarter
       ORDER BY property_id, year, month;
       ```

    4. Function `get_reorder_alerts(threshold_pct)`:
       Returns TABLE (property_id UUID, current_level DECIMAL, tank_capacity DECIMAL, level_percentage DECIMAL, daily_usage_rate DECIMAL, days_until_empty INTEGER, projected_empty_date DATE, urgency TEXT).
       Query from current_inventory_levels WHERE level_percentage <= threshold_pct AND daily_usage_rate IS NOT NULL.
       Urgency: 'critical' if days_until_empty <= 7, 'warning' if <= 14, else 'normal'.
       Order by days_until_empty ASC NULLS LAST.

    Comments on each view and function.

    Extend src/types/suppliers.ts — ADD (do not remove any existing content) the following types after existing types:

    - InventoryMovementType = 'delivery' | 'reading' | 'adjustment'
    - InventoryMovement interface matching 054 table columns plus optional joined fields (property?: { id, name }, delivery?: { id, delivery_date })
    - CreateInventoryMovementInput (property_id, movement_type, movement_date, tank_level, tank_capacity?, building_id?, delivery_id?, notes?)
    - CurrentInventoryLevel interface (property_id, movement_date, tank_level, tank_capacity, level_percentage, daily_usage_rate, projected_empty_date)
    - ReorderAlert interface (property_id, property_name, current_level, tank_capacity, level_percentage, daily_usage_rate, days_until_empty, projected_empty_date, urgency: 'critical' | 'warning' | 'normal')
    - PriceHistoryPoint (delivery_id, delivery_date, property_id, supplier_id, quantity_received, unit_price, year_month, year, month)
    - SeasonalConsumption (property_id, year, month, quarter, delivery_count, total_quantity, avg_quantity_per_delivery, avg_unit_price)
    - PurchaseOrderAllocation interface matching 055 table columns plus optional joined fields (property?: { id, name }, delivery?: { id, delivery_date })
    - CreateAllocationInput (purchase_order_id, property_id, building_id?, allocated_quantity, allocated_amount, notes?)
    - API response types: InventoryMovementsResponse, ReorderAlertsResponse, PriceHistoryResponse, SeasonalConsumptionResponse, AllocationsResponse

    Install recharts: `npm install recharts`
  </action>
  <verify>
    - `grep -c "InventoryMovement" src/types/suppliers.ts` returns > 0
    - `grep -c "PurchaseOrderAllocation" src/types/suppliers.ts` returns > 0
    - `grep -c "ReorderAlert" src/types/suppliers.ts` returns > 0
    - `grep "recharts" package.json` shows recharts in dependencies
    - `npx tsc --noEmit` passes (no type errors from new types)
  </verify>
  <done>
    3 views and 1 function exist in migration. TypeScript types cover all new entities and API responses. Recharts installed.
  </done>
</task>

</tasks>

<verification>
- All 3 migration files parse valid SQL
- Types compile without errors: `npx tsc --noEmit`
- recharts is in package.json dependencies
- Existing supplier types unchanged (PurchaseOrder, Delivery, etc.)
</verification>

<success_criteria>
- inventory_movements table with level tracking, usage rate calculation columns, and proper FK references
- purchase_order_allocations table with validation trigger preventing over-allocation
- current_inventory_levels view returning latest level per property with stock-out projection
- delivery_price_history view calculating unit_price from deliveries
- seasonal_consumption view aggregating by property/year/month
- get_reorder_alerts function classifying urgency
- All new TypeScript types importable from @/types/suppliers
- recharts importable for chart components
</success_criteria>

<output>
After completion, create `.planning/phases/20-supplier-advanced/20-01-SUMMARY.md`
</output>
