---
phase: 19-supplier-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/suppliers/status-utils.ts
  - src/lib/suppliers/purchase-order-queries.ts
  - src/app/api/purchase-orders/route.ts
  - src/app/api/purchase-orders/[id]/route.ts
  - src/app/api/purchase-orders/[id]/status/route.ts
  - src/components/suppliers/PurchaseOrderForm.tsx
  - src/components/suppliers/PurchaseOrderList.tsx
  - src/components/suppliers/PurchaseOrderStatusBadge.tsx
autonomous: true

must_haves:
  truths:
    - "User can create a purchase order with line items"
    - "User can view list of purchase orders with status filters"
    - "User can transition purchase order through status workflow"
    - "Status badges show correct German labels and colors"
  artifacts:
    - path: "src/lib/suppliers/status-utils.ts"
      provides: "Status labels, colors, and transition validation"
      exports: ["getPurchaseOrderStatusLabel", "getPurchaseOrderStatusColor", "canTransitionTo"]
    - path: "src/app/api/purchase-orders/route.ts"
      provides: "Purchase order list and create endpoints"
      exports: ["GET", "POST"]
    - path: "src/app/api/purchase-orders/[id]/status/route.ts"
      provides: "Status transition endpoint"
      exports: ["POST"]
    - path: "src/components/suppliers/PurchaseOrderForm.tsx"
      provides: "Form for creating/editing purchase orders"
      min_lines: 100
    - path: "src/components/suppliers/PurchaseOrderList.tsx"
      provides: "List component with status filters"
      min_lines: 80
  key_links:
    - from: "src/components/suppliers/PurchaseOrderForm.tsx"
      to: "/api/purchase-orders"
      via: "fetch POST on submit"
      pattern: "fetch.*api/purchase-orders"
    - from: "src/app/api/purchase-orders/[id]/status/route.ts"
      to: "src/lib/suppliers/status-utils.ts"
      via: "transition validation"
      pattern: "canTransitionTo"
---

<objective>
Implement purchase order CRUD operations with status workflow, including API endpoints and UI components.

Purpose: Enable users to create purchase orders for suppliers and track them through the ordered -> confirmed -> delivered -> invoiced workflow.
Output: Status utilities, API routes for PO management, form and list components.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-supplier-core/19-RESEARCH.md

# Existing patterns to follow
@src/lib/costs/invoice-queries.ts
@src/app/api/invoices/route.ts
@src/components/costs/InvoiceForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create status utilities and query helpers</name>
  <files>
    src/lib/suppliers/status-utils.ts
    src/lib/suppliers/purchase-order-queries.ts
  </files>
  <action>
1. Create src/lib/suppliers/status-utils.ts following pattern from invoice-queries.ts:

```typescript
export type PurchaseOrderStatus =
  | 'draft'
  | 'ordered'
  | 'confirmed'
  | 'delivered'
  | 'invoiced'
  | 'cancelled'

// German labels
export function getPurchaseOrderStatusLabel(status: PurchaseOrderStatus): string {
  const labels: Record<PurchaseOrderStatus, string> = {
    draft: 'Entwurf',
    ordered: 'Bestellt',
    confirmed: 'Bestaetigt',
    delivered: 'Geliefert',
    invoiced: 'Verrechnet',
    cancelled: 'Storniert',
  }
  return labels[status] ?? status
}

// Status colors (Tailwind classes)
export function getPurchaseOrderStatusColor(status: PurchaseOrderStatus): string {
  const colors: Record<PurchaseOrderStatus, string> = {
    draft: 'bg-gray-100 text-gray-800',
    ordered: 'bg-blue-100 text-blue-800',
    confirmed: 'bg-purple-100 text-purple-800',
    delivered: 'bg-green-100 text-green-800',
    invoiced: 'bg-gray-100 text-gray-600',
    cancelled: 'bg-red-100 text-red-800',
  }
  return colors[status] ?? 'bg-gray-100 text-gray-800'
}

// Valid transitions (mirrors database trigger)
export const VALID_PO_TRANSITIONS: Record<PurchaseOrderStatus, PurchaseOrderStatus[]> = {
  draft: ['ordered', 'cancelled'],
  ordered: ['confirmed', 'cancelled'],
  confirmed: ['delivered', 'cancelled'],
  delivered: ['invoiced'],
  invoiced: [],
  cancelled: [],
}

export function canTransitionTo(
  current: PurchaseOrderStatus,
  target: PurchaseOrderStatus
): boolean {
  return VALID_PO_TRANSITIONS[current]?.includes(target) ?? false
}

export function getNextActions(status: PurchaseOrderStatus): PurchaseOrderStatus[] {
  return VALID_PO_TRANSITIONS[status] ?? []
}
```

2. Create src/lib/suppliers/purchase-order-queries.ts with helper functions:

```typescript
import { createClient } from '@/lib/supabase/server'
import type { PurchaseOrder, PurchaseOrderLineItem } from '@/types/suppliers'

// Calculate total from line items
export function calculateLineItemsTotal(items: PurchaseOrderLineItem[]): number {
  return items.reduce((sum, item) => sum + item.total, 0)
}

// Generate new line item with UUID
export function createLineItem(partial: Omit<PurchaseOrderLineItem, 'id' | 'total'>): PurchaseOrderLineItem {
  return {
    id: crypto.randomUUID(),
    ...partial,
    total: partial.quantity * partial.unit_price,
  }
}

// Format order number for display
export function formatOrderNumber(orderNumber: string): string {
  return orderNumber // Already formatted as PO-YYYY-NNNNN
}

// Format CHF amount (reuse from invoice-queries if available)
export function formatCHF(amount: number): string {
  return new Intl.NumberFormat('de-CH', {
    style: 'currency',
    currency: 'CHF',
  }).format(amount)
}
```
  </action>
  <verify>
TypeScript: npx tsc --noEmit
Import test: Add temporary import in any existing file to verify exports work
  </verify>
  <done>
Status utilities export label/color/transition functions.
Query helpers export calculation and formatting functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create purchase order API routes</name>
  <files>
    src/app/api/purchase-orders/route.ts
    src/app/api/purchase-orders/[id]/route.ts
    src/app/api/purchase-orders/[id]/status/route.ts
  </files>
  <action>
1. Create src/app/api/purchase-orders/route.ts:

GET endpoint:
- Accept query params: supplier_id, status, limit, offset
- Join with partners to get supplier name
- Order by created_at DESC
- Return { purchase_orders, total, limit, offset }

POST endpoint:
- Validate: supplier_id required, line_items required and non-empty
- Verify supplier exists and is type='supplier'
- Calculate total_amount from line_items
- Generate order_number via RPC call to generate_purchase_order_number
- Insert with status='draft' (or 'ordered' if specified)
- Return { purchase_order } with 201 status

Follow exact auth pattern from src/app/api/partners/route.ts (x-user-id, x-user-role headers).

2. Create src/app/api/purchase-orders/[id]/route.ts:

GET: Return single purchase order with supplier join
PATCH: Update allowed fields (line_items, expected_delivery_date, notes) - NOT status
DELETE: Only if status='draft', otherwise return 400

3. Create src/app/api/purchase-orders/[id]/status/route.ts:

POST endpoint:
- Accept { status: PurchaseOrderStatus } in body
- Validate transition using canTransitionTo from status-utils
- If invalid, return 400 with error message listing valid transitions
- Update status (database trigger handles timestamp)
- Return updated purchase order

This pattern ensures status changes go through validation both client-side and database-side.
  </action>
  <verify>
Start dev server: npm run dev
Test create: curl -X POST http://localhost:3000/api/purchase-orders with valid body
Test list: curl http://localhost:3000/api/purchase-orders
Test status: curl -X POST http://localhost:3000/api/purchase-orders/{id}/status -d '{"status":"ordered"}'
  </verify>
  <done>
Purchase order CRUD API works with auth middleware.
Status transitions validated in API and database.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create purchase order UI components</name>
  <files>
    src/components/suppliers/PurchaseOrderForm.tsx
    src/components/suppliers/PurchaseOrderList.tsx
    src/components/suppliers/PurchaseOrderStatusBadge.tsx
    src/components/suppliers/LineItemEditor.tsx
  </files>
  <action>
1. Create src/components/suppliers/PurchaseOrderStatusBadge.tsx:
- Simple component using getPurchaseOrderStatusLabel and getPurchaseOrderStatusColor
- Props: { status: PurchaseOrderStatus, size?: 'sm' | 'md' }
- Render as span with Tailwind classes

2. Create src/components/suppliers/LineItemEditor.tsx:
- Reusable line item editor (add, edit, remove items)
- Props: { items: PurchaseOrderLineItem[], onChange: (items) => void }
- Each row: description, quantity, unit, unit_price, calculated total
- Add item button, remove button per row
- Auto-calculate total on quantity/price change
- Use createLineItem helper for new items

3. Create src/components/suppliers/PurchaseOrderForm.tsx:
- Props: { supplierId?: string, onSave: (po) => void, onCancel: () => void }
- Fields:
  - Supplier dropdown (fetch from /api/suppliers, pre-select if supplierId provided)
  - Expected delivery date (date input)
  - Line items (use LineItemEditor component)
  - Notes (textarea)
- Calculate and display total amount
- Submit creates PO via POST /api/purchase-orders
- Show loading state during save
- Use Card, CardHeader, CardContent, CardFooter from ui components

4. Create src/components/suppliers/PurchaseOrderList.tsx:
- Props: { supplierId?: string } (optional filter)
- Fetch from /api/purchase-orders with supplierId filter if provided
- Display as table: Order #, Supplier, Total, Expected Date, Status, Actions
- Status filter dropdown (all, draft, ordered, confirmed, delivered, invoiced, cancelled)
- Link order number to detail page
- Show empty state if no orders

Follow existing component patterns from src/components/costs/ for styling consistency.
  </action>
  <verify>
TypeScript: npx tsc --noEmit
Visual: Import components in a test page and verify rendering
  </verify>
  <done>
PurchaseOrderForm creates new purchase orders with line items.
PurchaseOrderList displays orders with status filtering.
StatusBadge shows correct German labels and colors.
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit` passes
2. API: All endpoints return correct responses
3. Components: Form submits successfully, List displays data
4. Status: Transitions work through UI -> API -> Database
</verification>

<success_criteria>
- Status utilities provide German labels and valid transition checks
- Purchase order API supports full CRUD with proper auth
- Status endpoint validates and executes transitions
- Form component creates POs with line items
- List component displays and filters POs by status
</success_criteria>

<output>
After completion, create `.planning/phases/19-supplier-core/19-02-SUMMARY.md`
</output>
