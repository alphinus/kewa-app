---
phase: 19-supplier-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/051_purchase_orders.sql
  - supabase/migrations/052_deliveries.sql
  - src/types/suppliers.ts
  - src/app/api/suppliers/route.ts
autonomous: true

must_haves:
  truths:
    - "Purchase order table exists with status enum and line items JSONB"
    - "Deliveries table exists with property/building association"
    - "TypeScript types match database schema"
    - "Suppliers endpoint returns partners filtered by type='supplier'"
  artifacts:
    - path: "supabase/migrations/051_purchase_orders.sql"
      provides: "purchase_orders table with status workflow"
      contains: "CREATE TABLE.*purchase_orders"
    - path: "supabase/migrations/052_deliveries.sql"
      provides: "deliveries table with property association"
      contains: "CREATE TABLE.*deliveries"
    - path: "src/types/suppliers.ts"
      provides: "PurchaseOrder, Delivery, LineItem types"
      exports: ["PurchaseOrder", "Delivery", "PurchaseOrderLineItem"]
    - path: "src/app/api/suppliers/route.ts"
      provides: "Supplier list API (filtered partners)"
      exports: ["GET"]
  key_links:
    - from: "src/types/suppliers.ts"
      to: "supabase/migrations/051_purchase_orders.sql"
      via: "Type definitions match table columns"
      pattern: "status.*PurchaseOrderStatus"
    - from: "supabase/migrations/052_deliveries.sql"
      to: "supabase/migrations/051_purchase_orders.sql"
      via: "Foreign key reference"
      pattern: "REFERENCES purchase_orders"
---

<objective>
Create database schema for purchase orders and deliveries, with TypeScript types and supplier listing API.

Purpose: Establish the data foundation for supplier management. Purchase orders track what's ordered from suppliers, deliveries track what actually arrived and where.
Output: Two migration files, types module, and supplier API endpoint.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-supplier-core/19-RESEARCH.md

# Existing patterns to follow
@supabase/migrations/017_offer.sql
@supabase/migrations/025_work_order_status.sql
@src/types/database.ts
@src/app/api/partners/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create purchase_orders migration</name>
  <files>supabase/migrations/051_purchase_orders.sql</files>
  <action>
Create migration following patterns from 017_offer.sql and 025_work_order_status.sql:

1. Create purchase_order_status enum:
   - draft, ordered, confirmed, delivered, invoiced, cancelled

2. Create purchase_order_seq sequence for order numbers (PO-YYYY-NNNNN)

3. Create purchase_orders table with columns:
   - id UUID PRIMARY KEY
   - supplier_id UUID NOT NULL REFERENCES partners(id)
   - order_number TEXT UNIQUE (generated via function)
   - status purchase_order_status DEFAULT 'draft'
   - line_items JSONB DEFAULT '[]' (same pattern as offers)
   - total_amount DECIMAL(12,2) NOT NULL
   - currency TEXT DEFAULT 'CHF'
   - expected_delivery_date DATE
   - notes TEXT
   - Status timestamps: ordered_at, confirmed_at, delivered_at, invoiced_at, cancelled_at
   - Metadata: created_by, created_at, updated_at

4. Create generate_purchase_order_number(p_year INTEGER) function using sequence

5. Create validate_purchase_order_status_transition() trigger function:
   - Valid transitions: draft->ordered->confirmed->delivered->invoiced, any state->cancelled except invoiced
   - Auto-set timestamps on status change

6. Create indexes on supplier_id, status, expected_delivery_date

7. Add table and column comments

Follow the JSONB trigger pattern from 025 for status transitions.
  </action>
  <verify>
Run: npx supabase db reset --local
Check migration applies without errors.
Verify: SELECT * FROM pg_type WHERE typname = 'purchase_order_status';
Verify: SELECT generate_purchase_order_number(2026);
  </verify>
  <done>
purchase_orders table exists with status enum, sequence function, and transition trigger.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create deliveries migration</name>
  <files>supabase/migrations/052_deliveries.sql</files>
  <action>
Create deliveries table following research pattern:

1. Create deliveries table with columns:
   - id UUID PRIMARY KEY
   - purchase_order_id UUID NOT NULL REFERENCES purchase_orders(id)
   - delivery_date DATE NOT NULL
   - delivery_note_number TEXT (Lieferschein-Nr.)
   - quantity_ordered DECIMAL(12,2) NOT NULL
   - quantity_received DECIMAL(12,2) NOT NULL
   - quantity_unit TEXT NOT NULL DEFAULT 'Tonnen'
   - has_variance BOOLEAN GENERATED ALWAYS AS (quantity_received != quantity_ordered) STORED
   - variance_note TEXT
   - property_id UUID REFERENCES properties(id)
   - building_id UUID REFERENCES buildings(id)
   - invoice_id UUID REFERENCES invoices(id)
   - notes TEXT
   - created_by UUID REFERENCES users(id)
   - created_at, updated_at TIMESTAMPTZ

2. Create indexes:
   - deliveries_purchase_order_idx
   - deliveries_property_idx
   - deliveries_invoice_idx
   - deliveries_date_idx (DESC for recent-first)

3. Create updated_at trigger

4. Create check constraint: building_id only valid if property_id is set
   CHECK (building_id IS NULL OR property_id IS NOT NULL)

5. Add table and column comments
  </action>
  <verify>
Run: npx supabase db reset --local
Verify: \d deliveries shows all columns and constraints
Verify: has_variance computed column works:
  INSERT INTO deliveries (purchase_order_id, delivery_date, quantity_ordered, quantity_received, quantity_unit)
  SELECT id, CURRENT_DATE, 10.0, 9.5, 'Tonnen' FROM purchase_orders LIMIT 1;
  SELECT has_variance FROM deliveries; -- should be true
  </verify>
  <done>
deliveries table exists with property association, invoice linking, and variance tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create TypeScript types and supplier API</name>
  <files>
    src/types/suppliers.ts
    src/app/api/suppliers/route.ts
  </files>
  <action>
1. Create src/types/suppliers.ts with:

```typescript
// Status enum matching database
export type PurchaseOrderStatus =
  | 'draft'
  | 'ordered'
  | 'confirmed'
  | 'delivered'
  | 'invoiced'
  | 'cancelled'

// Line item structure (matches offers pattern)
export interface PurchaseOrderLineItem {
  id: string
  description: string
  quantity: number
  unit: string
  unit_price: number
  total: number
}

// Purchase Order entity
export interface PurchaseOrder {
  id: string
  supplier_id: string
  order_number: string
  status: PurchaseOrderStatus
  line_items: PurchaseOrderLineItem[]
  total_amount: number
  currency: string
  expected_delivery_date: string | null
  notes: string | null
  ordered_at: string | null
  confirmed_at: string | null
  delivered_at: string | null
  invoiced_at: string | null
  cancelled_at: string | null
  created_by: string | null
  created_at: string
  updated_at: string
  // Joined fields
  supplier?: {
    id: string
    company_name: string
  }
}

// Delivery entity
export interface Delivery {
  id: string
  purchase_order_id: string
  delivery_date: string
  delivery_note_number: string | null
  quantity_ordered: number
  quantity_received: number
  quantity_unit: string
  has_variance: boolean
  variance_note: string | null
  property_id: string | null
  building_id: string | null
  invoice_id: string | null
  notes: string | null
  created_by: string | null
  created_at: string
  updated_at: string
  // Joined fields
  purchase_order?: PurchaseOrder
  property?: { id: string; name: string }
  building?: { id: string; name: string }
  invoice?: { id: string; invoice_number: string }
}

// Input types for API
export interface CreatePurchaseOrderInput {
  supplier_id: string
  line_items: PurchaseOrderLineItem[]
  expected_delivery_date?: string
  notes?: string
  status?: 'draft' | 'ordered'
}

export interface CreateDeliveryInput {
  purchase_order_id: string
  delivery_date: string
  delivery_note_number?: string
  quantity_ordered: number
  quantity_received: number
  quantity_unit: string
  property_id: string
  building_id?: string
  variance_note?: string
  notes?: string
}
```

2. Create src/app/api/suppliers/route.ts:

```typescript
// GET /api/suppliers - List suppliers (partners with type='supplier')
// Thin wrapper around partners API with fixed type filter
```

Follow the exact pattern from src/app/api/partners/route.ts but:
- Hard-code type filter to 'supplier'
- Remove type parameter from query params
- Keep is_active, limit, offset filters
- Return { suppliers, total, limit, offset }
  </action>
  <verify>
TypeScript: npx tsc --noEmit (no type errors)
API test: curl http://localhost:3000/api/suppliers returns empty array or existing suppliers
  </verify>
  <done>
TypeScript types exist for PurchaseOrder, Delivery, line items.
Supplier API returns partners filtered by type='supplier'.
  </done>
</task>

</tasks>

<verification>
1. Database: Both migrations apply cleanly with `npx supabase db reset --local`
2. Types: `npx tsc --noEmit` passes without errors
3. API: GET /api/suppliers returns JSON with suppliers array
4. Schema: purchase_orders and deliveries tables visible in Supabase Studio
</verification>

<success_criteria>
- purchase_orders table exists with status enum and timestamp triggers
- deliveries table exists with property association and variance tracking
- TypeScript types match database schema exactly
- Supplier API endpoint works with auth middleware
</success_criteria>

<output>
After completion, create `.planning/phases/19-supplier-core/19-01-SUMMARY.md`
</output>
