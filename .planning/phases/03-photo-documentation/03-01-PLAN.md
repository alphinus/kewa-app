---
phase: 03-photo-documentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/003_task_photos.sql
  - src/types/database.ts
  - src/lib/imageCompression.ts
  - src/app/api/photos/route.ts
  - src/app/api/photos/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Photos can be uploaded to Supabase Storage"
    - "Photo metadata is stored in database with task reference"
    - "Photos are compressed before upload (max 720px, WebP)"
    - "Photos can be deleted by their creator"
  artifacts:
    - path: "supabase/migrations/003_task_photos.sql"
      provides: "Task photos table with foreign keys and indexes"
      contains: "CREATE TABLE task_photos"
    - path: "src/lib/imageCompression.ts"
      provides: "Browser-side image compression utility"
      exports: ["compressImage"]
    - path: "src/app/api/photos/route.ts"
      provides: "Photo upload and list API"
      exports: ["GET", "POST"]
    - path: "src/app/api/photos/[id]/route.ts"
      provides: "Photo delete API"
      exports: ["DELETE"]
  key_links:
    - from: "src/app/api/photos/route.ts"
      to: "Supabase Storage"
      via: "supabase.storage.from('task-photos').upload()"
      pattern: "storage.*upload"
    - from: "src/app/api/photos/route.ts"
      to: "task_photos table"
      via: "supabase.from('task_photos').insert()"
      pattern: "from\\('task_photos'\\)"
---

<objective>
Set up photo storage infrastructure and upload API for task documentation.

Purpose: Enable KEWA and Imeri to attach photos to tasks. This is the core value of the app - proof of completed work with timestamps.
Output: Database schema for photos, Supabase Storage bucket, compression utility, and CRUD API endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (task structure we're extending)
@.planning/phases/02-task-management/02-01-SUMMARY.md

# Existing code to extend
@src/types/database.ts
@src/lib/supabase/server.ts
@supabase/migrations/001_initial_schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create task_photos database schema</name>
  <files>supabase/migrations/003_task_photos.sql</files>
  <action>
Create migration file with:

1. **task_photos table:**
   - id (UUID, primary key)
   - task_id (UUID, references tasks, ON DELETE CASCADE)
   - photo_type ('explanation' | 'completion') - KEWA adds explanation, Imeri adds completion
   - storage_path (TEXT) - path in Supabase Storage bucket
   - file_name (TEXT) - original filename for display
   - file_size (INTEGER) - size in bytes
   - uploaded_by (UUID, references users)
   - created_at (TIMESTAMPTZ)

2. **Indexes:**
   - idx_task_photos_task_id ON task_photos(task_id)
   - idx_task_photos_type ON task_photos(task_id, photo_type)

3. **Constraints:**
   - CHECK (photo_type IN ('explanation', 'completion'))
   - Max 2 photos per type per task enforced at API level (easier to change)

4. **Storage bucket policy (as SQL comment):**
   Document that 'task-photos' bucket needs:
   - Authenticated users can upload to their own folder
   - All authenticated users can read all photos
   - Only uploader can delete their photos

Use deterministic UUIDs for any seed data (follow pattern from 001_initial_schema.sql).
  </action>
  <verify>SQL syntax valid (review manually), follows existing migration patterns</verify>
  <done>Migration file created with task_photos table, indexes, and storage policy documentation</done>
</task>

<task type="auto">
  <name>Task 2: Add photo types and create compression utility</name>
  <files>src/types/database.ts, src/lib/imageCompression.ts</files>
  <action>
**In src/types/database.ts, add:**

1. PhotoType = 'explanation' | 'completion'

2. TaskPhoto interface:
   - id: string
   - task_id: string
   - photo_type: PhotoType
   - storage_path: string
   - file_name: string
   - file_size: number
   - uploaded_by: string
   - created_at: string

3. TaskPhotoWithUrl extends TaskPhoto:
   - url: string (signed URL from storage)

4. CreatePhotoInput:
   - task_id: string
   - photo_type: PhotoType
   - file: File (for client-side)

5. PhotosResponse:
   - photos: TaskPhotoWithUrl[]

**Create src/lib/imageCompression.ts:**

Use browser-native Canvas API (no external library needed for basic compression):

```typescript
export interface CompressionOptions {
  maxWidth?: number      // Default 720
  maxHeight?: number     // Default 720
  quality?: number       // Default 0.8
  outputFormat?: 'webp' | 'jpeg'  // Default 'webp'
}

export async function compressImage(
  file: File,
  options?: CompressionOptions
): Promise<Blob>
```

Implementation:
1. Create Image element, load file as data URL
2. Create canvas with target dimensions (maintain aspect ratio)
3. Draw image to canvas
4. Export as WebP (or JPEG fallback for Safari < 14)
5. Return compressed Blob

Include WebP support detection:
```typescript
export function supportsWebP(): boolean {
  const canvas = document.createElement('canvas')
  return canvas.toDataURL('image/webp').startsWith('data:image/webp')
}
```

Target: 720px max dimension, 0.8 quality = typically 50-100KB from phone photos.
  </action>
  <verify>npm run type-check passes, compression utility exports correctly</verify>
  <done>Photo types added to database.ts, imageCompression.ts created with canvas-based compression</done>
</task>

<task type="auto">
  <name>Task 3: Create photo upload and list API</name>
  <files>src/app/api/photos/route.ts</files>
  <action>
Create API route with:

**GET /api/photos?task_id={id}**
- Requires authentication (check session)
- Query task_photos where task_id matches
- Generate signed URLs for each photo (1 hour expiry)
- Return PhotosResponse

**POST /api/photos**
- Requires authentication
- Accept multipart/form-data with:
  - file: compressed image blob
  - task_id: string
  - photo_type: 'explanation' | 'completion'
- Validate:
  - User is authenticated
  - Task exists
  - photo_type is valid
  - Max 2 photos of this type for this task not exceeded
  - KEWA can only add 'explanation', Imeri can only add 'completion'
- Generate storage path: `{task_id}/{photo_type}/{uuid}.webp`
- Upload to 'task-photos' bucket using server Supabase client
- Insert record into task_photos table
- Return created photo with signed URL

**Error handling:**
- 401 for unauthenticated
- 400 for invalid input
- 403 for wrong role/photo_type combination
- 409 for max photos exceeded
- 500 for storage/database errors

**Retry-friendly:**
- Use unique UUID per upload (no conflicts on retry)
- Transaction: only insert DB record after storage upload succeeds
  </action>
  <verify>npm run type-check passes, API structure matches existing patterns in src/app/api/tasks/</verify>
  <done>Photo upload and list API created with proper validation and error handling</done>
</task>

<task type="auto">
  <name>Task 4: Create photo delete API</name>
  <files>src/app/api/photos/[id]/route.ts</files>
  <action>
Create API route with:

**DELETE /api/photos/[id]**
- Requires authentication
- Get photo record from task_photos
- Validate:
  - Photo exists (404 if not)
  - Current user is the uploader (403 if not)
- Delete from Supabase Storage first
- Delete from task_photos table
- Return { success: true }

**Error handling:**
- 401 for unauthenticated
- 403 for wrong user (not the uploader)
- 404 for photo not found
- 500 for storage/database errors

**Clean deletion:**
- Delete storage first (if DB delete fails, orphaned storage is okay)
- If storage delete fails but file doesn't exist, continue (idempotent)
  </action>
  <verify>npm run type-check passes, follows delete pattern from src/app/api/tasks/[id]/route.ts</verify>
  <done>Photo delete API created with proper authorization and cleanup</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run type-check` passes
- [ ] Migration file has valid SQL syntax
- [ ] Photo types match migration schema
- [ ] imageCompression.ts exports compressImage function
- [ ] GET /api/photos returns PhotosResponse type
- [ ] POST /api/photos handles multipart/form-data
- [ ] DELETE /api/photos/[id] validates ownership
- [ ] All error cases return appropriate status codes
</verification>

<success_criteria>
- All tasks completed
- Type checking passes
- Database schema ready for migration
- Compression utility ready for client use
- Photo CRUD API matches existing patterns
- Authorization rules enforced (KEWA=explanation, Imeri=completion)
</success_criteria>

<output>
After completion, create `.planning/phases/03-photo-documentation/03-01-SUMMARY.md`
</output>
