---
phase: 18-knowledge-base
plan: 04
type: execute
wave: 3
depends_on: ["18-02"]
files_modified:
  - supabase/migrations/049_kb_attachments.sql
  - src/types/knowledge-base.ts
  - src/components/knowledge/AttachmentUploader.tsx
  - src/components/knowledge/AttachmentList.tsx
  - src/components/knowledge/ApprovalWorkflow.tsx
  - src/app/api/knowledge/[id]/attachments/route.ts
  - src/app/api/knowledge/[id]/status/route.ts
autonomous: true

must_haves:
  truths:
    - "User can attach files (PDFs, images) to articles"
    - "User can view and download attachments from articles"
    - "User can submit article for review"
    - "Admin can approve or reject articles in review"
    - "Article status follows workflow: draft -> review -> published"
  artifacts:
    - path: "src/components/knowledge/AttachmentUploader.tsx"
      provides: "File upload component for KB attachments"
      min_lines: 40
    - path: "src/components/knowledge/ApprovalWorkflow.tsx"
      provides: "Status change controls based on workflow state"
      min_lines: 50
    - path: "src/app/api/knowledge/[id]/attachments/route.ts"
      provides: "Attachment upload and list API"
      exports: ["GET", "POST", "DELETE"]
    - path: "src/app/api/knowledge/[id]/status/route.ts"
      provides: "Status transition API with validation"
      exports: ["PUT"]
  key_links:
    - from: "src/components/knowledge/AttachmentUploader.tsx"
      to: "/api/knowledge/[id]/attachments"
      via: "FormData POST"
      pattern: "fetch.*attachments.*POST"
    - from: "src/components/knowledge/ApprovalWorkflow.tsx"
      to: "/api/knowledge/[id]/status"
      via: "PUT request"
      pattern: "fetch.*status.*PUT"
    - from: "src/app/api/knowledge/[id]/status/route.ts"
      to: "kb_workflow_transitions"
      via: "Trigger logs transition"
      pattern: "status.*=.*review|published|draft"
---

<objective>
Implement file attachments for articles and the approval workflow for publishing. Users can upload PDFs and images to articles. Articles must be submitted for review and approved by admin before becoming published.

Purpose: Attachments support policy documents, guides with downloadable templates. Approval workflow ensures content quality before contractor visibility.
Output: Attachment upload/view components, workflow status controls, and supporting API endpoints.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-knowledge-base/18-CONTEXT.md
@.planning/phases/18-knowledge-base/18-RESEARCH.md
@.planning/phases/18-knowledge-base/18-01-SUMMARY.md
@.planning/phases/18-knowledge-base/18-02-SUMMARY.md
@src/types/knowledge-base.ts
@src/components/upload/FileUploader.tsx
@supabase/migrations/015_media.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create attachments schema and storage</name>
  <files>
    supabase/migrations/049_kb_attachments.sql
    src/types/knowledge-base.ts
  </files>
  <action>
**supabase/migrations/049_kb_attachments.sql**:
```sql
-- Knowledge Base Attachments
-- Stores file attachments for articles (PDFs, images, docs)

CREATE TABLE IF NOT EXISTS kb_attachments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  article_id UUID NOT NULL REFERENCES kb_articles(id) ON DELETE CASCADE,
  file_name TEXT NOT NULL,
  file_size INTEGER NOT NULL,
  mime_type TEXT NOT NULL,
  storage_path TEXT NOT NULL, -- Path in Supabase Storage
  description TEXT,
  uploaded_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_kb_attachments_article ON kb_attachments(article_id);

-- Register in storage_metadata for cleanup tracking (if table exists)
-- INSERT INTO storage_metadata pattern from existing codebase

COMMENT ON TABLE kb_attachments IS 'File attachments for knowledge base articles';
COMMENT ON COLUMN kb_attachments.storage_path IS 'Path in Supabase Storage: kb_articles/{article_id}/attachments/{uuid}.{ext}';
```

**Update src/types/knowledge-base.ts** - add attachment types:
```typescript
export interface KBAttachment {
  id: string
  article_id: string
  file_name: string
  file_size: number
  mime_type: string
  storage_path: string
  description: string | null
  uploaded_by: string | null
  created_at: string
}

export interface KBAttachmentWithUrl extends KBAttachment {
  url: string // Signed URL for download
}

export interface UploadKBAttachmentInput {
  file: File
  description?: string
}
```

Storage path convention: `kb_articles/{article_id}/attachments/{uuid}.{ext}`
Use existing `media` bucket (per RESEARCH.md recommendation).
  </action>
  <verify>
Run `npm run type-check` - should pass.
Verify migration syntax is valid SQL.
  </verify>
  <done>
Attachments table created with proper indexes and FK constraints. TypeScript types added for attachments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create attachment upload/view components and API</name>
  <files>
    src/components/knowledge/AttachmentUploader.tsx
    src/components/knowledge/AttachmentList.tsx
    src/app/api/knowledge/[id]/attachments/route.ts
  </files>
  <action>
**src/components/knowledge/AttachmentUploader.tsx**:
```typescript
'use client'

import { useState, useCallback } from 'react'
import { Upload, X, File, Image } from 'lucide-react'
import { Button } from '@/components/ui/button'

interface AttachmentUploaderProps {
  articleId: string
  onUploadComplete?: () => void
  maxSizeMB?: number
  acceptedTypes?: string[]
}

export function AttachmentUploader({
  articleId,
  onUploadComplete,
  maxSizeMB = 10,
  acceptedTypes = ['.pdf', '.doc', '.docx', '.png', '.jpg', '.jpeg'],
}: AttachmentUploaderProps) {
  const [uploading, setUploading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [dragActive, setDragActive] = useState(false)

  const handleUpload = async (files: FileList | null) => {
    if (!files || files.length === 0) return

    setError(null)
    setUploading(true)

    try {
      for (const file of Array.from(files)) {
        // Validate file size
        if (file.size > maxSizeMB * 1024 * 1024) {
          throw new Error(`Datei zu gross (max ${maxSizeMB}MB)`)
        }

        const formData = new FormData()
        formData.append('file', file)

        const res = await fetch(`/api/knowledge/${articleId}/attachments`, {
          method: 'POST',
          body: formData,
        })

        if (!res.ok) {
          const data = await res.json()
          throw new Error(data.error || 'Upload fehlgeschlagen')
        }
      }
      onUploadComplete?.()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload fehlgeschlagen')
    } finally {
      setUploading(false)
    }
  }

  // Render drag-drop zone
  // File input (hidden, triggered by button)
  // Show accepted file types
  // Progress indicator when uploading
  // Error message display

  return (
    <div className="border-2 border-dashed rounded-lg p-4">
      {/* Drag and drop zone */}
      {/* Upload button */}
      {/* Error display */}
    </div>
  )
}
```

**src/components/knowledge/AttachmentList.tsx**:
- Display list of attachments for article
- Show file icon (PDF icon, image icon, doc icon based on mime type)
- Show file name, size, upload date
- Download link (opens signed URL)
- Delete button (if user is author or admin)
- Preview for images (thumbnail)

**src/app/api/knowledge/[id]/attachments/route.ts**:
```typescript
// GET /api/knowledge/[id]/attachments
// Returns: { attachments: KBAttachmentWithUrl[] }
// Generate signed URLs for each attachment (expires in 1 hour)

// POST /api/knowledge/[id]/attachments
// Body: FormData with 'file' field
// Upload to Supabase Storage: kb_articles/{id}/attachments/{uuid}.{ext}
// Insert record to kb_attachments
// Returns: { attachment: KBAttachment }

// DELETE /api/knowledge/[id]/attachments/[attachmentId] (route in separate file or param)
// Delete from Storage and db
// Returns: { success: true }
```

Use existing upload patterns from src/components/upload/ if available.
Follow Supabase Storage API for signed URLs.
  </action>
  <verify>
Run `npm run type-check` - should pass.
Run `npm run lint` - should pass.
  </verify>
  <done>
AttachmentUploader accepts drag-drop file uploads. AttachmentList displays attachments with download links. API handles upload to Supabase Storage and returns signed URLs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create approval workflow controls</name>
  <files>
    src/components/knowledge/ApprovalWorkflow.tsx
    src/app/api/knowledge/[id]/status/route.ts
  </files>
  <action>
**src/components/knowledge/ApprovalWorkflow.tsx**:
```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Send, Check, X, Archive } from 'lucide-react'
import type { KBArticleStatus } from '@/types/knowledge-base'

interface ApprovalWorkflowProps {
  articleId: string
  currentStatus: KBArticleStatus
  isAuthor: boolean
  isAdmin: boolean
  onStatusChange?: (newStatus: KBArticleStatus) => void
}

export function ApprovalWorkflow({
  articleId,
  currentStatus,
  isAuthor,
  isAdmin,
  onStatusChange,
}: ApprovalWorkflowProps) {
  const [loading, setLoading] = useState(false)
  const [showRejectInput, setShowRejectInput] = useState(false)
  const [rejectComment, setRejectComment] = useState('')

  const changeStatus = async (newStatus: KBArticleStatus, comment?: string) => {
    setLoading(true)
    try {
      const res = await fetch(`/api/knowledge/${articleId}/status`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status: newStatus, comment }),
      })
      if (!res.ok) {
        const data = await res.json()
        throw new Error(data.error)
      }
      onStatusChange?.(newStatus)
    } finally {
      setLoading(false)
      setShowRejectInput(false)
    }
  }

  // Valid transitions based on role and current status:
  // draft + author -> "Zur Pruefung einreichen" (review)
  // draft + author -> "Archivieren" (archived)
  // review + admin -> "Genehmigen" (published)
  // review + admin -> "Ablehnen" (draft, with comment)
  // published + admin -> "Archivieren" (archived)

  // Show status badge with current status
  // Show available action buttons based on role/status
  // Reject requires comment input before confirming

  return (
    <div className="flex items-center gap-4">
      {/* Status badge */}
      <StatusBadge status={currentStatus} />

      {/* Action buttons based on transitions */}
      {currentStatus === 'draft' && isAuthor && (
        <Button onClick={() => changeStatus('review')} disabled={loading}>
          <Send className="w-4 h-4 mr-2" />
          Zur Pruefung einreichen
        </Button>
      )}

      {currentStatus === 'review' && isAdmin && (
        <>
          <Button onClick={() => changeStatus('published')} disabled={loading}>
            <Check className="w-4 h-4 mr-2" />
            Genehmigen
          </Button>
          <Button variant="secondary" onClick={() => setShowRejectInput(true)} disabled={loading}>
            <X className="w-4 h-4 mr-2" />
            Ablehnen
          </Button>
        </>
      )}

      {/* Reject comment input modal/inline */}
    </div>
  )
}

function StatusBadge({ status }: { status: KBArticleStatus }) {
  const styles = {
    draft: 'bg-gray-100 text-gray-800',
    review: 'bg-yellow-100 text-yellow-800',
    published: 'bg-green-100 text-green-800',
    archived: 'bg-red-100 text-red-800',
  }
  const labels = {
    draft: 'Entwurf',
    review: 'In Pruefung',
    published: 'Veroeffentlicht',
    archived: 'Archiviert',
  }
  return (
    <span className={`px-2 py-1 rounded text-sm ${styles[status]}`}>
      {labels[status]}
    </span>
  )
}
```

**src/app/api/knowledge/[id]/status/route.ts**:
```typescript
// PUT /api/knowledge/[id]/status
// Body: { status: KBArticleStatus, comment?: string }
// Returns: { article: KBArticle }

// Validate auth
// Get current article status
// Validate transition is allowed (trigger will also enforce, but check early for better error)
// - draft -> review (author only)
// - draft -> archived (author only)
// - review -> published (admin only)
// - review -> draft (admin only)
// - published -> archived (admin only)
// Update article status
// Trigger will log to kb_workflow_transitions automatically
// Return updated article
```

Integrate ApprovalWorkflow into:
- Edit page (below editor, above save button)
- View page (in header area for admins)

Update existing knowledge pages to show workflow controls.
  </action>
  <verify>
Run `npm run type-check` - should pass.
Run `npm run lint` - should pass.
Test workflow: create draft -> submit for review -> approve (as admin)
  </verify>
  <done>
ApprovalWorkflow shows status badge and action buttons based on current status and user role. Status API validates and applies transitions with audit trail.
  </done>
</task>

</tasks>

<verification>
- [ ] Attachments table exists with article FK and cascade delete
- [ ] AttachmentUploader handles drag-drop and file input
- [ ] AttachmentList shows files with download links
- [ ] Attachment API uploads to Supabase Storage
- [ ] ApprovalWorkflow shows correct buttons for status/role
- [ ] Status transitions follow workflow rules
- [ ] Workflow transitions logged to kb_workflow_transitions
- [ ] `npm run type-check` passes
- [ ] `npm run lint` passes
</verification>

<success_criteria>
1. User can upload PDF/image attachments to article
2. User can view and download attachments
3. Author can submit draft for review
4. Admin can approve or reject articles in review
5. Rejected articles return to draft with comment
6. Published articles can be archived by admin
</success_criteria>

<output>
After completion, create `.planning/phases/18-knowledge-base/18-04-SUMMARY.md`
</output>
