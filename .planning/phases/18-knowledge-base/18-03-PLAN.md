---
phase: 18-knowledge-base
plan: 03
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - src/components/knowledge/CategoryTree.tsx
  - src/components/knowledge/SearchBar.tsx
  - src/components/knowledge/SearchResults.tsx
  - src/lib/knowledge/search.ts
  - src/app/api/knowledge/search/route.ts
  - src/app/api/knowledge/categories/[id]/route.ts
  - src/app/dashboard/knowledge/category/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can see categories in collapsible sidebar tree"
    - "User can navigate by category and see articles in that category"
    - "User can search articles and see results with snippets"
    - "Search results highlight matching terms"
  artifacts:
    - path: "src/components/knowledge/CategoryTree.tsx"
      provides: "Collapsible sidebar navigation for categories"
      min_lines: 60
    - path: "src/components/knowledge/SearchBar.tsx"
      provides: "Search input with suggestions"
      min_lines: 40
    - path: "src/lib/knowledge/search.ts"
      provides: "Search query builder and result processing"
      exports: ["searchArticles", "getSuggestions"]
    - path: "src/app/api/knowledge/search/route.ts"
      provides: "Full-text search API endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/components/knowledge/SearchBar.tsx"
      to: "/api/knowledge/search"
      via: "fetch with debounce"
      pattern: "fetch.*api/knowledge/search"
    - from: "src/lib/knowledge/search.ts"
      to: "websearch_to_tsquery"
      via: "PostgreSQL FTS function"
      pattern: "websearch_to_tsquery|plainto_tsquery"
    - from: "src/components/knowledge/CategoryTree.tsx"
      to: "/api/knowledge/categories"
      via: "fetch on mount"
      pattern: "fetch.*api/knowledge/categories"
---

<objective>
Implement category navigation with collapsible tree sidebar and full-text search with PostgreSQL tsvector. Users can browse articles by category and search across all content with highlighting and snippets.

Purpose: Discovery and navigation - users need to find articles quickly via browsing (categories) or searching (keywords).
Output: Category tree component, search bar with suggestions, search results with snippets, and supporting API endpoints.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-knowledge-base/18-CONTEXT.md
@.planning/phases/18-knowledge-base/18-RESEARCH.md
@.planning/phases/18-knowledge-base/18-01-SUMMARY.md
@src/types/knowledge-base.ts
@src/components/ui/button.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CategoryTree component and category API</name>
  <files>
    src/components/knowledge/CategoryTree.tsx
    src/app/api/knowledge/categories/[id]/route.ts
  </files>
  <action>
**src/components/knowledge/CategoryTree.tsx**:
```typescript
'use client'

import { useState, useEffect } from 'react'
import { ChevronRight, ChevronDown, Folder, FolderOpen } from 'lucide-react'
import Link from 'next/link'
import { cn } from '@/lib/utils'
import type { KBCategoryWithCount } from '@/types/knowledge-base'

interface CategoryTreeProps {
  selectedCategoryId?: string
  showEmpty?: boolean // admin sees all, users see only populated
}

export function CategoryTree({ selectedCategoryId, showEmpty = false }: CategoryTreeProps) {
  const [categories, setCategories] = useState<KBCategoryWithCount[]>([])
  const [expanded, setExpanded] = useState<Set<string>>(new Set())
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetch(`/api/knowledge/categories?include_empty=${showEmpty}`)
      .then(res => res.json())
      .then(data => {
        setCategories(data.categories)
        // Auto-expand parent of selected category
        if (selectedCategoryId) {
          const selected = findCategory(data.categories, selectedCategoryId)
          if (selected?.parent_id) {
            setExpanded(new Set([selected.parent_id]))
          }
        }
      })
      .finally(() => setLoading(false))
  }, [showEmpty, selectedCategoryId])

  const toggleExpand = (id: string) => {
    const next = new Set(expanded)
    if (next.has(id)) next.delete(id)
    else next.add(id)
    setExpanded(next)
  }

  // Render tree recursively
  // Level 1 categories show with expand/collapse if they have children
  // Level 2 categories are children (indented)
  // Show article count badge
  // Highlight selected category
  // Use existing Link component for navigation
  // Style with Tailwind, dark mode support

  return (
    <nav className="space-y-1">
      {/* "Alle Artikel" link at top */}
      {/* Render top-level categories */}
      {/* Each category links to /dashboard/knowledge/category/[id] */}
    </nav>
  )
}
```

Key features:
- Collapsible tree (level 1 can expand to show level 2)
- Article count badge for each category
- Selected state highlighting
- "Alle Artikel" link at top
- Icons: FolderOpen for expanded, Folder for collapsed
- German UI text

**src/app/api/knowledge/categories/[id]/route.ts**:
- GET: Return single category with article list
- PUT: Update category (admin only)
- DELETE: Delete category (admin only, only if empty)

Follow existing patterns for auth validation and error handling.
  </action>
  <verify>
Run `npm run type-check` - should pass.
Run `npm run lint` - should pass.
  </verify>
  <done>
CategoryTree component renders collapsible tree with article counts. Category detail API endpoints exist.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create search functionality with PostgreSQL FTS</name>
  <files>
    src/lib/knowledge/search.ts
    src/app/api/knowledge/search/route.ts
  </files>
  <action>
**src/lib/knowledge/search.ts**:
```typescript
import { createClient } from '@/lib/supabase/server'
import type { KBSearchFilters, KBSearchResult } from '@/types/knowledge-base'

export async function searchArticles(
  query: string,
  filters: KBSearchFilters = {},
  limit: number = 20
): Promise<{ results: KBSearchResult[]; total: number }> {
  const supabase = await createClient()

  // Use websearch_to_tsquery for safe user input handling
  // Build query with filters
  // Join with users and categories for metadata
  // Use ts_headline for snippet generation with <mark> tags
  // Use ts_rank_cd for relevance ranking
  // Return results sorted by rank

  const { data, error, count } = await supabase
    .rpc('search_kb_articles', {
      search_query: query,
      category_filter: filters.categoryId || null,
      visibility_filter: filters.audience || null,
      author_filter: filters.author || null,
      date_from: filters.dateFrom || null,
      date_to: filters.dateTo || null,
      result_limit: limit,
    })

  if (error) throw error
  return { results: data || [], total: count || 0 }
}

export async function getSuggestions(
  term: string,
  limit: number = 5
): Promise<string[]> {
  const supabase = await createClient()

  // Use pg_trgm similarity for fuzzy matching
  // Query article titles and tags
  // Return top matches by similarity score

  const { data, error } = await supabase
    .rpc('get_kb_suggestions', {
      search_term: term,
      match_limit: limit,
    })

  if (error) throw error
  return data?.map((r: { suggestion: string }) => r.suggestion) || []
}
```

**src/app/api/knowledge/search/route.ts**:
```typescript
// GET /api/knowledge/search
// Query params: ?q=search+terms&category_id=uuid&visibility=internal&author=uuid&from=date&to=date&limit=20
// Returns: { results: KBSearchResult[], total: number }

// Validate auth
// Parse query params
// Call searchArticles from lib
// Return results with snippets and highlighting markers

// For contractor access (detected via role), filter visibility to 'contractors' or 'both'
```

**Database functions (add to migration or create new migration)**:
Create RPC functions in Supabase:
1. `search_kb_articles` - parameterized search with filters, returns results with snippets
2. `get_kb_suggestions` - trigram-based suggestions for autocomplete

SQL for search function:
```sql
CREATE OR REPLACE FUNCTION search_kb_articles(
  search_query TEXT,
  category_filter UUID DEFAULT NULL,
  visibility_filter TEXT DEFAULT NULL,
  author_filter UUID DEFAULT NULL,
  date_from TIMESTAMPTZ DEFAULT NULL,
  date_to TIMESTAMPTZ DEFAULT NULL,
  result_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
  id UUID,
  title TEXT,
  snippet TEXT,
  rank FLOAT,
  category_id UUID,
  category_name TEXT,
  updated_at TIMESTAMPTZ,
  author_name TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    a.id,
    a.title,
    ts_headline('english', a.content::text, websearch_to_tsquery('english', search_query),
      'MaxWords=35, MinWords=15, StartSel=<mark>, StopSel=</mark>') AS snippet,
    ts_rank_cd(a.search_vector, websearch_to_tsquery('english', search_query)) AS rank,
    a.category_id,
    c.name AS category_name,
    a.updated_at,
    u.name AS author_name
  FROM kb_articles a
  LEFT JOIN kb_categories c ON c.id = a.category_id
  LEFT JOIN users u ON u.id = a.author_id
  WHERE a.search_vector @@ websearch_to_tsquery('english', search_query)
    AND a.status = 'published'
    AND (category_filter IS NULL OR a.category_id = category_filter)
    AND (visibility_filter IS NULL OR a.visibility::TEXT = visibility_filter OR a.visibility = 'both')
    AND (author_filter IS NULL OR a.author_id = author_filter)
    AND (date_from IS NULL OR a.updated_at >= date_from)
    AND (date_to IS NULL OR a.updated_at <= date_to)
  ORDER BY rank DESC
  LIMIT result_limit;
END;
$$ LANGUAGE plpgsql;
```
  </action>
  <verify>
Run `npm run type-check` - should pass.
Test search API with curl: `curl "http://localhost:3000/api/knowledge/search?q=test"`
  </verify>
  <done>
Search library functions exist. Search API endpoint returns results with snippets. Database RPC functions created for parameterized search.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create SearchBar and SearchResults components</name>
  <files>
    src/components/knowledge/SearchBar.tsx
    src/components/knowledge/SearchResults.tsx
    src/app/dashboard/knowledge/category/[id]/page.tsx
  </files>
  <action>
**src/components/knowledge/SearchBar.tsx**:
```typescript
'use client'

import { useState, useCallback } from 'react'
import { Search, X } from 'lucide-react'
import { useRouter } from 'next/navigation'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'

interface SearchBarProps {
  initialQuery?: string
  onSearch?: (query: string) => void
  showSuggestions?: boolean
  placeholder?: string
}

export function SearchBar({
  initialQuery = '',
  onSearch,
  showSuggestions = true,
  placeholder = 'Artikel suchen...',
}: SearchBarProps) {
  const [query, setQuery] = useState(initialQuery)
  const [suggestions, setSuggestions] = useState<string[]>([])
  const [showDropdown, setShowDropdown] = useState(false)
  const router = useRouter()

  // Debounced fetch for suggestions (300ms)
  const fetchSuggestions = useCallback(
    debounce(async (term: string) => {
      if (term.length < 2) {
        setSuggestions([])
        return
      }
      const res = await fetch(`/api/knowledge/search/suggestions?q=${encodeURIComponent(term)}`)
      const data = await res.json()
      setSuggestions(data.suggestions || [])
      setShowDropdown(true)
    }, 300),
    []
  )

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    setShowDropdown(false)
    if (onSearch) {
      onSearch(query)
    } else {
      router.push(`/dashboard/knowledge?q=${encodeURIComponent(query)}`)
    }
  }

  // Render input with search icon
  // Dropdown for suggestions (positioned absolute below input)
  // Clear button when query is not empty
  // Keyboard navigation for suggestions (arrow keys, enter)

  return (
    <form onSubmit={handleSubmit} className="relative">
      {/* Search input */}
      {/* Suggestions dropdown */}
    </form>
  )
}
```

**src/components/knowledge/SearchResults.tsx**:
- Receive results array and display as cards/list
- Show title with highlighted matches
- Show snippet with <mark> tags rendered
- Show category, author, date metadata
- Link each result to article view page
- Empty state: "Keine Ergebnisse" with spelling suggestions

**src/app/dashboard/knowledge/category/[id]/page.tsx**:
- Load category info and articles in that category
- Show category name as heading
- Show breadcrumb (if subcategory, show parent > child)
- List articles in category (most recent first)
- CategoryTree sidebar, SearchBar at top

Update src/app/dashboard/knowledge/page.tsx to include:
- CategoryTree in sidebar
- SearchBar at top
- If ?q= param present, show SearchResults instead of article list

German UI: "Suchen", "Keine Ergebnisse gefunden", "Vorschlaege"
  </action>
  <verify>
Run `npm run type-check` - should pass.
Run `npm run lint` - should pass.
Navigate to /dashboard/knowledge and test search functionality.
  </verify>
  <done>
SearchBar with suggestions dropdown. SearchResults displays results with snippets. Category page shows articles in category with sidebar navigation.
  </done>
</task>

</tasks>

<verification>
- [ ] CategoryTree renders collapsible two-level hierarchy
- [ ] Category detail page shows articles in that category
- [ ] SearchBar has debounced suggestions
- [ ] Search results show snippets with <mark> highlighting
- [ ] Empty search state shows suggestions
- [ ] Search filters work (category, visibility, author, date)
- [ ] Search uses websearch_to_tsquery for safe input
- [ ] `npm run type-check` passes
- [ ] `npm run lint` passes
</verification>

<success_criteria>
1. User can browse categories in collapsible sidebar
2. User can click category and see articles in that category
3. User can search and see results with highlighted snippets
4. User can filter search by category, author, date
5. Search handles special characters safely (no SQL injection)
</success_criteria>

<output>
After completion, create `.planning/phases/18-knowledge-base/18-03-SUMMARY.md`
</output>
