---
phase: 24-push-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/061_notifications.sql
  - src/types/notifications.ts
  - src/lib/notifications/queries.ts
  - public/sw.js
  - next.config.ts
  - src/contexts/PushContext.tsx
  - src/app/api/push/subscribe/route.ts
  - src/app/api/push/unsubscribe/route.ts
  - src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Notification tables exist in database (notifications, user_notifications, push_subscriptions, notification_preferences)"
    - "Service worker registers in browser and can receive push events"
    - "User can subscribe to push notifications and subscription is stored in database"
    - "User can unsubscribe and subscription is removed from database"
    - "VAPID public key is exposed to client, private key is server-only"
    - "PushProvider wraps the app so usePush() is available to all pages"
  artifacts:
    - path: "supabase/migrations/061_notifications.sql"
      provides: "All notification tables, enums, indexes, pg_cron jobs for purge and digest"
      contains: "CREATE TABLE notifications"
    - path: "src/types/notifications.ts"
      provides: "TypeScript types for notifications, preferences, subscriptions"
      exports: ["Notification", "UserNotification", "PushSubscription", "NotificationPreferences", "NotificationType", "UrgencyLevel"]
    - path: "src/lib/notifications/queries.ts"
      provides: "Database query helpers for notifications and subscriptions"
    - path: "public/sw.js"
      provides: "Service worker with push and notificationclick handlers"
    - path: "src/contexts/PushContext.tsx"
      provides: "React context for service worker registration and push subscription management"
    - path: "src/app/api/push/subscribe/route.ts"
      provides: "Store push subscription endpoint"
      exports: ["POST"]
    - path: "src/app/api/push/unsubscribe/route.ts"
      provides: "Remove push subscription endpoint"
      exports: ["POST"]
    - path: "src/app/layout.tsx"
      provides: "Root layout wrapping children with PushProvider"
  key_links:
    - from: "src/contexts/PushContext.tsx"
      to: "/api/push/subscribe"
      via: "fetch POST with subscription data"
      pattern: "fetch.*api/push/subscribe"
    - from: "public/sw.js"
      to: "notificationclick"
      via: "clients.openWindow on notification click"
      pattern: "clients\\.openWindow"
    - from: "next.config.ts"
      to: "public/sw.js"
      via: "Cache-Control headers for service worker"
      pattern: "sw\\.js"
    - from: "src/app/layout.tsx"
      to: "src/contexts/PushContext.tsx"
      via: "PushProvider wraps children"
      pattern: "PushProvider"
---

<objective>
Create the notification database schema, TypeScript types, service worker, push subscription management, and PushProvider integration.

Purpose: Foundation layer for the entire push notification system. All other notification plans depend on these artifacts. PushProvider is included here so Wave 2 plans (24-02, 24-04) can safely use usePush().
Output: Migration with 4 tables + pg_cron jobs, types file, service worker, PushContext, subscribe/unsubscribe APIs, next.config update, PushProvider in root layout.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-push-notifications/24-CONTEXT.md
@.planning/phases/24-push-notifications/24-RESEARCH.md
@supabase/migrations/060_inspection_advanced.sql
@src/types/change-orders.ts
@src/app/api/change-orders/route.ts
@src/middleware.ts
@next.config.ts
@src/app/dashboard/layout.tsx
@src/app/layout.tsx
@src/contexts/BuildingContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration and npm install</name>
  <files>supabase/migrations/061_notifications.sql</files>
  <action>
Install required packages:

```bash
npm install web-push uuid js-cookie
npm install -D @types/web-push @types/uuid @types/js-cookie
```

Generate VAPID keys and note them for environment variables:

```bash
npx web-push generate-vapid-keys
```

Store the output. The public key goes into `.env.local` as `NEXT_PUBLIC_VAPID_PUBLIC_KEY`, private key as `VAPID_PRIVATE_KEY`, and add `VAPID_SUBJECT=mailto:admin@kewa.ch`. Add these to `.env.local` (create if not exists, or append). Add `VAPID_PRIVATE_KEY` to `.env.example` as a placeholder.

Create migration `061_notifications.sql` with:

**Enums (DO/EXCEPTION idempotent pattern like 057):**
- `notification_type`: `'work_order_status'`, `'approval_needed'`, `'deadline_reminder'`
- `urgency_level`: `'urgent'`, `'normal'`, `'info'`

**Table: notifications** (content stored once, referenced many times)
- id UUID PK DEFAULT uuid_generate_v4()
- type notification_type NOT NULL
- title TEXT NOT NULL
- body TEXT NOT NULL
- entity_type TEXT NOT NULL -- 'work_order', 'invoice', 'change_order'
- entity_id UUID NOT NULL
- actor_id UUID REFERENCES users(id) -- who triggered this notification
- urgency urgency_level NOT NULL DEFAULT 'normal'
- url TEXT NOT NULL -- navigation target on click
- created_at TIMESTAMPTZ DEFAULT NOW()

**Table: user_notifications** (per-user read tracking)
- id UUID PK DEFAULT uuid_generate_v4()
- user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
- notification_id UUID NOT NULL REFERENCES notifications(id) ON DELETE CASCADE
- read_at TIMESTAMPTZ (nullable)
- created_at TIMESTAMPTZ DEFAULT NOW()
- UNIQUE(user_id, notification_id)

**Table: push_subscriptions** (one per device/browser)
- id UUID PK DEFAULT uuid_generate_v4()
- user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
- device_id TEXT NOT NULL -- UUID stored in cookie
- subscription_data JSONB NOT NULL -- Full PushSubscription object (endpoint, keys)
- enabled BOOLEAN DEFAULT TRUE
- created_at TIMESTAMPTZ DEFAULT NOW()
- last_used_at TIMESTAMPTZ DEFAULT NOW()
- UNIQUE(user_id, device_id)

**Table: notification_preferences** (one per user)
- user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE
- work_order_status_enabled BOOLEAN DEFAULT TRUE
- approval_needed_enabled BOOLEAN DEFAULT TRUE
- deadline_reminder_enabled BOOLEAN DEFAULT TRUE
- quiet_hours_start TIME DEFAULT '22:00'
- quiet_hours_end TIME DEFAULT '08:00'
- timezone TEXT DEFAULT 'Europe/Zurich'
- digest_enabled BOOLEAN DEFAULT FALSE
- digest_time TIME DEFAULT '08:00'
- created_at TIMESTAMPTZ DEFAULT NOW()
- updated_at TIMESTAMPTZ DEFAULT NOW()

**Indexes:**
- idx_notifications_entity ON notifications(entity_type, entity_id)
- idx_notifications_created ON notifications(created_at)
- idx_user_notifications_user ON user_notifications(user_id)
- idx_user_notifications_unread ON user_notifications(user_id) WHERE read_at IS NULL
- idx_push_subscriptions_user ON push_subscriptions(user_id) WHERE enabled = TRUE
- idx_notification_preferences_digest ON notification_preferences(digest_time) WHERE digest_enabled = TRUE

**Functions:**
1. `purge_old_notifications()` - Deletes notifications older than 90 days. Cascades to user_notifications via FK.
2. `send_daily_digests()` - Finds users whose digest_time matches the current hour (in their timezone). For each matching user, counts unread notifications. Calls the internal digest API endpoint via `net_http_post` (pg_net extension) to POST to `/api/notifications/digest` with { userId, unreadCount }. If pg_net is not available, fall back to RAISE LOG with user_id and unread count (the digest can alternatively be triggered by an external cron hitting the API).

**pg_cron jobs (wrap in DO block with EXCEPTION for environments without pg_cron):**
1. `purge-old-notifications`: runs daily at 3 AM UTC, calls purge_old_notifications()
2. `send-daily-digests`: runs every hour, calls send_daily_digests()

**Trigger:** update_updated_at on notification_preferences.

Add COMMENT ON for all tables and non-obvious columns. Follow comment style from 057_change_orders.sql.
  </action>
  <verify>
Run: `npx supabase db reset` -- migration applies without errors.
Check: `npm ls web-push` confirms package installed.
Check: `npm ls js-cookie` confirms package installed.
Check: `.env.local` contains NEXT_PUBLIC_VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY, VAPID_SUBJECT.
  </verify>
  <done>All four notification tables exist with correct columns, enums, indexes, pg_cron jobs, and comments. npm packages installed. VAPID keys generated and stored in .env.local.</done>
</task>

<task type="auto">
  <name>Task 2: TypeScript types and query helpers</name>
  <files>
    src/types/notifications.ts
    src/lib/notifications/queries.ts
  </files>
  <action>
**src/types/notifications.ts** - Follow pattern from src/types/change-orders.ts:

Type unions:
- NotificationType: 'work_order_status' | 'approval_needed' | 'deadline_reminder'
- UrgencyLevel: 'urgent' | 'normal' | 'info'
- EntityType: 'work_order' | 'invoice' | 'change_order'

Interfaces:
- Notification: { id, type, title, body, entity_type, entity_id, actor_id, urgency, url, created_at }
- UserNotification: { id, user_id, notification_id, read_at, created_at, notification?: Notification }
- PushSubscriptionRecord: { id, user_id, device_id, subscription_data: PushSubscriptionJSON, enabled, created_at, last_used_at }
- PushSubscriptionJSON: { endpoint: string, keys: { p256dh: string, auth: string } }
- NotificationPreferences: { user_id, work_order_status_enabled, approval_needed_enabled, deadline_reminder_enabled, quiet_hours_start, quiet_hours_end, timezone, digest_enabled, digest_time, created_at, updated_at }

Input types:
- CreateNotificationInput: { type, title, body, entity_type, entity_id, actor_id?, urgency?, url }
- SubscribePushInput: { subscription: PushSubscriptionJSON, deviceId: string }
- UpdatePreferencesInput: Partial of relevant NotificationPreferences fields (omit user_id, created_at, updated_at)

Response types:
- NotificationsResponse: { notifications: UserNotification[], total: number, unread_count: number }
- PreferencesResponse: { preferences: NotificationPreferences }
- SubscribeResponse: { success: boolean }

Role-based notification type map (export as const):
```typescript
export const ROLE_NOTIFICATION_TYPES: Record<string, NotificationType[]> = {
  admin: ['work_order_status', 'approval_needed', 'deadline_reminder'],
  property_manager: ['work_order_status', 'approval_needed', 'deadline_reminder'],
  accounting: ['approval_needed', 'deadline_reminder'],
  tenant: [],
  external_contractor: ['work_order_status'],
}
```

**src/lib/notifications/queries.ts** - Database query functions using createClient from @/lib/supabase/server:

Notifications:
- `listUserNotifications(userId, filters?: { unread_only?: boolean, type?: NotificationType, limit?: number, offset?: number })`: SELECT from user_notifications JOIN notifications, ordered by created_at DESC. Returns { notifications, total, unread_count }.
- `getUnreadCount(userId)`: SELECT COUNT from user_notifications WHERE user_id AND read_at IS NULL.
- `markAsRead(userId, notificationId)`: UPDATE user_notifications SET read_at = NOW().
- `markAllAsRead(userId)`: UPDATE user_notifications SET read_at = NOW() WHERE user_id AND read_at IS NULL.
- `createNotification(input: CreateNotificationInput)`: INSERT into notifications table. Returns the notification.
- `createUserNotification(userId, notificationId)`: INSERT into user_notifications. Returns the user_notification.
- `createNotificationForUsers(input: CreateNotificationInput, userIds: string[])`: Creates one notification row, then creates user_notification rows for each user. Uses a transaction pattern (insert notification, then batch insert user_notifications).

Push Subscriptions:
- `saveSubscription(userId, input: SubscribePushInput)`: UPSERT into push_subscriptions (on conflict user_id + device_id, update subscription_data and last_used_at).
- `removeSubscription(userId, deviceId)`: DELETE from push_subscriptions.
- `removeSubscriptionByEndpoint(endpoint)`: DELETE from push_subscriptions WHERE subscription_data->>'endpoint' = endpoint. (For handling 410 Gone)
- `getUserSubscriptions(userId)`: SELECT from push_subscriptions WHERE user_id AND enabled = TRUE.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Check: All exported types and functions are accessible from other files.
  </verify>
  <done>Types file exports all notification/preference/subscription interfaces. Queries module provides full CRUD for notifications, user_notifications, and push_subscriptions.</done>
</task>

<task type="auto">
  <name>Task 3: Service worker, PushContext, subscribe API, next.config, PushProvider in layout</name>
  <files>
    public/sw.js
    next.config.ts
    src/contexts/PushContext.tsx
    src/app/api/push/subscribe/route.ts
    src/app/api/push/unsubscribe/route.ts
    src/app/layout.tsx
  </files>
  <action>
**public/sw.js** - Service worker with push and notification click handlers:

```javascript
// Push event: display notification
self.addEventListener('push', (event) => {
  const data = event.data.json()
  const options = {
    body: data.body,
    icon: '/icon-192x192.png',
    badge: '/badge-72x72.png',
    tag: data.tag || `notification-${Date.now()}`,
    data: { url: data.url, notificationId: data.notificationId },
    requireInteraction: data.urgency === 'urgent',
    renotify: true,
  }
  event.waitUntil(self.registration.showNotification(data.title, options))
})

// Notification click: navigate to entity URL
self.addEventListener('notificationclick', (event) => {
  event.notification.close()
  const url = event.notification.data.url || '/'
  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      for (const client of clientList) {
        if (client.url.includes(url) && 'focus' in client) return client.focus()
      }
      if (clients.openWindow) return clients.openWindow(url)
    })
  )
})

// Subscription change: update backend
self.addEventListener('pushsubscriptionchange', (event) => {
  event.waitUntil(
    fetch('/api/push/subscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        subscription: event.newSubscription,
        oldEndpoint: event.oldSubscription?.endpoint,
      }),
    })
  )
})
```

If icons (icon-192x192.png, badge-72x72.png) do not exist in public/, create simple placeholder SVGs or skip the icon references (the notification will still work without them). Check if any existing PWA icons exist first.

**next.config.ts** - Add headers function for service worker cache control:

Add `headers()` async function to nextConfig. Set `Cache-Control: no-cache, no-store, must-revalidate` and `Service-Worker-Allowed: /` for the `/sw.js` route. Keep all existing config (output, reactCompiler, turbopack, experimental).

**src/contexts/PushContext.tsx** - Client component context provider:

'use client' directive. Create PushContext with:
- State: subscription (PushSubscription | null), isSupported (boolean), isSubscribed (boolean)
- On mount: Check 'serviceWorker' in navigator && 'PushManager' in window. If supported, register SW at '/sw.js' with updateViaCache: 'none'. Get existing subscription via pushManager.getSubscription(). Set state.
- subscribeToPush(): Get SW registration via navigator.serviceWorker.ready. Call pushManager.subscribe with userVisibleOnly: true and applicationServerKey from NEXT_PUBLIC_VAPID_PUBLIC_KEY (convert with urlBase64ToUint8Array helper). POST to /api/push/subscribe with subscription JSON and deviceId. Get deviceId from cookie (js-cookie), generate UUID if not exists and set cookie.
- unsubscribeFromPush(): Call subscription.unsubscribe(). POST to /api/push/unsubscribe with deviceId. Clear state.
- Export PushProvider component wrapping children with context.
- Export usePush() hook for consuming context.

Include the urlBase64ToUint8Array utility function in this file (converts VAPID public key for browser API).

**src/app/api/push/subscribe/route.ts** - POST handler:

Auth required (x-user-id from headers). Parse body: { subscription, deviceId }. Validate both fields present. Call saveSubscription(userId, input) from queries. Return { success: true } with 200.

**src/app/api/push/unsubscribe/route.ts** - POST handler:

Auth required (x-user-id from headers). Parse body: { deviceId }. Call removeSubscription(userId, deviceId). Return { success: true } with 200.

Follow exact API pattern from existing routes (try-catch, 401 for no auth, createClient from server).

**src/app/layout.tsx** - Add PushProvider:

Import PushProvider from @/contexts/PushContext. Wrap the body content with PushProvider so service worker registration happens app-wide:
```tsx
<body className={...}>
  <PushProvider>
    {children}
  </PushProvider>
</body>
```

The PushProvider is a client component. The root layout needs to remain a server component by default. Since PushProvider has 'use client', it can be a child of a server component -- React handles the boundary. The key is that PushProvider wraps {children} so all pages have access to the push context.

IMPORTANT: Check if layout.tsx currently has 'use client' directive. If not, the PushProvider wrapper should work fine as a client component child. If there are issues, create a `Providers.tsx` client component that wraps PushProvider and use that in layout.

This must be done in Plan 24-01 (not 24-04) because Plan 24-02 (Wave 2) uses usePush() in the settings page. PushProvider must exist in the tree before any consumer runs.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Run: `npm run build` -- build succeeds.
Verify: public/sw.js exists and contains push/notificationclick handlers.
Verify: next.config.ts has headers() with sw.js cache control.
Verify: src/app/layout.tsx imports and renders PushProvider wrapping children.
  </verify>
  <done>Service worker handles push events and notification clicks. PushContext registers SW and manages subscriptions. Subscribe/unsubscribe APIs store subscriptions in database. VAPID public key exposed to client only. PushProvider wraps app in root layout so usePush() is available to all downstream pages.</done>
</task>

</tasks>

<verification>
1. `npx supabase db reset` succeeds -- migration 061 applies cleanly
2. `npx tsc --noEmit` passes -- all types resolve
3. `npm run build` succeeds -- no build errors
4. `npm ls web-push` shows installed package
5. `npm ls js-cookie` shows installed package
6. `.env.local` contains VAPID keys
7. public/sw.js exists with push and notificationclick handlers
8. next.config.ts has sw.js cache headers
9. src/app/layout.tsx renders PushProvider wrapping children
</verification>

<success_criteria>
- Migration creates notifications, user_notifications, push_subscriptions, notification_preferences with all columns, enums, indexes, pg_cron jobs
- TypeScript types match database schema exactly
- Service worker registers and handles push/notificationclick events
- PushContext manages service worker lifecycle and subscription state
- Subscribe/unsubscribe APIs persist subscription data to database
- VAPID private key is server-only (no NEXT_PUBLIC_ prefix)
- PushProvider wraps app in root layout (available for Wave 2 consumers)
</success_criteria>

<output>
After completion, create `.planning/phases/24-push-notifications/24-01-SUMMARY.md`
</output>
