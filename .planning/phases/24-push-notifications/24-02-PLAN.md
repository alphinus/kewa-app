---
phase: 24-push-notifications
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/app/api/notifications/preferences/route.ts
  - src/lib/notifications/preferences.ts
  - src/lib/notifications/send.ts
  - src/app/api/notifications/digest/route.ts
  - src/app/dashboard/settings/benachrichtigungen/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can view and update their notification preferences"
    - "Preferences UI shows only notification types available for user's role"
    - "User can set quiet hours start/end times"
    - "User can enable/disable daily digest and set digest time"
    - "Send function respects quiet hours (urgent bypasses, normal respects)"
    - "Send function respects per-type enable/disable preferences"
    - "Contractor sees only work order notification type in preferences"
    - "Daily digest sends summary push with unread count at user's configured time"
  artifacts:
    - path: "src/app/api/notifications/preferences/route.ts"
      provides: "GET and PUT for notification preferences"
      exports: ["GET", "PUT"]
    - path: "src/lib/notifications/preferences.ts"
      provides: "Preference queries and role-type filtering"
    - path: "src/lib/notifications/send.ts"
      provides: "Core send function with preference checks, quiet hours, urgency bypass, push delivery, and digest sending"
    - path: "src/app/api/notifications/digest/route.ts"
      provides: "Internal endpoint called by pg_cron to send digest push notifications"
      exports: ["POST"]
    - path: "src/app/dashboard/settings/benachrichtigungen/page.tsx"
      provides: "Notification preferences settings page"
  key_links:
    - from: "src/lib/notifications/send.ts"
      to: "src/lib/notifications/preferences.ts"
      via: "imports preference checks"
      pattern: "import.*from.*notifications/preferences"
    - from: "src/lib/notifications/send.ts"
      to: "src/lib/notifications/queries.ts"
      via: "imports query functions for subscriptions"
      pattern: "import.*from.*notifications/queries"
    - from: "src/lib/notifications/send.ts"
      to: "web-push"
      via: "sends push notification via web-push library"
      pattern: "import webpush from 'web-push'"
    - from: "src/app/api/notifications/digest/route.ts"
      to: "src/lib/notifications/send.ts"
      via: "calls sendDigestNotification to send summary push"
      pattern: "sendDigestNotification"
    - from: "src/app/dashboard/settings/benachrichtigungen/page.tsx"
      to: "/api/notifications/preferences"
      via: "fetch GET and PUT"
      pattern: "fetch.*api/notifications/preferences"
---

<objective>
Build notification preferences management, the core send notification function with quiet hours/urgency bypass/push delivery, digest sending logic, and the digest API endpoint.

Purpose: Users control which notifications they receive and when. The send function is the central dispatch used by all event triggers in Plan 24-03. The digest endpoint is called by pg_cron (from 24-01 migration) to send daily summary push notifications.
Output: Preferences API + UI page, core send function with web-push integration, digest API endpoint for PUSH-10.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-push-notifications/24-CONTEXT.md
@.planning/phases/24-push-notifications/24-RESEARCH.md
@.planning/phases/24-push-notifications/24-01-SUMMARY.md
@src/types/notifications.ts
@src/lib/notifications/queries.ts
@src/app/dashboard/settings/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Preferences API and lib</name>
  <files>
    src/lib/notifications/preferences.ts
    src/app/api/notifications/preferences/route.ts
  </files>
  <action>
**src/lib/notifications/preferences.ts** - Preference management functions:

- `getPreferences(userId)`: SELECT from notification_preferences WHERE user_id. If no row exists, return defaults (all enabled, quiet hours 22:00-08:00, Europe/Zurich, digest disabled, digest_time 08:00). Do NOT auto-insert — only create on first save.
- `upsertPreferences(userId, input: UpdatePreferencesInput)`: UPSERT into notification_preferences (ON CONFLICT user_id DO UPDATE). Set updated_at to NOW(). Return updated preferences.
- `getAvailableTypes(roleName: string)`: Return NotificationType[] from ROLE_NOTIFICATION_TYPES map (imported from types/notifications.ts). Used by UI to show/hide toggles.
- `isTypeEnabledForUser(preferences: NotificationPreferences, type: NotificationType)`: Check the boolean field matching the type. Map type to field: 'work_order_status' -> work_order_status_enabled, 'approval_needed' -> approval_needed_enabled, 'deadline_reminder' -> deadline_reminder_enabled.
- `isWithinQuietHours(preferences: NotificationPreferences)`: Compare current time in user's timezone against quiet_hours_start/end. Handle overnight wrap (e.g., 22:00 start, 08:00 end means quiet from 22:00 to 08:00 next day). Return boolean.

Use createClient from @/lib/supabase/server for database queries.

**src/app/api/notifications/preferences/route.ts** - GET and PUT handlers:

GET: Auth required (x-user-id, x-user-role-name from headers). Call getPreferences(userId). Also return availableTypes from getAvailableTypes(roleName). Response: { preferences, availableTypes }.

PUT: Auth required. Parse body as UpdatePreferencesInput. Validate: only allow setting types that are available for user's role (e.g., contractor cannot enable approval_needed). Call upsertPreferences(userId, validated input). Return { preferences }.

Follow existing API pattern: try-catch, 401 for no auth, NextRequest/NextResponse.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Verify: GET /api/notifications/preferences returns defaults for new user.
Verify: PUT /api/notifications/preferences updates preferences.
  </verify>
  <done>Preferences API returns user preferences with role-based available types. Upsert creates row on first save, updates on subsequent saves.</done>
</task>

<task type="auto">
  <name>Task 2: Send notification function, digest endpoint, and preferences UI</name>
  <files>
    src/lib/notifications/send.ts
    src/app/api/notifications/digest/route.ts
    src/app/dashboard/settings/benachrichtigungen/page.tsx
  </files>
  <action>
**src/lib/notifications/send.ts** - Core notification dispatch function:

This is the central function called by all event triggers. It:
1. Creates a notification record in the database
2. Creates user_notification records for each target user
3. Sends push notifications to subscribed devices (respecting preferences)

Main export: `sendNotification(input: SendNotificationInput)` where SendNotificationInput extends CreateNotificationInput with `targetUserIds: string[]`.

Add this type to notifications.ts:
```typescript
export interface SendNotificationInput extends CreateNotificationInput {
  targetUserIds: string[]
}
```

Implementation steps:
1. Call `createNotificationForUsers(input, targetUserIds)` from queries.ts to store notification + user_notifications.
2. For each target user, check preferences:
   a. Call `getPreferences(userId)` from preferences.ts
   b. Check `isTypeEnabledForUser(prefs, input.type)` — skip if disabled
   c. Check digest mode: if prefs.digest_enabled AND input.urgency !== 'urgent', skip push (notification is stored in DB, digest will summarize later)
   d. Check quiet hours: if `isWithinQuietHours(prefs)` AND input.urgency !== 'urgent', skip push (urgent always bypasses quiet hours)
   e. If all checks pass, send push to all user's devices
3. For push delivery:
   - Import webpush from 'web-push'
   - Call webpush.setVapidDetails with env vars (VAPID_SUBJECT, NEXT_PUBLIC_VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY)
   - Get user subscriptions via `getUserSubscriptions(userId)` from queries.ts
   - Build payload: JSON.stringify({ title, body, url, urgency, tag: `${entity_type}-${entity_id}`, notificationId })
   - Send with webpush.sendNotification(), catch 410 errors and call removeSubscriptionByEndpoint()
   - Use Promise.allSettled for multiple devices
4. Return { notificationId, deliveredTo: number } (count of users who got push)

Export a helper: `sendNotificationToRole(input: CreateNotificationInput, roleName: string)` that looks up all users with that role and calls sendNotification. Use supabase query: SELECT id FROM users JOIN user_roles ON users.id = user_roles.user_id JOIN roles ON user_roles.role_id = roles.id WHERE roles.name = roleName.

**Digest sending function** (PUSH-10 implementation):

Export: `sendDigestNotification(userId: string, unreadCount: number)` — Sends a single summary push notification to a user.
- title: "Tagliche Zusammenfassung"
- body: `Sie haben ${unreadCount} ungelesene Benachrichtigungen`
- url: '/dashboard/benachrichtigungen' (opens notification center)
- urgency: 'info'
- tag: 'daily-digest'
- Get user's push subscriptions via getUserSubscriptions(userId)
- Send push via webpush.sendNotification() to all devices
- Handle 410 Gone cleanup same as sendNotification
- If unreadCount is 0, skip sending (no digest for zero unread)

This function is called by the digest API endpoint (below), which is invoked by the pg_cron job's `send_daily_digests()` function from the 24-01 migration.

IMPORTANT: The `web-push` library uses Node.js APIs. This function runs server-side only (in API routes or server actions). Never import it in client components.

**src/app/api/notifications/digest/route.ts** - Internal digest endpoint:

POST handler. Called by pg_cron (via pg_net) or external cron to send digest notifications.

Body: { userId: string, unreadCount: number } OR no body (batch mode).

Two modes:
1. **Single user mode** (body has userId + unreadCount): Call sendDigestNotification(userId, unreadCount) directly. This is the mode pg_cron uses.
2. **Batch mode** (no body or body.batch === true): Query all users with digest_enabled = TRUE whose digest_time matches current hour in their timezone. For each, count unread notifications and call sendDigestNotification. This mode can be triggered by an external cron as a fallback if pg_net is unavailable.

Security: Require either x-user-id header (authenticated admin) OR X-Cron-Secret header matching env var CRON_SECRET. Reject with 401 if neither.

Return: { success: true, digestsSent: number }.

**src/app/dashboard/settings/benachrichtigungen/page.tsx** - Notification preferences settings page:

'use client' component. German UI. Layout:
- Page title: "Benachrichtigungen"
- Subtitle: "Verwalten Sie Ihre Benachrichtigungs-Einstellungen"

Sections:
1. **Benachrichtigungstypen** - Toggle switches for each available notification type. Show only types returned by GET availableTypes. Each toggle maps to the boolean field (e.g., work_order_status_enabled). Labels:
   - work_order_status: "Arbeitsauftrag-Statusanderungen" — description: "Benachrichtigung bei Statusanderung von Arbeitsauftragen (gesendet, akzeptiert, abgelehnt)"
   - approval_needed: "Genehmigungen erforderlich" — description: "Benachrichtigung bei ausstehenden Genehmigungen (Rechnungen, Anderungsauftrage)"
   - deadline_reminder: "Frist-Erinnerungen" — description: "Erinnerung 24 Stunden vor Ablauf einer Annahmefrist"

2. **Ruhezeiten** - Time inputs for quiet_hours_start and quiet_hours_end. Label: "Ruhezeiten" with description: "Wahrend der Ruhezeiten werden keine normalen Benachrichtigungen gesendet. Dringende Benachrichtigungen werden immer zugestellt."
   - Start time input (type="time")
   - End time input (type="time")

3. **Tagliche Zusammenfassung** - Toggle for digest_enabled. When enabled, show time picker for digest_time. Label: "Tagliche Zusammenfassung" with description: "Erhalten Sie eine tagliche Zusammenfassung statt einzelner Benachrichtigungen. Dringende Benachrichtigungen werden weiterhin sofort gesendet."
   - Toggle switch
   - Time picker (type="time", only shown when toggle is on)

4. **Push-Benachrichtigungen** - Show push subscription status. Import and use usePush() from PushContext. Show:
   - If isSupported: "Push-Benachrichtigungen werden von Ihrem Browser unterstutzt"
   - If isSubscribed: "Push-Benachrichtigungen sind aktiviert" + "Deaktivieren" button
   - If not isSubscribed: "Push-Benachrichtigungen aktivieren" button
   - If not isSupported: "Ihr Browser unterstutzt keine Push-Benachrichtigungen"

On load: GET /api/notifications/preferences. Populate form.
On save: PUT /api/notifications/preferences with updated values. Show toast or success message.

Use existing UI patterns from the codebase: Tailwind styling, Card components if available, form layout matching other settings pages. Check src/app/dashboard/settings/page.tsx for styling reference.

Add navigation link to this page from the existing settings page or add a tab/link. Use "Benachrichtigungen" as the label.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Run: `npm run build` -- build succeeds.
Verify: /dashboard/settings/benachrichtigungen page renders with preference toggles.
Verify: src/app/api/notifications/digest/route.ts exists and exports POST.
Verify: send.ts exports sendDigestNotification function.
  </verify>
  <done>Send function dispatches notifications respecting preferences, quiet hours, urgency bypass, and digest mode. Digest endpoint sends summary push via sendDigestNotification when called by pg_cron or external cron. Preferences page lets users configure all notification settings with role-based type visibility.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all types resolve
2. `npm run build` succeeds -- no build errors
3. GET /api/notifications/preferences returns defaults for new user
4. PUT /api/notifications/preferences saves and returns updated preferences
5. Send function creates notification + user_notifications in database
6. Send function skips push for disabled types
7. Send function bypasses quiet hours for urgent notifications
8. Send function skips push for digest-enabled users (non-urgent)
9. POST /api/notifications/digest sends summary push to digest-enabled user with unread count
10. Settings page shows role-appropriate notification types
</verification>

<success_criteria>
- Preferences API returns role-filtered notification types
- Send function checks: type enabled, digest mode, quiet hours, urgency bypass
- Send function delivers push via web-push with 410 cleanup
- sendDigestNotification sends summary push "Sie haben X ungelesene Benachrichtigungen"
- Digest API endpoint callable by pg_cron (single user) and external cron (batch mode)
- Preferences UI shows toggles for available types, quiet hours, digest mode
- Push subscription status shown with enable/disable buttons
</success_criteria>

<output>
After completion, create `.planning/phases/24-push-notifications/24-02-SUMMARY.md`
</output>
