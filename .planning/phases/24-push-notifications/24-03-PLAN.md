---
phase: 24-push-notifications
plan: 03
type: execute
wave: 3
depends_on: ["24-01", "24-02"]
files_modified:
  - src/lib/notifications/triggers.ts
  - src/app/api/work-orders/[id]/route.ts
  - src/app/api/work-orders/[id]/send/route.ts
  - src/app/api/invoices/[id]/approve/route.ts
  - src/app/api/change-orders/[id]/route.ts
  - src/app/api/notifications/trigger/route.ts
autonomous: true

must_haves:
  truths:
    - "User receives notification when work order status changes (sent, accepted, rejected)"
    - "User receives notification when invoice approval is needed"
    - "User receives notification when change order approval is needed"
    - "Contractor receives notification when work order is assigned to them"
    - "Notifications have correct urgency levels (normal for WO status, urgent for approvals)"
    - "Notification URL navigates to the correct entity page"
  artifacts:
    - path: "src/lib/notifications/triggers.ts"
      provides: "Event trigger functions that create and dispatch notifications"
      exports: ["notifyWorkOrderStatusChange", "notifyApprovalNeeded", "notifyDeadlineReminder"]
    - path: "src/app/api/notifications/trigger/route.ts"
      provides: "Internal API for triggering notifications (used by deadline reminder cron)"
      exports: ["POST"]
  key_links:
    - from: "src/lib/notifications/triggers.ts"
      to: "src/lib/notifications/send.ts"
      via: "calls sendNotification for dispatch"
      pattern: "import.*sendNotification.*from.*notifications/send"
    - from: "src/app/api/work-orders/[id]/route.ts"
      to: "src/lib/notifications/triggers.ts"
      via: "calls notifyWorkOrderStatusChange on status PATCH"
      pattern: "notifyWorkOrderStatusChange"
    - from: "src/app/api/invoices/[id]/approve/route.ts"
      to: "src/lib/notifications/triggers.ts"
      via: "calls notifyApprovalNeeded"
      pattern: "notifyApprovalNeeded"
---

<objective>
Implement event trigger functions and integrate them into existing API routes to fire notifications on workflow events.

Purpose: Connect the notification system to real application events. When work orders change status, approvals are needed, or deadlines approach, users receive push notifications.
Output: Trigger functions library, integration into work-order/invoice/change-order APIs, internal trigger API for cron.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-push-notifications/24-CONTEXT.md
@.planning/phases/24-push-notifications/24-RESEARCH.md
@.planning/phases/24-push-notifications/24-01-SUMMARY.md
@.planning/phases/24-push-notifications/24-02-SUMMARY.md
@src/types/notifications.ts
@src/lib/notifications/send.ts
@src/lib/notifications/queries.ts
@src/app/api/work-orders/[id]/route.ts
@src/app/api/work-orders/[id]/send/route.ts
@src/app/api/invoices/[id]/approve/route.ts
@src/app/api/change-orders/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification trigger functions</name>
  <files>
    src/lib/notifications/triggers.ts
    src/app/api/notifications/trigger/route.ts
  </files>
  <action>
**src/lib/notifications/triggers.ts** - Event trigger functions that create and dispatch notifications:

Each function builds a CreateNotificationInput and identifies target users, then calls sendNotification from send.ts. All functions are async and fire-and-forget (caller does not await, errors are logged not thrown).

1. `notifyWorkOrderStatusChange(workOrderId: string, woNumber: string, newStatus: string, actorId: string)`:
   - type: 'work_order_status'
   - urgency: 'normal'
   - entity_type: 'work_order', entity_id: workOrderId
   - url: `/dashboard/auftraege/${workOrderId}`
   - title: `Arbeitsauftrag ${woNumber}`
   - body: Map status to German text: 'sent' -> 'wurde versendet', 'accepted' -> 'wurde akzeptiert', 'rejected' -> 'wurde abgelehnt', default -> `Status: ${newStatus}`
   - Target users: All users with roles admin, property_manager (SELECT users.id FROM users JOIN user_roles... JOIN roles... WHERE roles.name IN ('admin', 'property_manager'))
   - ALSO notify contractor if status is 'sent': Look up work_order partner_id, find user with that partner link and external_contractor role, add to target list

2. `notifyApprovalNeeded(entityType: 'invoice' | 'change_order', entityId: string, entityNumber: string, actorId: string)`:
   - type: 'approval_needed'
   - urgency: 'urgent'
   - entity_type: entityType, entity_id: entityId
   - url: entityType === 'invoice' ? `/dashboard/kosten/rechnungen/${entityId}` : `/dashboard/aenderungsauftraege/${entityId}`
   - title: entityType === 'invoice' ? `Rechnung ${entityNumber}` : `Anderungsauftrag ${entityNumber}`
   - body: 'Genehmigung erforderlich'
   - Target users: All users with roles admin, property_manager, accounting

3. `notifyDeadlineReminder(workOrderId: string, woNumber: string, deadlineDate: string)`:
   - type: 'deadline_reminder'
   - urgency: 'urgent'
   - entity_type: 'work_order', entity_id: workOrderId
   - url: `/dashboard/auftraege/${workOrderId}`
   - title: `Frist-Erinnerung: ${woNumber}`
   - body: `Annahmefrist lauft am ${formatDate(deadlineDate)} ab`
   - Target users: All users with roles admin, property_manager
   - actor_id: null (system-triggered)

Helper function `getUsersByRoles(roleNames: string[])`: SELECT users.id FROM users JOIN user_roles ON... JOIN roles ON... WHERE roles.name = ANY(roleNames). Return string[] of user IDs.

Helper function `getContractorUserForWorkOrder(workOrderId: string)`: Look up work_order.partner_id, then find user linked to that partner with external_contractor role. Return userId or null.

**src/app/api/notifications/trigger/route.ts** - Internal trigger endpoint for cron/system events:

POST handler. Accept body: { type: 'deadline_reminder', workOrderId, woNumber, deadlineDate }. Validate type. Call appropriate trigger function. Return { success: true }.

This endpoint is for the pg_cron deadline reminder job or external cron. Protect it: require either x-user-id header (authenticated) OR a secret header (X-Cron-Secret matching env var CRON_SECRET). Add CRON_SECRET to .env.local with a generated value.

For now, the deadline reminder is a placeholder trigger endpoint. The actual cron logic to find work orders with deadlines 24h away would need a database query:
```sql
SELECT id, wo_number, acceptance_deadline
FROM work_orders
WHERE acceptance_deadline BETWEEN NOW() AND NOW() + INTERVAL '24 hours'
AND status IN ('sent', 'viewed')
```
Include this query as a function in triggers.ts: `getUpcomingDeadlines()`. The trigger endpoint calls it and sends reminders for each.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Verify: triggers.ts exports all three notification functions.
Verify: trigger/route.ts handles POST with deadline_reminder type.
  </verify>
  <done>Three trigger functions create and dispatch notifications for work order status changes, approval requests, and deadline reminders. Internal trigger API available for cron jobs.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate triggers into existing API routes</name>
  <files>
    src/app/api/work-orders/[id]/route.ts
    src/app/api/work-orders/[id]/send/route.ts
    src/app/api/invoices/[id]/approve/route.ts
    src/app/api/change-orders/[id]/route.ts
  </files>
  <action>
Integrate notification triggers into existing API routes. Each integration is a small addition AFTER the main operation succeeds. Use fire-and-forget pattern: call trigger function without await to avoid slowing down the API response. Wrap in try-catch to prevent notification failures from breaking the main operation.

**src/app/api/work-orders/[id]/route.ts** - PATCH handler (status updates):

After successful status update, add:
```typescript
// Fire notification (non-blocking)
import { notifyWorkOrderStatusChange } from '@/lib/notifications/triggers'

// After the PATCH succeeds and workOrder is returned:
const notifiableStatuses = ['sent', 'accepted', 'rejected']
if (body.status && notifiableStatuses.includes(body.status)) {
  notifyWorkOrderStatusChange(
    workOrder.id,
    workOrder.wo_number,
    body.status,
    userId
  ).catch(err => console.error('Notification error:', err))
}
```

Read the existing PATCH handler carefully. Find where status is updated and the response is built. Add the notification call AFTER the DB update succeeds but BEFORE the response is sent. The .catch() ensures it's fire-and-forget.

**src/app/api/work-orders/[id]/send/route.ts** - POST handler (sending work order to contractor):

After successful send, add notification:
```typescript
import { notifyWorkOrderStatusChange } from '@/lib/notifications/triggers'

// After send succeeds:
notifyWorkOrderStatusChange(
  workOrder.id,
  workOrder.wo_number,
  'sent',
  userId
).catch(err => console.error('Notification error:', err))
```

**src/app/api/invoices/[id]/approve/route.ts** - POST handler (submitting for approval):

Read the existing handler. After the approval request is created/status changes to 'under_review', add:
```typescript
import { notifyApprovalNeeded } from '@/lib/notifications/triggers'

notifyApprovalNeeded(
  'invoice',
  invoice.id,
  invoice.invoice_number || invoice.id,
  userId
).catch(err => console.error('Notification error:', err))
```

If the approve route actually processes the approval (not requests it), adjust: notify when status becomes 'under_review' or when an approval action is needed, NOT when it's already approved.

**src/app/api/change-orders/[id]/route.ts** - PATCH handler (status to 'submitted'):

After change order status changes to 'submitted' (meaning it needs approval), add:
```typescript
import { notifyApprovalNeeded } from '@/lib/notifications/triggers'

if (body.status === 'submitted') {
  notifyApprovalNeeded(
    'change_order',
    changeOrder.id,
    changeOrder.co_number,
    userId
  ).catch(err => console.error('Notification error:', err))
}
```

IMPORTANT for all integrations:
- Read each file FIRST to understand the existing structure
- Add imports at top of file
- Add notification call after successful DB operation
- Always use .catch() for fire-and-forget
- Never block the response on notification delivery
- Do not modify any existing logic, only add the notification calls
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Run: `npm run build` -- build succeeds.
Verify: Each modified API file imports from triggers.ts.
Verify: Notification calls are after DB operations and use .catch().
  </verify>
  <done>Work order status changes, work order sends, invoice approval requests, and change order submissions all trigger appropriate notifications. All triggers are fire-and-forget with error logging.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all types resolve
2. `npm run build` succeeds -- no build errors
3. Work order PATCH with status change triggers notifyWorkOrderStatusChange
4. Work order send triggers notifyWorkOrderStatusChange with 'sent'
5. Invoice approve triggers notifyApprovalNeeded with 'invoice'
6. Change order submitted triggers notifyApprovalNeeded with 'change_order'
7. All triggers are non-blocking (.catch pattern)
8. Trigger functions create notification + user_notification records in database
</verification>

<success_criteria>
- Three trigger functions cover all CONTEXT.md event categories (WO status, approvals, deadlines)
- Triggers integrated into 4 existing API routes without modifying existing behavior
- Notifications have correct urgency (normal for WO status, urgent for approvals/deadlines)
- Notification URLs navigate to correct entity pages
- Contractor receives WO notifications when work order is sent to them
- Internal trigger API available for deadline reminder cron
</success_criteria>

<output>
After completion, create `.planning/phases/24-push-notifications/24-03-SUMMARY.md`
</output>
