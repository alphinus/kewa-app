---
phase: 24-push-notifications
plan: 04
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - src/app/api/notifications/route.ts
  - src/app/api/notifications/mark-read/route.ts
  - src/app/api/notifications/mark-all-read/route.ts
  - src/components/notifications/NotificationBell.tsx
  - src/components/notifications/NotificationItem.tsx
  - src/components/notifications/NotificationDropdown.tsx
  - src/components/navigation/header.tsx
  - src/app/dashboard/benachrichtigungen/page.tsx
  - src/app/layout.tsx
autonomous: true

must_haves:
  truths:
    - "Bell icon in header shows unread count badge (exact count, 9+ cap)"
    - "Clicking bell opens dropdown with recent notifications"
    - "Notifications grouped by entity with count (e.g., 'Arbeitsauftrag #42 - 3 Aktualisierungen')"
    - "User can mark individual notification as read"
    - "User can mark all notifications as read via 'Alle gelesen' button"
    - "Clicking notification navigates to relevant entity page"
    - "Full notification page at /dashboard/benachrichtigungen with filters"
    - "Notifications update in real-time via Supabase Realtime"
    - "Empty state shows 'Keine Benachrichtigungen'"
  artifacts:
    - path: "src/components/notifications/NotificationBell.tsx"
      provides: "Bell icon with unread badge, dropdown toggle"
    - path: "src/components/notifications/NotificationDropdown.tsx"
      provides: "Dropdown panel with grouped notifications, mark all read, see all link"
    - path: "src/components/notifications/NotificationItem.tsx"
      provides: "Single notification item with read status, click navigation"
    - path: "src/app/api/notifications/route.ts"
      provides: "List notifications with pagination and filters"
      exports: ["GET"]
    - path: "src/app/api/notifications/mark-read/route.ts"
      provides: "Mark single notification as read"
      exports: ["POST"]
    - path: "src/app/api/notifications/mark-all-read/route.ts"
      provides: "Mark all notifications as read"
      exports: ["POST"]
    - path: "src/app/dashboard/benachrichtigungen/page.tsx"
      provides: "Full notification center page with filters"
    - path: "src/components/navigation/header.tsx"
      provides: "Updated header with NotificationBell"
  key_links:
    - from: "src/components/notifications/NotificationBell.tsx"
      to: "src/app/api/notifications/route.ts"
      via: "fetch for notifications list"
      pattern: "fetch.*api/notifications"
    - from: "src/components/notifications/NotificationBell.tsx"
      to: "Supabase Realtime"
      via: "subscribes to user_notifications changes"
      pattern: "supabase.*channel.*postgres_changes"
    - from: "src/components/notifications/NotificationItem.tsx"
      to: "/api/notifications/mark-read"
      via: "POST on click to mark read"
      pattern: "fetch.*mark-read"
    - from: "src/components/navigation/header.tsx"
      to: "src/components/notifications/NotificationBell.tsx"
      via: "renders NotificationBell in header"
      pattern: "NotificationBell"
---

<objective>
Build the in-app notification center: bell icon with badge, dropdown panel, full page, and real-time updates.

Purpose: Users can view, read, and navigate to notifications without relying solely on browser push. This is the primary notification surface.
Output: Notification UI components, notification APIs, full notification page, header integration.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-push-notifications/24-CONTEXT.md
@.planning/phases/24-push-notifications/24-RESEARCH.md
@.planning/phases/24-push-notifications/24-01-SUMMARY.md
@src/types/notifications.ts
@src/lib/notifications/queries.ts
@src/components/navigation/header.tsx
@src/app/dashboard/layout.tsx
@src/app/layout.tsx
@src/lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Notification APIs (list, mark-read, mark-all-read)</name>
  <files>
    src/app/api/notifications/route.ts
    src/app/api/notifications/mark-read/route.ts
    src/app/api/notifications/mark-all-read/route.ts
  </files>
  <action>
**src/app/api/notifications/route.ts** - GET handler:

Auth required (x-user-id). Query params:
- unread_only: boolean (default false)
- type: NotificationType (optional filter)
- limit: number (default 20, max 100)
- offset: number (default 0)

Call listUserNotifications from queries.ts. Return NotificationsResponse: { notifications, total, unread_count }.

The notifications should include the joined notification data (type, title, body, entity_type, entity_id, urgency, url, created_at) along with user_notification data (id, read_at). Use the Supabase select with join: `user_notifications(*, notification:notifications(*))`.

**src/app/api/notifications/mark-read/route.ts** - POST handler:

Auth required (x-user-id). Body: { notificationId: string }. Validate notificationId present. Call markAsRead(userId, notificationId) from queries.ts. Return { success: true }.

**src/app/api/notifications/mark-all-read/route.ts** - POST handler:

Auth required (x-user-id). No body needed. Call markAllAsRead(userId) from queries.ts. Return { success: true, count: number } where count is the number of notifications marked read.

All routes: Follow existing API pattern (try-catch, 401 for no auth, NextRequest/NextResponse).
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Verify: All three route files export correct HTTP methods.
  </verify>
  <done>Notification list API returns paginated notifications with unread count. Mark-read and mark-all-read APIs update read_at timestamps.</done>
</task>

<task type="auto">
  <name>Task 2: Notification UI components, header integration, full page</name>
  <files>
    src/components/notifications/NotificationBell.tsx
    src/components/notifications/NotificationItem.tsx
    src/components/notifications/NotificationDropdown.tsx
    src/components/navigation/header.tsx
    src/app/dashboard/benachrichtigungen/page.tsx
    src/app/layout.tsx
  </files>
  <action>
**src/components/notifications/NotificationItem.tsx** - Single notification display:

'use client'. Props: { notification: UserNotification (with joined Notification), onMarkRead: (id: string) => void, onNavigate: (url: string) => void }.

Renders:
- Left: Icon based on notification type (use lucide-react icons: FileText for work_order_status, AlertCircle for approval_needed, Clock for deadline_reminder)
- Center: title (bold if unread), body text, relative time (e.g., "vor 5 Min.", "vor 2 Std.", "Gestern")
- Right: Unread dot indicator (blue circle if read_at is null)
- Urgency badge: if urgency === 'urgent', show small "Dringend" badge in red

On click: Call onNavigate(notification.notification.url) to navigate. If unread, call onMarkRead first.

Relative time helper: Use Intl.RelativeTimeFormat with 'de' locale, or compute manually (< 1h -> "vor X Min.", < 24h -> "vor X Std.", < 7d -> "vor X Tagen", else date string).

**src/components/notifications/NotificationDropdown.tsx** - Dropdown panel:

'use client'. Props: { notifications: UserNotification[], unreadCount: number, onMarkRead: (id: string) => void, onMarkAllRead: () => void, onClose: () => void }.

Renders:
- Header: "Benachrichtigungen" title + "Alle gelesen" button (only if unreadCount > 0)
- List: Up to 10 most recent notifications using NotificationItem
- Group by entity: If multiple notifications share the same entity_type + entity_id, show as single group: "{title} - {count} Aktualisierungen". Click expands or navigates. Implementation: reduce notifications array to group by `entity_type:entity_id`, show latest notification per group with count badge.
- Empty state: "Keine Benachrichtigungen" centered text
- Footer: "Alle anzeigen" link to /dashboard/benachrichtigungen

Styling: Absolute positioned dropdown below bell. w-80 or w-96. Max height with scroll. White bg, shadow-lg, rounded-lg, border. z-50.

Click outside to close: Use useEffect with document click listener.

**src/components/notifications/NotificationBell.tsx** - Bell icon with badge and dropdown:

'use client'. Props: { userId: string }.

State: notifications (UserNotification[]), unreadCount (number), isOpen (boolean).

On mount:
1. Fetch initial notifications: GET /api/notifications?limit=10
2. Set notifications and unreadCount from response
3. Subscribe to Supabase Realtime for user_notifications table changes:
   - Channel: `notifications-${userId}`
   - Listen for INSERT on user_notifications where user_id = userId
   - On INSERT: Fetch the new notification details (or use payload.new), prepend to list, increment unreadCount
   - Listen for UPDATE on user_notifications where user_id = userId
   - On UPDATE: If read_at is set, decrement unreadCount, update item in list

Import createClient from @/lib/supabase/client for Realtime subscription.

On unmount: Remove Supabase channel.

Renders:
- Bell icon (lucide-react Bell). Relative positioned.
- Badge: If unreadCount > 0, show count. If > 9, show "9+". Red background, white text, absolute positioned top-right.
- On click: Toggle isOpen state.
- When isOpen: Render NotificationDropdown.

Mark read handler: POST /api/notifications/mark-read with notificationId. Update local state.
Mark all read handler: POST /api/notifications/mark-all-read. Update local state (set all read_at, reset unreadCount to 0).
Navigate handler: Use router.push(url) from next/navigation. Close dropdown.

**src/components/navigation/header.tsx** - Add NotificationBell to header:

Import NotificationBell. Add it in the header's right section, between the user display name and the logout button. The bell needs the userId prop — the header already receives `user` prop. Pass `user.id` to NotificationBell.

The bell should only render when user is defined (authenticated). Place it like:
```tsx
{/* User role, notifications, and logout */}
<div className="flex items-center gap-3 flex-shrink-0">
  {user && (
    <span className="text-sm font-medium text-gray-600 dark:text-gray-400 hidden sm:inline">
      {user.displayName}
    </span>
  )}
  {user && <NotificationBell userId={user.id} />}
  <Button ...logout... />
</div>
```

**src/app/layout.tsx** - Add PushProvider:

Import PushProvider from @/contexts/PushContext. Wrap the body content with PushProvider so service worker registration happens app-wide:
```tsx
<body className={...}>
  <PushProvider>
    {children}
  </PushProvider>
</body>
```

The PushProvider is a client component. The root layout needs to remain a server component by default. Since PushProvider has 'use client', it can be a child of a server component — React handles the boundary. The key is that PushProvider wraps {children} so all pages have access to the push context.

IMPORTANT: Check if layout.tsx currently has 'use client' directive. If not, the PushProvider wrapper should work fine as a client component child. If there are issues, create a `Providers.tsx` client component that wraps PushProvider and use that in layout.

**src/app/dashboard/benachrichtigungen/page.tsx** - Full notification center page:

'use client'. Full page with:

Header section:
- Page title: "Benachrichtigungen"
- "Alle gelesen" button (top right, only if unread > 0)

Filters:
- Type filter: Select dropdown with options "Alle", "Arbeitsauftrag-Status", "Genehmigungen", "Frist-Erinnerungen"
- Read status filter: "Alle", "Ungelesen", "Gelesen"

Notification list:
- Full-width list using NotificationItem components
- Grouped by entity (same grouping logic as dropdown)
- Pagination: "Mehr laden" button at bottom (loads next 20)
- Empty state: "Keine Benachrichtigungen" with description text

On mount: GET /api/notifications with limit=20. Apply filters as query params.
On filter change: Re-fetch with updated params.
Mark read: POST /api/notifications/mark-read, update local state.
Mark all read: POST /api/notifications/mark-all-read, update all local state.
Navigate: router.push(url) on notification click.

Use Supabase Realtime subscription (same pattern as NotificationBell) to show new notifications in real-time without page refresh.

Styling: Match existing dashboard page patterns. Card-based layout. Tailwind utility classes.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Run: `npm run build` -- build succeeds.
Verify: Header renders bell icon with NotificationBell component.
Verify: /dashboard/benachrichtigungen page renders notification list.
Verify: PushProvider wraps app in root layout.
  </verify>
  <done>Bell icon in header shows unread count, dropdown shows grouped notifications with real-time updates, full page has filters and pagination. Clicking notifications navigates to entity. Mark read/all-read updates both local state and database.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all types resolve
2. `npm run build` succeeds -- no build errors
3. Bell icon visible in header with unread badge
4. Dropdown opens on bell click with recent notifications
5. "Alle gelesen" marks all notifications as read
6. Clicking notification navigates to entity URL
7. /dashboard/benachrichtigungen shows full notification list with filters
8. Real-time updates via Supabase Realtime (new notification appears without refresh)
9. Empty state shows "Keine Benachrichtigungen"
10. PushProvider wraps app in root layout
</verification>

<success_criteria>
- Notification APIs return paginated data with unread counts
- Bell icon shows exact unread count with 9+ cap
- Dropdown shows grouped notifications by entity
- Mark read/mark all read work for individual and bulk
- Navigation from notification to entity page works
- Full page has type and read status filters
- Supabase Realtime delivers new notifications in real-time
- Header integration does not break existing header functionality
</success_criteria>

<output>
After completion, create `.planning/phases/24-push-notifications/24-04-SUMMARY.md`
</output>
