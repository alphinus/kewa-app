---
phase: 08
plan: 04
name: Quality Gates & Gantt Preview
wave: 2
depends_on: [01, 02, 03]
scope: medium
autonomous: true
files_modified:
  - src/app/api/templates/[id]/quality-gates/route.ts
  - src/app/api/renovation-projects/[id]/quality-gates/route.ts
  - src/app/api/renovation-projects/[id]/quality-gates/[gateId]/route.ts
  - src/components/templates/QualityGateEditor.tsx
  - src/components/templates/QualityGateProgress.tsx
  - src/components/templates/GanttPreview.tsx
  - src/components/templates/SimpleTimeline.tsx
  - src/lib/templates/schedule.ts
  - package.json
requirements:
  - TMPL-05
---

# 08-04: Quality Gates & Gantt Preview

## Objective

Implement the Quality Gates system with evidence requirements (checklist items and photo uploads) and a Gantt-style timeline visualization for templates and projects. Quality Gates serve as checkpoints at package and phase boundaries, requiring specific evidence before progression (TMPL-05). The Gantt preview shows task sequences, dependencies, and estimated durations.

## Tasks

<task id="1" title="Create template quality gates API route">
Create `src/app/api/templates/[id]/quality-gates/route.ts` for CRUD operations.

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getValidatedSession } from '@/lib/auth/session'
import type { CreateTemplateQualityGateInput } from '@/types/templates'

interface RouteParams {
  params: Promise<{ id: string }>
}

// GET /api/templates/[id]/quality-gates - List quality gates
export async function GET(request: NextRequest, { params }: RouteParams) {
  const session = await getValidatedSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { id } = await params
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('template_quality_gates')
    .select(`
      *,
      phase:template_phases(id, name, wbs_code),
      package:template_packages(id, name, wbs_code)
    `)
    .eq('template_id', id)

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ quality_gates: data })
}

// POST /api/templates/[id]/quality-gates - Create quality gate (admin only)
export async function POST(request: NextRequest, { params }: RouteParams) {
  const session = await getValidatedSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  if (session.role !== 'kewa') {
    return NextResponse.json({ error: 'Admin access required' }, { status: 403 })
  }

  const { id: templateId } = await params
  const body: Omit<CreateTemplateQualityGateInput, 'template_id'> = await request.json()

  // Validate required fields
  if (!body.name || !body.gate_level) {
    return NextResponse.json(
      { error: 'name and gate_level are required' },
      { status: 400 }
    )
  }

  // Validate gate has correct parent reference
  if (body.gate_level === 'phase' && !body.phase_id) {
    return NextResponse.json(
      { error: 'phase_id required for phase-level gate' },
      { status: 400 }
    )
  }
  if (body.gate_level === 'package' && !body.package_id) {
    return NextResponse.json(
      { error: 'package_id required for package-level gate' },
      { status: 400 }
    )
  }

  const supabase = await createClient()

  const { data, error } = await supabase
    .from('template_quality_gates')
    .insert({
      template_id: templateId,
      gate_level: body.gate_level,
      phase_id: body.phase_id || null,
      package_id: body.package_id || null,
      name: body.name,
      description: body.description,
      checklist_items: body.checklist_items || [],
      min_photos_required: body.min_photos_required || 0,
      photo_types: body.photo_types || ['completion'],
      is_blocking: body.is_blocking ?? false,
      auto_approve_when_complete: body.auto_approve_when_complete ?? true
    })
    .select()
    .single()

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ quality_gate: data }, { status: 201 })
}
```
</task>

<task id="2" title="Create project quality gates API routes" depends_on="1">
Create `src/app/api/renovation-projects/[id]/quality-gates/route.ts` for listing project gates.

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getValidatedSession } from '@/lib/auth/session'

interface RouteParams {
  params: Promise<{ id: string }>
}

// GET /api/renovation-projects/[id]/quality-gates - List project quality gates
export async function GET(request: NextRequest, { params }: RouteParams) {
  const session = await getValidatedSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { id } = await params
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('project_quality_gates')
    .select(`
      *,
      phase:project_phases(id, name, wbs_code, status),
      package:project_packages(id, name, wbs_code, status),
      photos:media(id, file_name, storage_path)
    `)
    .eq('project_id', id)

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  // Calculate completion status for each gate
  const gatesWithStatus = data.map(gate => {
    const requiredChecks = gate.checklist_items.filter((i: any) => i.required)
    const completedChecks = requiredChecks.filter((item: any) =>
      gate.checklist_progress?.find((p: any) => p.id === item.id && p.completed)
    )
    const photoCount = gate.photos?.length || 0

    const checklistComplete = completedChecks.length === requiredChecks.length
    const photosComplete = photoCount >= gate.min_photos_required
    const isComplete = checklistComplete && photosComplete

    return {
      ...gate,
      completion: {
        checklist_complete: checklistComplete,
        checklist_progress: `${completedChecks.length}/${requiredChecks.length}`,
        photos_complete: photosComplete,
        photos_progress: `${photoCount}/${gate.min_photos_required}`,
        is_complete: isComplete,
        can_auto_approve: isComplete && gate.auto_approve_when_complete
      }
    }
  })

  return NextResponse.json({ quality_gates: gatesWithStatus })
}
```
</task>

<task id="3" title="Create single project gate API route" depends_on="2">
Create `src/app/api/renovation-projects/[id]/quality-gates/[gateId]/route.ts`.

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getValidatedSession } from '@/lib/auth/session'

interface RouteParams {
  params: Promise<{ id: string; gateId: string }>
}

// GET - Get single gate with full details
export async function GET(request: NextRequest, { params }: RouteParams) {
  const session = await getValidatedSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { gateId } = await params
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('project_quality_gates')
    .select(`
      *,
      phase:project_phases(id, name, wbs_code, status),
      package:project_packages(id, name, wbs_code, status),
      photos:media(id, file_name, storage_path, created_at)
    `)
    .eq('id', gateId)
    .single()

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ quality_gate: data })
}

// PATCH - Update gate progress (checklist, approve)
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  const session = await getValidatedSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { gateId } = await params
  const body = await request.json()
  const supabase = await createClient()

  // Handle checklist item toggle
  if (body.toggle_checklist_item) {
    const { data: gate } = await supabase
      .from('project_quality_gates')
      .select('checklist_items, checklist_progress')
      .eq('id', gateId)
      .single()

    if (!gate) {
      return NextResponse.json({ error: 'Gate not found' }, { status: 404 })
    }

    const itemId = body.toggle_checklist_item
    let progress = gate.checklist_progress || []

    const existingIndex = progress.findIndex((p: any) => p.id === itemId)
    if (existingIndex >= 0) {
      // Toggle existing
      progress[existingIndex] = {
        ...progress[existingIndex],
        completed: !progress[existingIndex].completed,
        completed_at: !progress[existingIndex].completed ? new Date().toISOString() : null,
        completed_by: !progress[existingIndex].completed ? session.userId : null
      }
    } else {
      // Add new completed item
      progress.push({
        id: itemId,
        completed: true,
        completed_at: new Date().toISOString(),
        completed_by: session.userId
      })
    }

    const { data, error } = await supabase
      .from('project_quality_gates')
      .update({ checklist_progress: progress })
      .eq('id', gateId)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    // Check for auto-approval
    await checkAndAutoApprove(supabase, gateId)

    return NextResponse.json({ quality_gate: data })
  }

  // Handle manual approval
  if (body.approve === true) {
    const { data, error } = await supabase
      .from('project_quality_gates')
      .update({
        status: 'passed',
        approved_at: new Date().toISOString(),
        approved_by: session.userId
      })
      .eq('id', gateId)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({ quality_gate: data })
  }

  return NextResponse.json({ error: 'Invalid update' }, { status: 400 })
}

// Helper: Check if gate should auto-approve
async function checkAndAutoApprove(supabase: any, gateId: string) {
  const { data: gate } = await supabase
    .from('project_quality_gates')
    .select(`
      id, checklist_items, checklist_progress, min_photos_required,
      auto_approve_when_complete, status
    `)
    .eq('id', gateId)
    .single()

  if (!gate || gate.status !== 'pending' || !gate.auto_approve_when_complete) {
    return
  }

  // Check checklist completion
  const requiredItems = gate.checklist_items.filter((i: any) => i.required)
  const allRequired = requiredItems.every((item: any) =>
    gate.checklist_progress?.find((p: any) => p.id === item.id && p.completed)
  )

  // Check photo count
  const { count } = await supabase
    .from('media')
    .select('id', { count: 'exact', head: true })
    .eq('entity_type', 'quality_gate')
    .eq('entity_id', gateId)

  const photosComplete = (count || 0) >= gate.min_photos_required

  // Auto-approve if complete
  if (allRequired && photosComplete) {
    await supabase
      .from('project_quality_gates')
      .update({
        status: 'passed',
        approved_at: new Date().toISOString(),
        approved_by: null  // null indicates auto-approval
      })
      .eq('id', gateId)
  }
}
```
</task>

<task id="4" title="Create QualityGateEditor component">
Create `src/components/templates/QualityGateEditor.tsx` for template editing.

```typescript
'use client'

import { useState } from 'react'
import type {
  TemplateQualityGate,
  TemplateChecklistItem,
  GateLevel
} from '@/types/templates'

interface QualityGateEditorProps {
  templateId: string
  phases: Array<{ id: string; name: string; wbs_code: string }>
  packages: Array<{ id: string; name: string; wbs_code: string; phase_id: string }>
  existingGates: TemplateQualityGate[]
  onSave: (gate: Partial<TemplateQualityGate>) => Promise<void>
  onDelete: (gateId: string) => Promise<void>
}

export function QualityGateEditor({
  templateId,
  phases,
  packages,
  existingGates,
  onSave,
  onDelete
}: QualityGateEditorProps) {
  const [selectedLevel, setSelectedLevel] = useState<GateLevel>('phase')
  const [selectedParent, setSelectedParent] = useState<string>('')
  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  const [checklistItems, setChecklistItems] = useState<TemplateChecklistItem[]>([])
  const [minPhotos, setMinPhotos] = useState(0)
  const [isBlocking, setIsBlocking] = useState(false)
  const [autoApprove, setAutoApprove] = useState(true)
  const [editingGate, setEditingGate] = useState<string | null>(null)

  const addChecklistItem = () => {
    setChecklistItems([
      ...checklistItems,
      { id: crypto.randomUUID(), text: '', required: true }
    ])
  }

  const updateChecklistItem = (index: number, updates: Partial<TemplateChecklistItem>) => {
    const updated = [...checklistItems]
    updated[index] = { ...updated[index], ...updates }
    setChecklistItems(updated)
  }

  const removeChecklistItem = (index: number) => {
    setChecklistItems(checklistItems.filter((_, i) => i !== index))
  }

  const handleSave = async () => {
    const gate: Partial<TemplateQualityGate> = {
      template_id: templateId,
      gate_level: selectedLevel,
      phase_id: selectedLevel === 'phase' ? selectedParent : null,
      package_id: selectedLevel === 'package' ? selectedParent : null,
      name,
      description: description || null,
      checklist_items: checklistItems.filter(i => i.text.trim()),
      min_photos_required: minPhotos,
      is_blocking: isBlocking,
      auto_approve_when_complete: autoApprove
    }

    if (editingGate) {
      gate.id = editingGate
    }

    await onSave(gate)
    resetForm()
  }

  const resetForm = () => {
    setName('')
    setDescription('')
    setChecklistItems([])
    setMinPhotos(0)
    setIsBlocking(false)
    setAutoApprove(true)
    setEditingGate(null)
    setSelectedParent('')
  }

  const editGate = (gate: TemplateQualityGate) => {
    setEditingGate(gate.id)
    setSelectedLevel(gate.gate_level)
    setSelectedParent(gate.phase_id || gate.package_id || '')
    setName(gate.name)
    setDescription(gate.description || '')
    setChecklistItems(gate.checklist_items)
    setMinPhotos(gate.min_photos_required)
    setIsBlocking(gate.is_blocking)
    setAutoApprove(gate.auto_approve_when_complete)
  }

  const parentOptions = selectedLevel === 'phase' ? phases : packages

  return (
    <div className="space-y-6">
      <h3 className="font-semibold text-lg">Quality Gates</h3>

      {/* Existing gates list */}
      <div className="space-y-2">
        {existingGates.map(gate => (
          <div
            key={gate.id}
            className="flex items-center justify-between p-3 bg-gray-50 rounded-lg"
          >
            <div>
              <div className="font-medium">{gate.name}</div>
              <div className="text-sm text-gray-500">
                {gate.gate_level === 'phase' ? 'Phase' : 'Paket'} |
                {gate.checklist_items.length} Checkpunkte |
                {gate.min_photos_required} Fotos erforderlich
              </div>
            </div>
            <div className="flex gap-2">
              <button
                onClick={() => editGate(gate)}
                className="px-3 py-1 text-sm bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
              >
                Bearbeiten
              </button>
              <button
                onClick={() => onDelete(gate.id)}
                className="px-3 py-1 text-sm bg-red-100 text-red-700 rounded hover:bg-red-200"
              >
                Loeschen
              </button>
            </div>
          </div>
        ))}
      </div>

      {/* Add/Edit form */}
      <div className="border rounded-lg p-4 space-y-4">
        <h4 className="font-medium">
          {editingGate ? 'Gate bearbeiten' : 'Neues Quality Gate'}
        </h4>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Gate-Ebene
            </label>
            <select
              value={selectedLevel}
              onChange={(e) => {
                setSelectedLevel(e.target.value as GateLevel)
                setSelectedParent('')
              }}
              className="w-full px-3 py-2 border rounded-lg"
            >
              <option value="phase">Phase</option>
              <option value="package">Paket</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              {selectedLevel === 'phase' ? 'Phase' : 'Paket'}
            </label>
            <select
              value={selectedParent}
              onChange={(e) => setSelectedParent(e.target.value)}
              className="w-full px-3 py-2 border rounded-lg"
            >
              <option value="">Waehlen...</option>
              {parentOptions.map(opt => (
                <option key={opt.id} value={opt.id}>
                  {opt.wbs_code} - {opt.name}
                </option>
              ))}
            </select>
          </div>
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Gate-Name
          </label>
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder="z.B. Demontage abgeschlossen"
            className="w-full px-3 py-2 border rounded-lg"
          />
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Beschreibung (optional)
          </label>
          <textarea
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            className="w-full px-3 py-2 border rounded-lg"
            rows={2}
          />
        </div>

        {/* Checklist items */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Checkliste
          </label>
          <div className="space-y-2">
            {checklistItems.map((item, index) => (
              <div key={item.id} className="flex gap-2 items-center">
                <input
                  type="text"
                  value={item.text}
                  onChange={(e) => updateChecklistItem(index, { text: e.target.value })}
                  placeholder="Checkpunkt beschreiben"
                  className="flex-1 px-3 py-2 border rounded-lg"
                />
                <label className="flex items-center gap-1 text-sm">
                  <input
                    type="checkbox"
                    checked={item.required}
                    onChange={(e) => updateChecklistItem(index, { required: e.target.checked })}
                  />
                  Pflicht
                </label>
                <button
                  onClick={() => removeChecklistItem(index)}
                  className="p-2 text-red-600 hover:bg-red-50 rounded"
                >
                  X
                </button>
              </div>
            ))}
            <button
              onClick={addChecklistItem}
              className="text-sm text-blue-600 hover:text-blue-700"
            >
              + Checkpunkt hinzufuegen
            </button>
          </div>
        </div>

        {/* Photo requirements */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Mindestanzahl Fotos
          </label>
          <input
            type="number"
            value={minPhotos}
            onChange={(e) => setMinPhotos(parseInt(e.target.value) || 0)}
            min={0}
            className="w-24 px-3 py-2 border rounded-lg"
          />
        </div>

        {/* Options */}
        <div className="flex gap-6">
          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={isBlocking}
              onChange={(e) => setIsBlocking(e.target.checked)}
            />
            <span className="text-sm">Blockiert Fortschritt</span>
          </label>
          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={autoApprove}
              onChange={(e) => setAutoApprove(e.target.checked)}
            />
            <span className="text-sm">Auto-Freigabe wenn vollstaendig</span>
          </label>
        </div>

        {/* Actions */}
        <div className="flex gap-2 pt-2">
          <button
            onClick={handleSave}
            disabled={!name || !selectedParent}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50"
          >
            {editingGate ? 'Aktualisieren' : 'Hinzufuegen'}
          </button>
          {editingGate && (
            <button
              onClick={resetForm}
              className="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
            >
              Abbrechen
            </button>
          )}
        </div>
      </div>
    </div>
  )
}
```
</task>

<task id="5" title="Create QualityGateProgress component" depends_on="4">
Create `src/components/templates/QualityGateProgress.tsx` for runtime gate tracking.

Features:
- Show gate status (pending/passed/failed)
- Interactive checklist with toggle
- Photo upload integration
- Progress indicators (x/y completed)
- Manual approve button for admin
- Auto-approve indicator
</task>

<task id="6" title="Install SVAR React Gantt package">
Add the Gantt library for timeline visualization.

Run:
```bash
npm install @svar/react-gantt date-fns
```

Add to package.json:
```json
{
  "dependencies": {
    "@svar/react-gantt": "^2.4.0",
    "date-fns": "^3.6.0"
  }
}
```

Note: If SVAR Gantt has issues, fallback to SimpleTimeline (task 8).
</task>

<task id="7" title="Create GanttPreview component" depends_on="6">
Create `src/components/templates/GanttPreview.tsx`.

```typescript
'use client'

import { useMemo } from 'react'
import { Gantt, type Task as GanttTask, type Link } from '@svar/react-gantt'
import '@svar/react-gantt/dist/gantt.css'
import type { TemplateWithHierarchy } from '@/types/templates'
import { addDays, format } from 'date-fns'

interface GanttPreviewProps {
  template: TemplateWithHierarchy
  startDate?: Date
  className?: string
}

// Map dependency types to SVAR link types
const linkTypeMap = {
  FS: 0,  // finish_to_start
  SS: 1,  // start_to_start
  FF: 2,  // finish_to_finish
  SF: 3   // start_to_finish
}

export function GanttPreview({
  template,
  startDate = new Date(),
  className = ''
}: GanttPreviewProps) {
  const { tasks, links } = useMemo(() => {
    const ganttTasks: GanttTask[] = []
    const ganttLinks: Link[] = []
    let currentDate = startDate

    // Process phases, packages, tasks
    template.phases.forEach((phase) => {
      const phaseStart = new Date(currentDate)
      let phaseEnd = phaseStart

      // Add phase as summary task
      ganttTasks.push({
        id: phase.id,
        text: `${phase.wbs_code} ${phase.name}`,
        start: phaseStart,
        duration: phase.estimated_duration_days || 1,
        progress: 0,
        type: 'summary',
        parent: '0'
      })

      phase.packages.forEach((pkg) => {
        const pkgStart = new Date(currentDate)

        // Add package as summary task
        ganttTasks.push({
          id: pkg.id,
          text: `${pkg.wbs_code} ${pkg.name}`,
          start: pkgStart,
          duration: pkg.estimated_duration_days || 1,
          progress: 0,
          type: 'summary',
          parent: phase.id
        })

        let pkgEndDate = pkgStart

        pkg.tasks.forEach((task) => {
          const taskStart = new Date(currentDate)
          const taskEnd = addDays(taskStart, task.estimated_duration_days)

          ganttTasks.push({
            id: task.id,
            text: `${task.wbs_code} ${task.name}`,
            start: taskStart,
            duration: task.estimated_duration_days,
            progress: 0,
            type: 'task',
            parent: pkg.id
          })

          // Track latest end date
          if (taskEnd > pkgEndDate) {
            pkgEndDate = taskEnd
          }
          if (taskEnd > phaseEnd) {
            phaseEnd = taskEnd
          }

          // Move forward for next task (simplified - ignores dependencies)
          currentDate = taskEnd
        })
      })

      // Update phase to use calculated dates
      const phaseIndex = ganttTasks.findIndex(t => t.id === phase.id)
      if (phaseIndex >= 0) {
        ganttTasks[phaseIndex].duration =
          Math.ceil((phaseEnd.getTime() - phaseStart.getTime()) / (1000 * 60 * 60 * 24))
      }
    })

    // Convert dependencies to links
    template.dependencies.forEach((dep) => {
      ganttLinks.push({
        id: dep.id,
        source: dep.predecessor_task_id,
        target: dep.successor_task_id,
        type: linkTypeMap[dep.dependency_type] || 0
      })
    })

    return { tasks: ganttTasks, links: ganttLinks }
  }, [template, startDate])

  if (tasks.length === 0) {
    return (
      <div className="p-8 text-center text-gray-500 border rounded-lg">
        Keine Tasks im Template vorhanden
      </div>
    )
  }

  return (
    <div className={`border rounded-lg overflow-hidden ${className}`}>
      <div className="p-3 bg-gray-50 border-b flex justify-between items-center">
        <h3 className="font-medium">Timeline-Vorschau</h3>
        <div className="text-sm text-gray-500">
          Start: {format(startDate, 'dd.MM.yyyy')} |
          Dauer: {template.total_duration_days || 0} Tage
        </div>
      </div>
      <div style={{ height: '400px' }}>
        <Gantt
          tasks={tasks}
          links={links}
          scales={[
            { unit: 'month', step: 1, format: 'MMMM yyyy' },
            { unit: 'week', step: 1, format: 'w' }
          ]}
          readonly={true}
          cellWidth={50}
          cellHeight={36}
        />
      </div>
    </div>
  )
}
```
</task>

<task id="8" title="Create SimpleTimeline fallback component" depends_on="7">
Create `src/components/templates/SimpleTimeline.tsx` as CSS-only fallback.

```typescript
'use client'

import { useMemo } from 'react'
import type { TemplateWithHierarchy } from '@/types/templates'

interface SimpleTimelineProps {
  template: TemplateWithHierarchy
  className?: string
}

const phaseColors = [
  'bg-blue-500',
  'bg-green-500',
  'bg-purple-500',
  'bg-orange-500',
  'bg-pink-500'
]

export function SimpleTimeline({ template, className = '' }: SimpleTimelineProps) {
  const { phases, totalDays } = useMemo(() => {
    let offset = 0
    const phaseData = template.phases.map((phase, index) => {
      const duration = phase.estimated_duration_days || 1
      const data = {
        ...phase,
        offset,
        duration,
        color: phaseColors[index % phaseColors.length]
      }
      offset += duration
      return data
    })

    return {
      phases: phaseData,
      totalDays: offset || 1
    }
  }, [template])

  if (phases.length === 0) {
    return (
      <div className="p-8 text-center text-gray-500 border rounded-lg">
        Keine Phasen im Template vorhanden
      </div>
    )
  }

  return (
    <div className={`border rounded-lg p-4 ${className}`}>
      <div className="flex justify-between items-center mb-4">
        <h3 className="font-medium">Timeline-Vorschau</h3>
        <div className="text-sm text-gray-500">
          Gesamt: {totalDays} Tage
        </div>
      </div>

      {/* Timeline bars */}
      <div className="relative h-48 bg-gray-100 rounded overflow-hidden">
        {/* Day markers */}
        <div className="absolute inset-0 flex">
          {Array.from({ length: Math.min(totalDays, 30) }).map((_, i) => (
            <div
              key={i}
              className="flex-1 border-r border-gray-200"
              style={{ minWidth: '20px' }}
            />
          ))}
        </div>

        {/* Phase bars */}
        <div className="absolute inset-0 p-2 space-y-2">
          {phases.map((phase, index) => {
            const left = (phase.offset / totalDays) * 100
            const width = (phase.duration / totalDays) * 100

            return (
              <div
                key={phase.id}
                className={`absolute h-8 ${phase.color} rounded text-white text-xs flex items-center px-2 shadow-sm overflow-hidden whitespace-nowrap`}
                style={{
                  left: `${left}%`,
                  width: `${Math.max(width, 5)}%`,
                  top: `${index * 40 + 8}px`
                }}
                title={`${phase.name}: ${phase.duration} Tage`}
              >
                <span className="truncate">
                  {phase.wbs_code} {phase.name}
                </span>
                <span className="ml-auto pl-2 opacity-80">
                  {phase.duration}d
                </span>
              </div>
            )
          })}
        </div>
      </div>

      {/* Legend */}
      <div className="mt-4 flex flex-wrap gap-3">
        {phases.map((phase) => (
          <div key={phase.id} className="flex items-center gap-1 text-sm">
            <div className={`w-3 h-3 rounded ${phase.color}`} />
            <span className="text-gray-600">{phase.name}</span>
          </div>
        ))}
      </div>
    </div>
  )
}
```
</task>

<task id="9" title="Create schedule calculation utilities" depends_on="8">
Create `src/lib/templates/schedule.ts` for timeline calculations.

```typescript
import { addDays, differenceInDays } from 'date-fns'
import type { TemplateWithHierarchy, TemplateDependency } from '@/types/templates'

interface ScheduledTask {
  id: string
  name: string
  wbs_code: string
  start: Date
  end: Date
  duration: number
  packageId: string
  phaseId: string
}

interface ScheduleResult {
  tasks: ScheduledTask[]
  totalDays: number
  criticalPath: string[]
  endDate: Date
}

/**
 * Calculate schedule from template with dependencies
 * Uses Forward Pass algorithm for early start/finish
 */
export function calculateSchedule(
  template: TemplateWithHierarchy,
  startDate: Date = new Date()
): ScheduleResult {
  const taskMap = new Map<string, ScheduledTask>()
  const dependencyMap = new Map<string, TemplateDependency[]>()

  // Build dependency lookup
  for (const dep of template.dependencies) {
    if (!dependencyMap.has(dep.successor_task_id)) {
      dependencyMap.set(dep.successor_task_id, [])
    }
    dependencyMap.get(dep.successor_task_id)!.push(dep)
  }

  // Collect all tasks with package/phase info
  for (const phase of template.phases) {
    for (const pkg of phase.packages) {
      for (const task of pkg.tasks) {
        taskMap.set(task.id, {
          id: task.id,
          name: task.name,
          wbs_code: task.wbs_code,
          start: startDate,
          end: addDays(startDate, task.estimated_duration_days),
          duration: task.estimated_duration_days,
          packageId: pkg.id,
          phaseId: phase.id
        })
      }
    }
  }

  // Topological sort for processing order
  const sorted = topologicalSort(Array.from(taskMap.keys()), dependencyMap)

  // Forward pass - calculate early start/finish
  for (const taskId of sorted) {
    const task = taskMap.get(taskId)!
    const deps = dependencyMap.get(taskId) || []

    let earliestStart = startDate

    for (const dep of deps) {
      const predecessor = taskMap.get(dep.predecessor_task_id)
      if (!predecessor) continue

      let depDate: Date
      switch (dep.dependency_type) {
        case 'FS': // Finish-to-Start
          depDate = addDays(predecessor.end, dep.lag_days)
          break
        case 'SS': // Start-to-Start
          depDate = addDays(predecessor.start, dep.lag_days)
          break
        case 'FF': // Finish-to-Finish
          depDate = addDays(predecessor.end, dep.lag_days - task.duration)
          break
        case 'SF': // Start-to-Finish
          depDate = addDays(predecessor.start, dep.lag_days - task.duration)
          break
        default:
          depDate = addDays(predecessor.end, dep.lag_days)
      }

      if (depDate > earliestStart) {
        earliestStart = depDate
      }
    }

    task.start = earliestStart
    task.end = addDays(earliestStart, task.duration)
  }

  // Find end date
  let endDate = startDate
  for (const task of taskMap.values()) {
    if (task.end > endDate) {
      endDate = task.end
    }
  }

  const totalDays = differenceInDays(endDate, startDate)

  // Simple critical path (tasks with no slack)
  // Full CPM would require backward pass
  const criticalPath = findCriticalPath(taskMap, dependencyMap, endDate)

  return {
    tasks: Array.from(taskMap.values()),
    totalDays,
    criticalPath,
    endDate
  }
}

/**
 * Topological sort of tasks based on dependencies
 */
function topologicalSort(
  taskIds: string[],
  dependencyMap: Map<string, TemplateDependency[]>
): string[] {
  const result: string[] = []
  const visited = new Set<string>()
  const temp = new Set<string>()

  function visit(id: string) {
    if (temp.has(id)) {
      throw new Error('Circular dependency detected')
    }
    if (visited.has(id)) return

    temp.add(id)

    // Visit all predecessors first
    const deps = dependencyMap.get(id) || []
    for (const dep of deps) {
      if (taskIds.includes(dep.predecessor_task_id)) {
        visit(dep.predecessor_task_id)
      }
    }

    temp.delete(id)
    visited.add(id)
    result.push(id)
  }

  for (const id of taskIds) {
    if (!visited.has(id)) {
      visit(id)
    }
  }

  return result
}

/**
 * Find critical path tasks (simplified - tasks that end at project end)
 */
function findCriticalPath(
  taskMap: Map<string, ScheduledTask>,
  dependencyMap: Map<string, TemplateDependency[]>,
  projectEnd: Date
): string[] {
  const criticalTasks: string[] = []

  for (const [id, task] of taskMap) {
    // Task is critical if it ends at or near project end
    const daysFromEnd = differenceInDays(projectEnd, task.end)
    if (daysFromEnd <= 1) {
      criticalTasks.push(id)
    }
  }

  return criticalTasks
}

/**
 * Format duration as human readable
 */
export function formatDuration(days: number): string {
  if (days === 1) return '1 Tag'
  if (days < 7) return `${days} Tage`
  const weeks = Math.floor(days / 7)
  const remainingDays = days % 7
  if (remainingDays === 0) {
    return weeks === 1 ? '1 Woche' : `${weeks} Wochen`
  }
  return `${weeks} Wo. ${remainingDays} Tage`
}
```
</task>

<task id="10" title="Integrate Gantt into template detail page" depends_on="7,8">
Update `src/app/templates/[id]/page.tsx` to include GanttPreview.

Add the timeline visualization below the WBS tree:
- Show GanttPreview if template has tasks
- Fall back to SimpleTimeline if Gantt fails to load
- Date picker for start date simulation
</task>

<task id="11" title="Add quality gate runtime types" depends_on="5">
Update `src/types/templates.ts` with runtime types for gate progress tracking.

Add:
```typescript
/**
 * Quality gate completion status for display
 */
export interface QualityGateCompletion {
  checklist_complete: boolean
  checklist_progress: string  // e.g., "3/5"
  photos_complete: boolean
  photos_progress: string  // e.g., "2/3"
  is_complete: boolean
  can_auto_approve: boolean
}

/**
 * Project quality gate with completion tracking
 */
export interface ProjectQualityGateWithCompletion extends ProjectQualityGate {
  completion: QualityGateCompletion
  photos: Array<{
    id: string
    file_name: string
    storage_path: string
  }>
}
```
</task>

## Verification

- [ ] Template quality gate CRUD API works correctly
- [ ] Project quality gate progress tracking updates properly
- [ ] Checklist items can be toggled on/off
- [ ] Auto-approve triggers when all requirements met
- [ ] Photo count tracked for gate requirements
- [ ] GanttPreview renders template timeline with dependencies
- [ ] SimpleTimeline works as fallback if Gantt fails
- [ ] Schedule calculation respects dependency types
- [ ] Quality gate editor allows full configuration
- [ ] Gate progress shows in project detail view

## Must Haves

These are goal-backward success criteria derived from TMPL-05:

- [ ] Quality Gates can be defined at package and phase levels (TMPL-05)
- [ ] Gates have configurable checklist items with required flag (TMPL-05)
- [ ] Gates have configurable minimum photo requirements (TMPL-05)
- [ ] Gate progress is tracked per checklist item
- [ ] Auto-approve works when all evidence requirements met
- [ ] Timeline visualization shows task sequence and dependencies
- [ ] Duration calculations are visible in preview
