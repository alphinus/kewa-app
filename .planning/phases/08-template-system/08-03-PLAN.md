---
phase: 08
plan: 03
name: Template Application & Dependencies
wave: 2
depends_on: [01, 02]
scope: large
autonomous: true
files_modified:
  - supabase/migrations/035_project_from_template.sql
  - supabase/migrations/036_task_dependencies_extended.sql
  - src/app/api/templates/[id]/apply/route.ts
  - src/app/api/templates/[id]/dependencies/route.ts
  - src/app/api/renovation-projects/[id]/apply-template/route.ts
  - src/app/renovation-projects/[id]/apply-template/page.tsx
  - src/components/templates/TemplateApplyWizard.tsx
  - src/components/templates/DependencyEditor.tsx
  - src/lib/templates/apply.ts
  - src/lib/templates/dependencies.ts
  - src/types/templates.ts
requirements:
  - TMPL-04
  - TMPL-06
---

# 08-03: Template Application & Dependencies

## Objective

Implement the template application system that deep-clones templates to projects and the dependency management system for task relationships. This includes a PostgreSQL function for atomic template application with ID remapping, a wizard UI for applying templates with optional task selection, dependency CRUD with circular detection, and the mapping rules that trigger room/unit condition updates on project completion (TMPL-06).

## Tasks

<task id="1" title="Extend task_dependencies table for dependency types">
Create migration to add dependency_type and lag_days to the existing task_dependencies table.

Create `supabase/migrations/036_task_dependencies_extended.sql`:

```sql
-- KEWA Renovations Operations System
-- Migration: 036_task_dependencies_extended.sql
-- TMPL-04: Task dependencies with types and lag time

-- =============================================
-- EXTEND TASK DEPENDENCIES
-- =============================================

-- Add dependency_type column (uses enum from 032_templates.sql)
ALTER TABLE task_dependencies
ADD COLUMN IF NOT EXISTS dependency_type dependency_type NOT NULL DEFAULT 'FS';

-- Add lag_days column
ALTER TABLE task_dependencies
ADD COLUMN IF NOT EXISTS lag_days INTEGER DEFAULT 0;

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON COLUMN task_dependencies.dependency_type IS 'FS=Finish-to-Start, SS=Start-to-Start, FF=Finish-to-Finish, SF=Start-to-Finish';
COMMENT ON COLUMN task_dependencies.lag_days IS 'Delay in days after dependency condition met (can be negative for lead time)';
```
</task>

<task id="2" title="Create project hierarchy tables for WBS">
Create tables for project phases and packages (runtime versions of template hierarchy).

Create `supabase/migrations/035_project_from_template.sql`:

```sql
-- KEWA Renovations Operations System
-- Migration: 035_project_from_template.sql
-- Runtime project hierarchy and template application

-- =============================================
-- PROJECT PHASES (runtime WBS Level 1)
-- =============================================

CREATE TABLE project_phases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES renovation_projects(id) ON DELETE CASCADE,

  -- Identification
  name TEXT NOT NULL,
  description TEXT,
  sort_order INTEGER NOT NULL DEFAULT 0,
  wbs_code TEXT NOT NULL,

  -- Scheduling
  estimated_duration_days INTEGER,
  actual_duration_days INTEGER,
  planned_start_date DATE,
  planned_end_date DATE,
  actual_start_date DATE,
  actual_end_date DATE,

  -- Status
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'blocked')),

  -- Template reference
  source_template_phase_id UUID,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(project_id, wbs_code)
);

-- Indexes
CREATE INDEX idx_project_phases_project ON project_phases(project_id);
CREATE INDEX idx_project_phases_status ON project_phases(status);

-- Timestamp trigger
CREATE TRIGGER project_phases_updated_at
  BEFORE UPDATE ON project_phases
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- =============================================
-- PROJECT PACKAGES (runtime WBS Level 2)
-- =============================================

CREATE TABLE project_packages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  phase_id UUID NOT NULL REFERENCES project_phases(id) ON DELETE CASCADE,

  -- Identification
  name TEXT NOT NULL,
  description TEXT,
  sort_order INTEGER NOT NULL DEFAULT 0,
  wbs_code TEXT NOT NULL,

  -- Trade association
  trade_category trade_category,

  -- Scheduling & Cost
  estimated_duration_days INTEGER,
  estimated_cost DECIMAL(10,2),
  actual_cost DECIMAL(10,2),

  -- Status
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'in_progress', 'completed', 'blocked')),

  -- Template reference
  source_template_package_id UUID,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  UNIQUE(phase_id, wbs_code)
);

-- Indexes
CREATE INDEX idx_project_packages_phase ON project_packages(phase_id);
CREATE INDEX idx_project_packages_status ON project_packages(status);

-- Timestamp trigger
CREATE TRIGGER project_packages_updated_at
  BEFORE UPDATE ON project_packages
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- =============================================
-- PROJECT TASKS EXTENSION (link to package)
-- =============================================

-- Add package link and WBS fields to tasks
ALTER TABLE tasks
ADD COLUMN IF NOT EXISTS package_id UUID REFERENCES project_packages(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS wbs_code TEXT,
ADD COLUMN IF NOT EXISTS is_from_template BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS source_template_task_id UUID;

-- Index for package lookup
CREATE INDEX IF NOT EXISTS idx_tasks_package_id ON tasks(package_id);
CREATE INDEX IF NOT EXISTS idx_tasks_wbs_code ON tasks(wbs_code) WHERE wbs_code IS NOT NULL;

-- =============================================
-- PROJECT QUALITY GATES (runtime gates)
-- =============================================

CREATE TABLE project_quality_gates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID NOT NULL REFERENCES renovation_projects(id) ON DELETE CASCADE,

  -- Gate location
  gate_level gate_level NOT NULL,
  phase_id UUID REFERENCES project_phases(id) ON DELETE CASCADE,
  package_id UUID REFERENCES project_packages(id) ON DELETE CASCADE,

  -- Gate definition
  name TEXT NOT NULL,
  description TEXT,

  -- Evidence requirements
  checklist_items JSONB NOT NULL DEFAULT '[]'::JSONB,
  checklist_progress JSONB DEFAULT '[]'::JSONB,  -- Runtime progress
  min_photos_required INTEGER DEFAULT 0,
  photo_types JSONB DEFAULT '["completion"]'::JSONB,

  -- Behavior
  is_blocking BOOLEAN DEFAULT false,
  auto_approve_when_complete BOOLEAN DEFAULT true,

  -- Status
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'passed', 'failed')),
  approved_at TIMESTAMPTZ,
  approved_by UUID REFERENCES users(id),

  -- Template reference
  source_template_gate_id UUID,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Ensure gate is linked to exactly one entity
  CHECK(
    (gate_level = 'package' AND package_id IS NOT NULL AND phase_id IS NULL) OR
    (gate_level = 'phase' AND phase_id IS NOT NULL AND package_id IS NULL)
  )
);

-- Indexes
CREATE INDEX idx_project_quality_gates_project ON project_quality_gates(project_id);
CREATE INDEX idx_project_quality_gates_status ON project_quality_gates(status);

-- Timestamp trigger
CREATE TRIGGER project_quality_gates_updated_at
  BEFORE UPDATE ON project_quality_gates
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE project_phases IS 'Runtime WBS Level 1: Major phases within a project';
COMMENT ON TABLE project_packages IS 'Runtime WBS Level 2: Work packages within phases';
COMMENT ON TABLE project_quality_gates IS 'Runtime quality gates for project milestones';
COMMENT ON COLUMN tasks.package_id IS 'Link to project package for WBS hierarchy';
COMMENT ON COLUMN tasks.wbs_code IS 'WBS code within project (e.g., 1.1.1)';
COMMENT ON COLUMN tasks.is_from_template IS 'True if task was created from template application';
```
</task>

<task id="3" title="Create template application PostgreSQL function" depends_on="1,2">
Create the atomic template application function in a separate migration.

Add to `supabase/migrations/035_project_from_template.sql`:

```sql
-- =============================================
-- TEMPLATE APPLICATION FUNCTION
-- =============================================

CREATE OR REPLACE FUNCTION apply_template_to_project(
  p_template_id UUID,
  p_project_id UUID,
  p_start_date DATE DEFAULT NULL,
  p_excluded_tasks UUID[] DEFAULT ARRAY[]::UUID[]
)
RETURNS TABLE(
  phases_created INTEGER,
  packages_created INTEGER,
  tasks_created INTEGER,
  dependencies_created INTEGER,
  gates_created INTEGER
) AS $$
DECLARE
  v_id_mapping JSONB := '{}'::JSONB;
  v_phase RECORD;
  v_package RECORD;
  v_task RECORD;
  v_dep RECORD;
  v_gate RECORD;
  v_new_phase_id UUID;
  v_new_package_id UUID;
  v_new_task_id UUID;
  v_phases_created INTEGER := 0;
  v_packages_created INTEGER := 0;
  v_tasks_created INTEGER := 0;
  v_deps_created INTEGER := 0;
  v_gates_created INTEGER := 0;
  v_start DATE;
BEGIN
  -- Get start date (default to planned_start_date or today)
  SELECT COALESCE(p_start_date, planned_start_date, CURRENT_DATE)
  INTO v_start
  FROM renovation_projects
  WHERE id = p_project_id;

  -- =============================================
  -- CREATE PHASES
  -- =============================================
  FOR v_phase IN
    SELECT * FROM template_phases
    WHERE template_id = p_template_id
    ORDER BY sort_order
  LOOP
    v_new_phase_id := gen_random_uuid();

    INSERT INTO project_phases (
      id, project_id, name, description, wbs_code, sort_order,
      estimated_duration_days, status, source_template_phase_id
    ) VALUES (
      v_new_phase_id, p_project_id, v_phase.name, v_phase.description,
      v_phase.wbs_code, v_phase.sort_order, v_phase.estimated_duration_days,
      'pending', v_phase.id
    );

    -- Store mapping: template_phase_id -> project_phase_id
    v_id_mapping := v_id_mapping ||
      jsonb_build_object(v_phase.id::TEXT, v_new_phase_id::TEXT);

    v_phases_created := v_phases_created + 1;

    -- =============================================
    -- CREATE PACKAGES FOR THIS PHASE
    -- =============================================
    FOR v_package IN
      SELECT * FROM template_packages
      WHERE phase_id = v_phase.id
      ORDER BY sort_order
    LOOP
      v_new_package_id := gen_random_uuid();

      INSERT INTO project_packages (
        id, phase_id, name, description, wbs_code, sort_order,
        trade_category, estimated_duration_days, estimated_cost,
        status, source_template_package_id
      ) VALUES (
        v_new_package_id, v_new_phase_id, v_package.name, v_package.description,
        v_package.wbs_code, v_package.sort_order, v_package.trade_category,
        v_package.estimated_duration_days, v_package.estimated_cost,
        'pending', v_package.id
      );

      -- Store mapping
      v_id_mapping := v_id_mapping ||
        jsonb_build_object(v_package.id::TEXT, v_new_package_id::TEXT);

      v_packages_created := v_packages_created + 1;

      -- =============================================
      -- CREATE TASKS FOR THIS PACKAGE
      -- =============================================
      FOR v_task IN
        SELECT * FROM template_tasks
        WHERE package_id = v_package.id
          AND id != ALL(p_excluded_tasks)  -- Skip excluded optional tasks
        ORDER BY sort_order
      LOOP
        v_new_task_id := gen_random_uuid();

        INSERT INTO tasks (
          id, renovation_project_id, title, description,
          estimated_hours, checklist_items, status, priority,
          package_id, wbs_code, is_from_template, source_template_task_id
        ) VALUES (
          v_new_task_id, p_project_id, v_task.name, v_task.description,
          v_task.estimated_duration_days * 8,  -- Convert days to hours
          v_task.checklist_template,
          'open', 'normal',
          v_new_package_id, v_task.wbs_code, true, v_task.id
        );

        -- Store mapping
        v_id_mapping := v_id_mapping ||
          jsonb_build_object(v_task.id::TEXT, v_new_task_id::TEXT);

        v_tasks_created := v_tasks_created + 1;
      END LOOP;
    END LOOP;
  END LOOP;

  -- =============================================
  -- CREATE DEPENDENCIES WITH REMAPPED IDs
  -- =============================================
  FOR v_dep IN
    SELECT * FROM template_dependencies
    WHERE template_id = p_template_id
      AND predecessor_task_id != ALL(p_excluded_tasks)
      AND successor_task_id != ALL(p_excluded_tasks)
  LOOP
    -- Only create if both tasks were created (not excluded)
    IF v_id_mapping ? v_dep.predecessor_task_id::TEXT
       AND v_id_mapping ? v_dep.successor_task_id::TEXT
    THEN
      INSERT INTO task_dependencies (
        task_id,
        depends_on_task_id,
        dependency_type,
        lag_days
      ) VALUES (
        (v_id_mapping ->> v_dep.successor_task_id::TEXT)::UUID,
        (v_id_mapping ->> v_dep.predecessor_task_id::TEXT)::UUID,
        v_dep.dependency_type,
        v_dep.lag_days
      );

      v_deps_created := v_deps_created + 1;
    END IF;
  END LOOP;

  -- =============================================
  -- CREATE QUALITY GATES WITH REMAPPED IDs
  -- =============================================
  FOR v_gate IN
    SELECT * FROM template_quality_gates
    WHERE template_id = p_template_id
  LOOP
    INSERT INTO project_quality_gates (
      id, project_id, gate_level,
      phase_id, package_id,
      name, description, checklist_items,
      min_photos_required, photo_types,
      is_blocking, auto_approve_when_complete,
      source_template_gate_id
    ) VALUES (
      gen_random_uuid(), p_project_id, v_gate.gate_level,
      CASE WHEN v_gate.phase_id IS NOT NULL
           THEN (v_id_mapping ->> v_gate.phase_id::TEXT)::UUID
           ELSE NULL END,
      CASE WHEN v_gate.package_id IS NOT NULL
           THEN (v_id_mapping ->> v_gate.package_id::TEXT)::UUID
           ELSE NULL END,
      v_gate.name, v_gate.description, v_gate.checklist_items,
      v_gate.min_photos_required, v_gate.photo_types,
      v_gate.is_blocking, v_gate.auto_approve_when_complete,
      v_gate.id
    );

    v_gates_created := v_gates_created + 1;
  END LOOP;

  -- =============================================
  -- UPDATE PROJECT METADATA
  -- =============================================
  UPDATE renovation_projects
  SET template_id = p_template_id,
      planned_start_date = COALESCE(planned_start_date, v_start)
  WHERE id = p_project_id;

  RETURN QUERY SELECT v_phases_created, v_packages_created, v_tasks_created, v_deps_created, v_gates_created;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION apply_template_to_project IS 'Atomically applies a template to a project, creating phases, packages, tasks, dependencies, and quality gates with proper ID remapping';
```
</task>

<task id="4" title="Create condition update trigger for TMPL-06" depends_on="3">
Create trigger that updates room/unit condition when project is approved.

Add to `supabase/migrations/035_project_from_template.sql`:

```sql
-- =============================================
-- TMPL-06: CONDITION UPDATE ON PROJECT APPROVAL
-- =============================================

CREATE OR REPLACE FUNCTION update_condition_on_project_approval()
RETURNS TRIGGER AS $$
BEGIN
  -- Only trigger when status changes to 'approved'
  IF NEW.status = 'approved' AND (OLD.status IS NULL OR OLD.status != 'approved') THEN

    -- Get the unit for this project
    -- Update all rooms in the unit to 'new' condition
    UPDATE rooms
    SET
      condition = 'new',
      condition_updated_at = NOW(),
      condition_source_project_id = NEW.id
    WHERE unit_id = NEW.unit_id;

    -- Log condition changes to history (if table exists from 027_condition_tracking.sql)
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'condition_history') THEN
      INSERT INTO condition_history (entity_type, entity_id, old_condition, new_condition, source_project_id, notes, changed_by)
      SELECT
        'room',
        r.id,
        r.condition,
        'new',
        NEW.id,
        'Automatisch aktualisiert nach Projekt-Abnahme: ' || NEW.name,
        NEW.approved_by
      FROM rooms r
      WHERE r.unit_id = NEW.unit_id;
    END IF;

  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_condition_on_approval
AFTER UPDATE ON renovation_projects
FOR EACH ROW
WHEN (NEW.status = 'approved' AND (OLD.status IS DISTINCT FROM 'approved'))
EXECUTE FUNCTION update_condition_on_project_approval();

COMMENT ON FUNCTION update_condition_on_project_approval IS 'TMPL-06: Updates room conditions to new when project is approved';
```
</task>

<task id="5" title="Create template application API route" depends_on="3">
Create `src/app/api/templates/[id]/apply/route.ts`.

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getValidatedSession } from '@/lib/auth/session'

interface RouteParams {
  params: Promise<{ id: string }>
}

interface ApplyTemplateBody {
  project_id: string
  start_date?: string
  excluded_task_ids?: string[]
}

// POST /api/templates/[id]/apply - Apply template to project
export async function POST(request: NextRequest, { params }: RouteParams) {
  const session = await getValidatedSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // Only admin and property_manager can apply templates
  if (session.role !== 'kewa') {
    return NextResponse.json({ error: 'Permission denied' }, { status: 403 })
  }

  const { id: templateId } = await params
  const body: ApplyTemplateBody = await request.json()

  if (!body.project_id) {
    return NextResponse.json(
      { error: 'project_id is required' },
      { status: 400 }
    )
  }

  const supabase = await createClient()

  // Verify template exists and is active
  const { data: template, error: templateError } = await supabase
    .from('templates')
    .select('id, name, is_active')
    .eq('id', templateId)
    .single()

  if (templateError || !template) {
    return NextResponse.json({ error: 'Template not found' }, { status: 404 })
  }

  if (!template.is_active) {
    return NextResponse.json(
      { error: 'Template is not active' },
      { status: 400 }
    )
  }

  // Verify project exists and is in 'planned' status
  const { data: project, error: projectError } = await supabase
    .from('renovation_projects')
    .select('id, name, status, template_id')
    .eq('id', body.project_id)
    .single()

  if (projectError || !project) {
    return NextResponse.json({ error: 'Project not found' }, { status: 404 })
  }

  if (project.status !== 'planned') {
    return NextResponse.json(
      { error: 'Template can only be applied to projects in planned status' },
      { status: 400 }
    )
  }

  if (project.template_id) {
    return NextResponse.json(
      { error: 'Project already has a template applied' },
      { status: 400 }
    )
  }

  // Apply template using the PostgreSQL function
  const { data, error } = await supabase.rpc('apply_template_to_project', {
    p_template_id: templateId,
    p_project_id: body.project_id,
    p_start_date: body.start_date || null,
    p_excluded_tasks: body.excluded_task_ids || []
  })

  if (error) {
    console.error('Template application error:', error)
    return NextResponse.json(
      { error: 'Failed to apply template: ' + error.message },
      { status: 500 }
    )
  }

  const result = data[0]

  return NextResponse.json({
    success: true,
    applied: {
      template_id: templateId,
      template_name: template.name,
      project_id: body.project_id,
      phases_created: result.phases_created,
      packages_created: result.packages_created,
      tasks_created: result.tasks_created,
      dependencies_created: result.dependencies_created,
      gates_created: result.gates_created
    }
  })
}
```
</task>

<task id="6" title="Create dependencies API route" depends_on="1">
Create `src/app/api/templates/[id]/dependencies/route.ts` for CRUD.

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { getValidatedSession } from '@/lib/auth/session'
import { detectCircularDependency } from '@/lib/templates/dependencies'
import type { CreateTemplateDependencyInput } from '@/types/templates'

interface RouteParams {
  params: Promise<{ id: string }>
}

// GET /api/templates/[id]/dependencies - List dependencies
export async function GET(request: NextRequest, { params }: RouteParams) {
  const session = await getValidatedSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { id } = await params
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('template_dependencies')
    .select('*')
    .eq('template_id', id)

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ dependencies: data })
}

// POST /api/templates/[id]/dependencies - Create dependency (admin only)
export async function POST(request: NextRequest, { params }: RouteParams) {
  const session = await getValidatedSession()
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  if (session.role !== 'kewa') {
    return NextResponse.json({ error: 'Admin access required' }, { status: 403 })
  }

  const { id: templateId } = await params
  const body: Omit<CreateTemplateDependencyInput, 'template_id'> = await request.json()

  if (!body.predecessor_task_id || !body.successor_task_id) {
    return NextResponse.json(
      { error: 'predecessor_task_id and successor_task_id are required' },
      { status: 400 }
    )
  }

  const supabase = await createClient()

  // Get existing dependencies
  const { data: existing } = await supabase
    .from('template_dependencies')
    .select('predecessor_task_id, successor_task_id')
    .eq('template_id', templateId)

  // Check for circular dependency
  const proposed = [
    ...(existing || []),
    {
      predecessor_task_id: body.predecessor_task_id,
      successor_task_id: body.successor_task_id
    }
  ]

  const circularCheck = detectCircularDependency(proposed)
  if (circularCheck.hasCircle) {
    return NextResponse.json(
      {
        error: 'Circular dependency detected',
        cycle: circularCheck.cycle
      },
      { status: 400 }
    )
  }

  // Create dependency
  const { data, error } = await supabase
    .from('template_dependencies')
    .insert({
      template_id: templateId,
      predecessor_task_id: body.predecessor_task_id,
      successor_task_id: body.successor_task_id,
      dependency_type: body.dependency_type || 'FS',
      lag_days: body.lag_days || 0
    })
    .select()
    .single()

  if (error) {
    if (error.code === '23505') {
      return NextResponse.json(
        { error: 'Dependency already exists' },
        { status: 400 }
      )
    }
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ dependency: data }, { status: 201 })
}
```
</task>

<task id="7" title="Create circular dependency detection utility" depends_on="6">
Create `src/lib/templates/dependencies.ts` with topological sort.

```typescript
/**
 * Dependency utilities for template system
 * Uses Kahn's algorithm for circular dependency detection
 */

interface Dependency {
  predecessor_task_id: string
  successor_task_id: string
}

/**
 * Detects circular dependencies using topological sort (Kahn's algorithm)
 */
export function detectCircularDependency(dependencies: Dependency[]): {
  hasCircle: boolean
  cycle?: string[]
} {
  // Build adjacency list and in-degree count
  const graph = new Map<string, string[]>()
  const inDegree = new Map<string, number>()

  // Initialize all nodes
  for (const dep of dependencies) {
    if (!graph.has(dep.predecessor_task_id)) {
      graph.set(dep.predecessor_task_id, [])
      inDegree.set(dep.predecessor_task_id, 0)
    }
    if (!graph.has(dep.successor_task_id)) {
      graph.set(dep.successor_task_id, [])
      inDegree.set(dep.successor_task_id, 0)
    }

    // Add edge
    graph.get(dep.predecessor_task_id)!.push(dep.successor_task_id)
    inDegree.set(
      dep.successor_task_id,
      (inDegree.get(dep.successor_task_id) || 0) + 1
    )
  }

  // Find all nodes with in-degree 0
  const queue: string[] = []
  for (const [node, degree] of inDegree) {
    if (degree === 0) {
      queue.push(node)
    }
  }

  // Process nodes
  let processedCount = 0
  while (queue.length > 0) {
    const node = queue.shift()!
    processedCount++

    for (const neighbor of graph.get(node) || []) {
      const newDegree = (inDegree.get(neighbor) || 0) - 1
      inDegree.set(neighbor, newDegree)
      if (newDegree === 0) {
        queue.push(neighbor)
      }
    }
  }

  // If we processed all nodes, no cycle
  if (processedCount === graph.size) {
    return { hasCircle: false }
  }

  // Find the cycle (nodes with remaining in-degree > 0)
  const cycleNodes: string[] = []
  for (const [node, degree] of inDegree) {
    if (degree > 0) {
      cycleNodes.push(node)
    }
  }

  // Try to trace the actual cycle for better error message
  const cycle = traceCycle(graph, cycleNodes[0])

  return {
    hasCircle: true,
    cycle: cycle || cycleNodes
  }
}

/**
 * Traces a cycle starting from a given node
 */
function traceCycle(graph: Map<string, string[]>, startNode: string): string[] | null {
  const visited = new Set<string>()
  const path: string[] = []

  function dfs(node: string): string[] | null {
    if (path.includes(node)) {
      // Found cycle - return from cycle start
      const cycleStart = path.indexOf(node)
      return [...path.slice(cycleStart), node]
    }

    if (visited.has(node)) {
      return null
    }

    visited.add(node)
    path.push(node)

    for (const neighbor of graph.get(node) || []) {
      const result = dfs(neighbor)
      if (result) return result
    }

    path.pop()
    return null
  }

  return dfs(startNode)
}

/**
 * Validates a new dependency won't create a cycle
 */
export async function validateDependency(
  existingDeps: Dependency[],
  newPredecessor: string,
  newSuccessor: string
): Promise<{ valid: boolean; error?: string; cycle?: string[] }> {
  // Self-reference check
  if (newPredecessor === newSuccessor) {
    return {
      valid: false,
      error: 'Task cannot depend on itself'
    }
  }

  // Check for circular dependency
  const allDeps = [
    ...existingDeps,
    { predecessor_task_id: newPredecessor, successor_task_id: newSuccessor }
  ]

  const result = detectCircularDependency(allDeps)

  if (result.hasCircle) {
    return {
      valid: false,
      error: 'Would create circular dependency',
      cycle: result.cycle
    }
  }

  return { valid: true }
}

/**
 * Get all tasks that depend on a given task (direct and indirect)
 */
export function getDependentTasks(
  dependencies: Dependency[],
  taskId: string
): string[] {
  const dependents = new Set<string>()
  const queue = [taskId]

  while (queue.length > 0) {
    const current = queue.shift()!

    for (const dep of dependencies) {
      if (dep.predecessor_task_id === current && !dependents.has(dep.successor_task_id)) {
        dependents.add(dep.successor_task_id)
        queue.push(dep.successor_task_id)
      }
    }
  }

  return Array.from(dependents)
}

/**
 * Get all tasks that a given task depends on (direct and indirect)
 */
export function getPrerequisiteTasks(
  dependencies: Dependency[],
  taskId: string
): string[] {
  const prerequisites = new Set<string>()
  const queue = [taskId]

  while (queue.length > 0) {
    const current = queue.shift()!

    for (const dep of dependencies) {
      if (dep.successor_task_id === current && !prerequisites.has(dep.predecessor_task_id)) {
        prerequisites.add(dep.predecessor_task_id)
        queue.push(dep.predecessor_task_id)
      }
    }
  }

  return Array.from(prerequisites)
}
```
</task>

<task id="8" title="Create template application client library" depends_on="5">
Create `src/lib/templates/apply.ts` with application helper functions.

```typescript
import type { TemplateWithHierarchy, TemplateTask } from '@/types/templates'

/**
 * Apply a template to a project
 */
export async function applyTemplateToProject(options: {
  templateId: string
  projectId: string
  startDate?: Date
  excludedTaskIds?: string[]
}): Promise<{
  success: boolean
  phases_created: number
  packages_created: number
  tasks_created: number
  dependencies_created: number
  gates_created: number
}> {
  const response = await fetch(`/api/templates/${options.templateId}/apply`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      project_id: options.projectId,
      start_date: options.startDate?.toISOString().split('T')[0],
      excluded_task_ids: options.excludedTaskIds || []
    })
  })

  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error || 'Failed to apply template')
  }

  const data = await response.json()
  return data.applied
}

/**
 * Stack multiple templates onto a project
 */
export async function stackTemplates(
  projectId: string,
  templates: Array<{
    templateId: string
    excludedTaskIds?: string[]
  }>,
  startDate: Date
): Promise<Array<{
  templateId: string
  tasks_created: number
  dependencies_created: number
}>> {
  const results = []

  for (const template of templates) {
    const result = await applyTemplateToProject({
      templateId: template.templateId,
      projectId,
      startDate,
      excludedTaskIds: template.excludedTaskIds
    })

    results.push({
      templateId: template.templateId,
      tasks_created: result.tasks_created,
      dependencies_created: result.dependencies_created
    })
  }

  return results
}

/**
 * Get all optional tasks from a template for preview
 */
export function getOptionalTasks(template: TemplateWithHierarchy): TemplateTask[] {
  const optional: TemplateTask[] = []

  for (const phase of template.phases) {
    for (const pkg of phase.packages) {
      for (const task of pkg.tasks) {
        if (task.is_optional) {
          optional.push(task)
        }
      }
    }
  }

  return optional
}

/**
 * Calculate total duration and cost for selected tasks
 */
export function calculateTemplateMetrics(
  template: TemplateWithHierarchy,
  excludedTaskIds: Set<string>
): {
  totalDays: number
  totalCost: number
  taskCount: number
} {
  let totalDays = 0
  let totalCost = 0
  let taskCount = 0

  for (const phase of template.phases) {
    for (const pkg of phase.packages) {
      for (const task of pkg.tasks) {
        if (!excludedTaskIds.has(task.id)) {
          totalDays += task.estimated_duration_days
          totalCost += task.estimated_cost || 0
          taskCount++
        }
      }
    }
  }

  return { totalDays, totalCost, taskCount }
}

/**
 * Get tasks that would be affected by excluding an optional task
 * (tasks that depend on it)
 */
export function getAffectedByExclusion(
  template: TemplateWithHierarchy,
  taskId: string
): string[] {
  const affected: string[] = []

  for (const dep of template.dependencies) {
    if (dep.predecessor_task_id === taskId) {
      affected.push(dep.successor_task_id)
    }
  }

  return affected
}
```
</task>

<task id="9" title="Create TemplateApplyWizard component" depends_on="8">
Create `src/components/templates/TemplateApplyWizard.tsx`.

Wizard steps:
1. Select template (show template library)
2. Configure optional tasks (toggle on/off)
3. Set start date
4. Preview (show task count, duration, cost)
5. Apply (call API, show result)

Features:
- Show warning when excluding task with dependents
- Calculate and display affected metrics in real-time
- Support stacking (apply multiple templates)
</task>

<task id="10" title="Create DependencyEditor component" depends_on="7">
Create `src/components/templates/DependencyEditor.tsx`.

Features:
- List current dependencies with type and lag
- Add new dependency: select predecessor and successor from task dropdown
- Dependency type selector (FS, SS, FF, SF)
- Lag days input
- Delete dependency
- Visual warning on potential circular dependency
- Show affected tasks when hovering over a dependency
</task>

<task id="11" title="Create apply template page" depends_on="9">
Create `src/app/renovation-projects/[id]/apply-template/page.tsx`.

Use TemplateApplyWizard component.
Redirect back to project detail on success.
</task>

<task id="12" title="Add runtime types for project hierarchy" depends_on="2">
Add types for project phases, packages, and quality gates to `src/types/templates.ts`.

```typescript
// =============================================
// RUNTIME PROJECT HIERARCHY TYPES
// =============================================

/**
 * Runtime project phase (created from template)
 */
export interface ProjectPhase {
  id: string
  project_id: string
  name: string
  description: string | null
  sort_order: number
  wbs_code: string
  estimated_duration_days: number | null
  actual_duration_days: number | null
  planned_start_date: string | null
  planned_end_date: string | null
  actual_start_date: string | null
  actual_end_date: string | null
  status: 'pending' | 'in_progress' | 'completed' | 'blocked'
  source_template_phase_id: string | null
  created_at: string
  updated_at: string
}

/**
 * Runtime project package
 */
export interface ProjectPackage {
  id: string
  phase_id: string
  name: string
  description: string | null
  sort_order: number
  wbs_code: string
  trade_category: TradeCategory | null
  estimated_duration_days: number | null
  estimated_cost: number | null
  actual_cost: number | null
  status: 'pending' | 'in_progress' | 'completed' | 'blocked'
  source_template_package_id: string | null
  created_at: string
  updated_at: string
}

/**
 * Runtime quality gate with progress tracking
 */
export interface ProjectQualityGate {
  id: string
  project_id: string
  gate_level: GateLevel
  phase_id: string | null
  package_id: string | null
  name: string
  description: string | null
  checklist_items: TemplateChecklistItem[]
  checklist_progress: Array<{
    id: string
    completed: boolean
    completed_at: string | null
    completed_by: string | null
  }>
  min_photos_required: number
  photo_types: string[]
  is_blocking: boolean
  auto_approve_when_complete: boolean
  status: 'pending' | 'passed' | 'failed'
  approved_at: string | null
  approved_by: string | null
  source_template_gate_id: string | null
  created_at: string
  updated_at: string
}

/**
 * Template application result
 */
export interface TemplateApplicationResult {
  template_id: string
  template_name: string
  project_id: string
  phases_created: number
  packages_created: number
  tasks_created: number
  dependencies_created: number
  gates_created: number
}
```
</task>

## Verification

- [ ] Migration 035 creates project_phases, project_packages, project_quality_gates tables
- [ ] Migration 036 extends task_dependencies with dependency_type and lag_days
- [ ] apply_template_to_project function creates all entities atomically
- [ ] Circular dependency detection prevents invalid dependency chains
- [ ] POST /api/templates/[id]/apply successfully applies template to project
- [ ] Dependencies API validates circular references before insert
- [ ] TemplateApplyWizard allows optional task selection
- [ ] Condition update trigger fires when project status becomes 'approved'
- [ ] Room conditions update to 'new' after project approval
- [ ] Condition history logs the changes (TMPL-06)

## Must Haves

These are goal-backward success criteria derived from TMPL-04, TMPL-06:

- [ ] Task dependencies include type (FS/SS/FF/SF) and lag days (TMPL-04)
- [ ] Dependencies are copied during template application with ID remapping
- [ ] Circular dependency detection prevents invalid templates
- [ ] Template can be applied to project in 'planned' status only
- [ ] Optional tasks can be excluded during application
- [ ] Project approval triggers room condition update to 'new' (TMPL-06)
- [ ] Condition update is logged to history with project reference
