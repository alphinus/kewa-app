# Plan: Status Workflows & NFR Implementation

```yaml
---
phase: 07
plan: 05
name: status-workflows-nfr
wave: 2
autonomous: true
scope: medium
requirements:
  - STAT-01
  - STAT-02
  - STAT-03
  - STAT-04
  - NFR-01
  - NFR-02
  - NFR-03
  - NFR-04
  - NFR-05
  - NFR-06
must_haves:
  - WorkOrder status transitions enforced (draft→sent→viewed→accepted/rejected→in_progress→done→inspected→closed)
  - RenovationProject status transitions enforced (planned→active→blocked→finished→approved)
  - Room/Unit condition enum (old|partial|new) with tracking
  - Condition updates linked to source project and media
  - Audit logging on all write operations (NFR-01)
  - RLS policies for tenant data isolation (NFR-02)
  - Retention policy configurable (NFR-03)
  - File storage for PDFs and photos (NFR-04)
  - Token-based external access with expiry (NFR-05)
  - Contractor page mobile-optimized (NFR-06)
---
```

## Objective

Implement status workflow enforcement and non-functional requirements. Status state machines ensure data integrity; NFRs ensure security, privacy, and usability.

## Context

**Status Workflows (STAT-01 to STAT-04):**
- WorkOrder has 9-state workflow with clear transitions
- RenovationProject has 5-state workflow
- Room/Unit condition is derived from project completion
- Condition tracking links to evidence (project, media, date)

**Non-Functional Requirements (NFR-01 to NFR-06):**
- Audit logging already created in Plan 07-02 (implement triggers)
- Swiss data privacy: tenant data isolated
- Configurable retention for audit logs
- File storage configuration for Supabase Storage
- Magic link tokens already created in Plan 07-04 (verify expiry)
- Mobile-first contractor portal

## Tasks

### Task 1: Implement WorkOrder Status Transitions (STAT-01)

**What:** Enforce valid state transitions for WorkOrders.

**SQL Migration:** `supabase/migrations/025_work_order_status.sql`

```sql
-- Valid WorkOrder status transitions
CREATE OR REPLACE FUNCTION validate_work_order_status_transition()
RETURNS TRIGGER AS $$
DECLARE
  valid_transitions JSONB := '{
    "draft": ["sent"],
    "sent": ["viewed", "draft"],
    "viewed": ["accepted", "rejected"],
    "accepted": ["in_progress"],
    "rejected": ["draft"],
    "in_progress": ["done", "blocked"],
    "blocked": ["in_progress", "done"],
    "done": ["inspected"],
    "inspected": ["closed", "in_progress"]
  }'::JSONB;
  allowed_next TEXT[];
BEGIN
  -- Skip if status not changed
  IF OLD.status = NEW.status THEN
    RETURN NEW;
  END IF;

  -- Get allowed transitions
  allowed_next := ARRAY(SELECT jsonb_array_elements_text(valid_transitions->OLD.status::TEXT));

  -- Check if transition is valid
  IF NOT (NEW.status::TEXT = ANY(allowed_next)) THEN
    RAISE EXCEPTION 'Invalid status transition: % -> %. Allowed: %',
      OLD.status, NEW.status, array_to_string(allowed_next, ', ');
  END IF;

  -- Auto-set timestamps based on status
  CASE NEW.status
    WHEN 'sent' THEN
      NEW.updated_at = NOW();
    WHEN 'viewed' THEN
      NEW.viewed_at = NOW();
    WHEN 'accepted' THEN
      NEW.accepted_at = NOW();
    WHEN 'rejected' THEN
      NEW.rejected_at = NOW();
    WHEN 'in_progress' THEN
      IF NEW.actual_start_date IS NULL THEN
        NEW.actual_start_date = CURRENT_DATE;
      END IF;
    WHEN 'done' THEN
      IF NEW.actual_end_date IS NULL THEN
        NEW.actual_end_date = CURRENT_DATE;
      END IF;
    ELSE
      -- No special handling
  END CASE;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER work_orders_status_transition
  BEFORE UPDATE OF status ON work_orders
  FOR EACH ROW EXECUTE FUNCTION validate_work_order_status_transition();

-- Function to check if work order can transition
CREATE OR REPLACE FUNCTION can_transition_work_order(
  p_work_order_id UUID,
  p_new_status work_order_status
) RETURNS BOOLEAN AS $$
DECLARE
  current_status work_order_status;
  valid_transitions JSONB := '{
    "draft": ["sent"],
    "sent": ["viewed", "draft"],
    "viewed": ["accepted", "rejected"],
    "accepted": ["in_progress"],
    "rejected": ["draft"],
    "in_progress": ["done", "blocked"],
    "blocked": ["in_progress", "done"],
    "done": ["inspected"],
    "inspected": ["closed", "in_progress"]
  }'::JSONB;
BEGIN
  SELECT status INTO current_status FROM work_orders WHERE id = p_work_order_id;

  IF current_status IS NULL THEN
    RETURN FALSE;
  END IF;

  RETURN p_new_status::TEXT = ANY(
    ARRAY(SELECT jsonb_array_elements_text(valid_transitions->current_status::TEXT))
  );
END;
$$ LANGUAGE plpgsql;
```

**Acceptance:**
- Invalid transitions raise exception
- Timestamps auto-set on transitions
- Helper function to check valid transitions

---

### Task 2: Implement RenovationProject Status Transitions (STAT-02)

**What:** Enforce valid state transitions for RenovationProjects.

**SQL Migration:** `supabase/migrations/026_project_status.sql`

```sql
-- Valid RenovationProject status transitions
CREATE OR REPLACE FUNCTION validate_project_status_transition()
RETURNS TRIGGER AS $$
DECLARE
  valid_transitions JSONB := '{
    "planned": ["active"],
    "active": ["blocked", "finished"],
    "blocked": ["active", "finished"],
    "finished": ["approved", "active"],
    "approved": []
  }'::JSONB;
  allowed_next TEXT[];
BEGIN
  -- Skip if status not changed
  IF OLD.status = NEW.status THEN
    RETURN NEW;
  END IF;

  -- Get allowed transitions
  allowed_next := ARRAY(SELECT jsonb_array_elements_text(valid_transitions->OLD.status::TEXT));

  -- Check if transition is valid (approved is final)
  IF array_length(allowed_next, 1) = 0 OR array_length(allowed_next, 1) IS NULL THEN
    IF OLD.status::TEXT = 'approved' THEN
      RAISE EXCEPTION 'Cannot change status of approved project';
    END IF;
  END IF;

  IF NOT (NEW.status::TEXT = ANY(allowed_next)) THEN
    RAISE EXCEPTION 'Invalid project status transition: % -> %. Allowed: %',
      OLD.status, NEW.status, array_to_string(allowed_next, ', ');
  END IF;

  -- Auto-set timestamps based on status
  CASE NEW.status
    WHEN 'active' THEN
      IF NEW.actual_start_date IS NULL THEN
        NEW.actual_start_date = CURRENT_DATE;
      END IF;
    WHEN 'finished' THEN
      IF NEW.actual_end_date IS NULL THEN
        NEW.actual_end_date = CURRENT_DATE;
      END IF;
    WHEN 'approved' THEN
      NEW.approved_at = NOW();
    ELSE
      -- No special handling
  END CASE;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER projects_status_transition
  BEFORE UPDATE OF status ON renovation_projects
  FOR EACH ROW EXECUTE FUNCTION validate_project_status_transition();
```

**Acceptance:**
- Invalid transitions raise exception
- Approved is terminal state
- Timestamps auto-set on transitions

---

### Task 3: Implement Condition Tracking (STAT-03, STAT-04)

**What:** Room/Unit condition enum and tracking system.

**SQL Migration:** `supabase/migrations/027_condition_tracking.sql`

```sql
-- Condition history table (tracks changes over time)
CREATE TABLE IF NOT EXISTS condition_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- What changed
  entity_type TEXT NOT NULL CHECK (entity_type IN ('room', 'unit', 'component')),
  entity_id UUID NOT NULL,

  -- Condition change
  old_condition room_condition,
  new_condition room_condition NOT NULL,

  -- Source of change
  source_project_id UUID REFERENCES renovation_projects(id),
  source_work_order_id UUID REFERENCES work_orders(id),

  -- Evidence
  media_ids UUID[], -- Links to before/after media

  -- Notes
  notes TEXT,

  -- Metadata
  changed_by UUID REFERENCES users(id),
  changed_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_condition_history_entity ON condition_history(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_condition_history_date ON condition_history(changed_at);

-- Function to update room condition (called when project approved)
CREATE OR REPLACE FUNCTION update_room_condition_from_project(
  p_project_id UUID,
  p_user_id UUID
) RETURNS void AS $$
DECLARE
  v_room RECORD;
  v_old_condition room_condition;
BEGIN
  -- Get all rooms affected by this project's tasks
  FOR v_room IN
    SELECT DISTINCT r.id, r.condition
    FROM rooms r
    JOIN tasks t ON t.room_id = r.id
    WHERE t.renovation_project_id = p_project_id
      AND t.status = 'completed'
  LOOP
    v_old_condition := v_room.condition;

    -- Update room to 'new' condition
    UPDATE rooms
    SET condition = 'new',
        condition_updated_at = NOW(),
        condition_source_project_id = p_project_id
    WHERE id = v_room.id;

    -- Record history
    INSERT INTO condition_history (
      entity_type, entity_id, old_condition, new_condition,
      source_project_id, changed_by
    ) VALUES (
      'room', v_room.id, v_old_condition, 'new',
      p_project_id, p_user_id
    );
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Trigger: when project approved, update room conditions
CREATE OR REPLACE FUNCTION on_project_approved()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'approved' AND OLD.status != 'approved' THEN
    PERFORM update_room_condition_from_project(NEW.id, NEW.approved_by);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER projects_on_approved
  AFTER UPDATE OF status ON renovation_projects
  FOR EACH ROW EXECUTE FUNCTION on_project_approved();

-- View: Unit condition summary (calculated from rooms)
CREATE OR REPLACE VIEW unit_condition_summary AS
SELECT
  u.id as unit_id,
  u.name as unit_name,
  COUNT(r.id) as total_rooms,
  COUNT(CASE WHEN r.condition = 'new' THEN 1 END) as new_rooms,
  COUNT(CASE WHEN r.condition = 'partial' THEN 1 END) as partial_rooms,
  COUNT(CASE WHEN r.condition = 'old' THEN 1 END) as old_rooms,
  ROUND(
    COUNT(CASE WHEN r.condition = 'new' THEN 1 END)::NUMERIC /
    NULLIF(COUNT(r.id), 0) * 100, 1
  ) as renovation_percentage,
  CASE
    WHEN COUNT(r.id) = 0 THEN NULL
    WHEN COUNT(CASE WHEN r.condition = 'new' THEN 1 END) = COUNT(r.id) THEN 'new'
    WHEN COUNT(CASE WHEN r.condition = 'old' THEN 1 END) = COUNT(r.id) THEN 'old'
    ELSE 'partial'
  END::room_condition as overall_condition
FROM units u
LEFT JOIN rooms r ON r.unit_id = u.id
GROUP BY u.id, u.name;
```

**Acceptance:**
- Condition history tracks all changes
- Project approval auto-updates room conditions
- Unit summary view calculates overall condition

---

### Task 4: Implement Audit Logging Triggers (NFR-01)

**What:** Automatic audit logging for all tables.

**SQL Migration:** `supabase/migrations/028_audit_triggers.sql`

```sql
-- Generic audit trigger function
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
  v_old_values JSONB;
  v_new_values JSONB;
  v_action audit_action;
  v_user_id UUID;
BEGIN
  -- Determine action
  IF TG_OP = 'INSERT' THEN
    v_action := 'create';
    v_new_values := to_jsonb(NEW);
    v_old_values := NULL;
    v_user_id := NEW.created_by;
  ELSIF TG_OP = 'UPDATE' THEN
    v_action := 'update';
    v_old_values := to_jsonb(OLD);
    v_new_values := to_jsonb(NEW);
    -- Try to get user from updated_by or created_by
    v_user_id := COALESCE(
      (v_new_values->>'updated_by')::UUID,
      (v_new_values->>'created_by')::UUID
    );
  ELSIF TG_OP = 'DELETE' THEN
    v_action := 'delete';
    v_old_values := to_jsonb(OLD);
    v_new_values := NULL;
    v_user_id := NULL;
  END IF;

  -- Insert audit log
  INSERT INTO audit_logs (
    table_name,
    record_id,
    action,
    user_id,
    old_values,
    new_values
  ) VALUES (
    TG_TABLE_NAME,
    COALESCE((NEW).id, (OLD).id),
    v_action,
    v_user_id,
    v_old_values,
    v_new_values
  );

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

-- Add audit triggers to all important tables
DO $$
DECLARE
  tables TEXT[] := ARRAY[
    'properties', 'buildings', 'units', 'rooms', 'components',
    'renovation_projects', 'tasks', 'work_orders',
    'partners', 'offers', 'invoices', 'expenses', 'payments',
    'media', 'users'
  ];
  t TEXT;
BEGIN
  FOREACH t IN ARRAY tables
  LOOP
    EXECUTE format('
      DROP TRIGGER IF EXISTS audit_%I ON %I;
      CREATE TRIGGER audit_%I
        AFTER INSERT OR UPDATE OR DELETE ON %I
        FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    ', t, t, t, t);
  END LOOP;
END;
$$;
```

**Acceptance:**
- All major tables have audit triggers
- INSERT/UPDATE/DELETE all logged
- Old and new values captured

---

### Task 5: Implement Row Level Security (NFR-02)

**What:** RLS policies for tenant data isolation.

**SQL Migration:** `supabase/migrations/029_rls_policies.sql`

```sql
-- Enable RLS on tenant-sensitive tables
ALTER TABLE units ENABLE ROW LEVEL SECURITY;
ALTER TABLE rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE work_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE renovation_projects ENABLE ROW LEVEL SECURITY;

-- Policy: Internal users see all
CREATE POLICY internal_full_access ON units
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users u
      JOIN roles r ON u.role_id = r.id
      WHERE u.id = auth.uid() AND r.is_internal = true
    )
  );

-- Policy: Tenants see only their units
CREATE POLICY tenant_own_units ON units
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM tenant_users tu
      WHERE tu.unit_id = units.id
        AND tu.user_id = auth.uid()
    )
  );

-- Similar policies for rooms, tasks, etc.
-- Rooms: inherit from unit access
CREATE POLICY internal_full_access ON rooms
  FOR ALL
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users u
      JOIN roles r ON u.role_id = r.id
      WHERE u.id = auth.uid() AND r.is_internal = true
    )
  );

CREATE POLICY tenant_own_rooms ON rooms
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM tenant_users tu
      WHERE tu.unit_id = rooms.unit_id
        AND tu.user_id = auth.uid()
    )
  );

-- WorkOrders: contractors see only their assigned orders
CREATE POLICY contractor_own_work_orders ON work_orders
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM users u
      JOIN partners p ON u.email = p.email
      WHERE u.id = auth.uid()
        AND p.id = work_orders.partner_id
    )
  );

-- Note: These are base policies. API routes will also enforce access
-- through application logic for more complex rules.
```

**Acceptance:**
- RLS enabled on sensitive tables
- Internal users have full access
- Tenants see only their units/rooms
- Contractors see only their work orders

---

### Task 6: Configure Retention Policy (NFR-03)

**What:** Configurable retention for audit logs and tokens.

**SQL Migration:** `supabase/migrations/030_retention.sql`

```sql
-- Settings table for configurable values
CREATE TABLE IF NOT EXISTS system_settings (
  key TEXT PRIMARY KEY,
  value JSONB NOT NULL,
  description TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  updated_by UUID REFERENCES users(id)
);

-- Seed default retention settings
INSERT INTO system_settings (key, value, description) VALUES
  ('audit_log_retention_days', '365', 'Days to keep audit logs'),
  ('magic_link_expiry_hours', '72', 'Hours until magic link expires'),
  ('magic_link_cleanup_days', '30', 'Days to keep expired magic links'),
  ('media_retention_days', '0', 'Days to keep media (0 = forever)')
ON CONFLICT (key) DO NOTHING;

-- Function to clean up old audit logs
CREATE OR REPLACE FUNCTION cleanup_old_audit_logs()
RETURNS INTEGER AS $$
DECLARE
  retention_days INTEGER;
  deleted_count INTEGER;
BEGIN
  SELECT (value::TEXT)::INTEGER INTO retention_days
  FROM system_settings WHERE key = 'audit_log_retention_days';

  IF retention_days IS NULL OR retention_days <= 0 THEN
    RETURN 0; -- No cleanup if retention is 0 or not set
  END IF;

  DELETE FROM audit_logs
  WHERE created_at < NOW() - (retention_days || ' days')::INTERVAL;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Function to clean up expired magic links
CREATE OR REPLACE FUNCTION cleanup_expired_magic_links()
RETURNS INTEGER AS $$
DECLARE
  cleanup_days INTEGER;
  deleted_count INTEGER;
BEGIN
  SELECT (value::TEXT)::INTEGER INTO cleanup_days
  FROM system_settings WHERE key = 'magic_link_cleanup_days';

  IF cleanup_days IS NULL OR cleanup_days <= 0 THEN
    cleanup_days := 30; -- Default
  END IF;

  DELETE FROM magic_link_tokens
  WHERE expires_at < NOW() - (cleanup_days || ' days')::INTERVAL;

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;
```

**Acceptance:**
- System settings table for configuration
- Retention periods configurable
- Cleanup functions for audit logs and tokens

---

### Task 7: Configure File Storage (NFR-04)

**What:** Supabase Storage buckets for all file types.

**SQL Migration:** `supabase/migrations/031_storage_buckets.sql`

```sql
-- Note: Bucket creation via Supabase Dashboard or supabase CLI
-- This migration documents the required buckets

/*
Required Supabase Storage Buckets:

1. task-photos (exists from v1)
   - Public: false
   - Max file size: 10MB
   - Allowed types: image/webp, image/jpeg, image/png

2. task-audio (exists from v1)
   - Public: false
   - Max file size: 50MB
   - Allowed types: audio/webm, audio/mp4, audio/mpeg

3. documents (new)
   - Public: false
   - Max file size: 20MB
   - Allowed types: application/pdf, image/*

4. media (new - unified)
   - Public: false
   - Max file size: 50MB
   - Allowed types: image/*, video/*, audio/*, application/pdf

Storage path conventions:
- tasks/{task_id}/{photo_type}/{uuid}.webp
- work_orders/{work_order_id}/documents/{uuid}.pdf
- offers/{offer_id}/{uuid}.pdf
- invoices/{invoice_id}/{uuid}.pdf
- receipts/{expense_id}/{uuid}.pdf
- rooms/{room_id}/media/{uuid}.{ext}
*/

-- Storage policies (to be applied via Supabase Dashboard)
-- These are documented here for reference:

-- Policy: Authenticated users can upload to their assigned areas
-- Policy: Internal users can access all files
-- Policy: Tenants can only access files in their units
-- Policy: Contractors can only access files in their work orders
```

**Files:** `supabase/setup_storage.md` (documentation)

**Acceptance:**
- All required buckets exist
- File size limits configured
- Storage paths documented

---

### Task 8: Verify Token Expiry (NFR-05)

**What:** Ensure magic link tokens expire correctly.

**Files:**
- `src/lib/magic-link.ts` — Token utilities

```typescript
// Already implemented in Plan 07-04
// This task verifies expiry logic:

interface MagicLinkConfig {
  expiryHours: number; // From system_settings
  singleUse: boolean;  // Mark as used after first access
}

async function createMagicLink(
  workOrderId: string,
  email: string,
  config?: Partial<MagicLinkConfig>
): Promise<{ token: string; url: string; expiresAt: Date }>;

async function verifyMagicLink(token: string): Promise<{
  valid: boolean;
  workOrderId?: string;
  email?: string;
  error?: 'expired' | 'used' | 'revoked' | 'not_found';
}>;

async function revokeMagicLink(token: string): Promise<void>;
```

**Acceptance:**
- Tokens expire after configured hours (default 72)
- Expired tokens return error
- Used tokens marked and cannot be reused
- Revocation works

---

### Task 9: Mobile-Friendly Contractor Page (NFR-06)

**What:** Ensure contractor portal is mobile-optimized.

**Files:**
- `src/app/contractor/[token]/page.tsx` — Contractor portal page
- `src/app/contractor/[token]/layout.tsx` — Mobile-first layout
- `src/components/contractor/` — Mobile-optimized components

**Mobile Requirements:**
- Touch-friendly buttons (min 44px height)
- Readable text without zooming (16px base)
- No horizontal scrolling
- Fast load time (< 3s on 3G)
- Works offline after initial load (PWA shell)

**Acceptance:**
- Lighthouse mobile score > 90
- Works on 320px width screens
- Large touch targets
- Responsive images

---

## Verification

```bash
# Status transitions
supabase db query "SELECT can_transition_work_order('uuid', 'accepted')"

# Audit logs created
supabase db query "SELECT COUNT(*) FROM audit_logs"

# RLS working
# Test as tenant user - should only see own units

# Storage buckets
supabase storage list

# TypeScript
npm run type-check

# Mobile test
npx lighthouse http://localhost:3000/contractor/test-token --view
```

## Success Criteria

- [ ] WorkOrder status transitions enforced
- [ ] RenovationProject status transitions enforced
- [ ] Room/Unit condition tracking functional
- [ ] Audit triggers on all tables
- [ ] RLS policies active and tested
- [ ] Retention settings configurable
- [ ] Storage buckets configured
- [ ] Magic link expiry working
- [ ] Contractor page mobile-optimized

## Output

**New Files:**
- `supabase/migrations/025_work_order_status.sql`
- `supabase/migrations/026_project_status.sql`
- `supabase/migrations/027_condition_tracking.sql`
- `supabase/migrations/028_audit_triggers.sql`
- `supabase/migrations/029_rls_policies.sql`
- `supabase/migrations/030_retention.sql`
- `supabase/migrations/031_storage_buckets.sql`
- `supabase/setup_storage.md`
- `src/lib/magic-link.ts`
- `src/app/contractor/[token]/page.tsx`
- `src/app/contractor/[token]/layout.tsx`

**Modified Files:**
- `src/types/database.ts` (condition history types)
