# Plan: Core Data Model Migration

```yaml
---
phase: 07
plan: 02
name: core-data-model
wave: 1
autonomous: true
scope: large
requirements:
  - DATA-01
  - DATA-02
  - DATA-03
  - DATA-04
  - DATA-05
  - DATA-06
  - DATA-07
  - DATA-08
  - DATA-09
  - DATA-14
  - DATA-15
must_haves:
  - Property table exists with columns: id, name, address, created_at, updated_at
  - Building table has property_id foreign key
  - Unit table has rent_amount field
  - Room table with room_type enum (bathroom, kitchen, bedroom, living, hallway, balcony, storage, other)
  - Component table optional but schema defined
  - RenovationProject table with status enum
  - Task table has dependencies and checklist_items JSONB
  - WorkOrder table with full workflow status enum
  - Partner table with partner_type and trade categories
  - Media table with before_after metadata
  - AuditLog table captures all changes
---
```

## Objective

Create comprehensive data model for renovation operations system. Migrate from simple task-app schema to full property → building → unit → room → project → task hierarchy with cost tracking entities.

## Context

**Current Schema (v1):**
- `users` — 2 PIN-based users (kewa, imeri)
- `buildings` — Single building record
- `units` — 23 units (apartments + common areas)
- `projects` — Simple project container
- `tasks` — Task with recurring support
- `task_photos` / `task_audio` — Media attachments

**Target Schema (v2.0):**
- Hierarchical: Property → Building → Unit → Room → Component
- Project types: RenovationProject (with templates, phases)
- Work management: Task (internal) + WorkOrder (external contractors)
- Partners: Handwerker, Lieferanten with trade categories
- Cost tracking: Offer, Invoice, Expense, Payment (Plan 03)
- Audit: Full change logging

**Migration Strategy:**
1. Add new tables without breaking existing
2. Migrate existing data where applicable
3. Add foreign keys and indexes
4. Enable RLS policies

## Tasks

### Task 1: Create Property & Building Enhancement (DATA-01, DATA-02)

**What:** Add Property entity and enhance Building with property relationship.

**SQL Migration:** `supabase/migrations/008_property_building.sql`

```sql
-- Property (Liegenschaft) entity
CREATE TABLE IF NOT EXISTS properties (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  address TEXT,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add property_id to buildings (make nullable for migration)
ALTER TABLE buildings
ADD COLUMN IF NOT EXISTS property_id UUID REFERENCES properties(id);

-- Create default property and link existing building
INSERT INTO properties (name, address)
VALUES ('Liegenschaft KEWA', 'Adresse TBD')
ON CONFLICT DO NOTHING;

UPDATE buildings
SET property_id = (SELECT id FROM properties LIMIT 1)
WHERE property_id IS NULL;

-- Index for lookups
CREATE INDEX IF NOT EXISTS idx_buildings_property_id ON buildings(property_id);

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER properties_updated_at
  BEFORE UPDATE ON properties
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

**TypeScript Types:** Update `src/types/database.ts`

**Acceptance:**
- Property table created
- Existing building linked to default property
- TypeScript types updated

---

### Task 2: Enhance Unit with Rent & Room Support (DATA-03, DATA-04)

**What:** Add rent tracking to Unit, create Room entity with type classification.

**SQL Migration:** `supabase/migrations/009_unit_room.sql`

```sql
-- Room type enum
CREATE TYPE room_type AS ENUM (
  'bathroom', 'kitchen', 'bedroom', 'living_room',
  'hallway', 'balcony', 'storage', 'laundry',
  'garage', 'office', 'other'
);

-- Room condition enum (for Digital Twin)
CREATE TYPE room_condition AS ENUM ('old', 'partial', 'new');

-- Add rent to units
ALTER TABLE units
ADD COLUMN IF NOT EXISTS rent_amount DECIMAL(10,2),
ADD COLUMN IF NOT EXISTS rent_currency TEXT DEFAULT 'CHF';

-- Rooms table
CREATE TABLE IF NOT EXISTS rooms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  unit_id UUID NOT NULL REFERENCES units(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  room_type room_type NOT NULL DEFAULT 'other',
  condition room_condition DEFAULT 'old',
  condition_updated_at TIMESTAMPTZ,
  condition_source_project_id UUID,
  area_sqm DECIMAL(8,2),
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_rooms_unit_id ON rooms(unit_id);
CREATE INDEX IF NOT EXISTS idx_rooms_condition ON rooms(condition);

CREATE TRIGGER rooms_updated_at
  BEFORE UPDATE ON rooms
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

**Acceptance:**
- Units have rent_amount field
- Rooms table created with type enum
- Condition tracking fields present for Digital Twin (Phase 11)

---

### Task 3: Create Component Entity (DATA-05)

**What:** Optional Component entity for granular tracking (Boden, Wände, Fenster).

**SQL Migration:** `supabase/migrations/010_component.sql`

```sql
-- Component type enum
CREATE TYPE component_type AS ENUM (
  'floor', 'walls', 'ceiling', 'windows', 'doors',
  'electrical', 'plumbing', 'heating', 'ventilation',
  'kitchen_appliances', 'bathroom_fixtures', 'other'
);

-- Components table (optional granular tracking)
CREATE TABLE IF NOT EXISTS components (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  room_id UUID NOT NULL REFERENCES rooms(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  component_type component_type NOT NULL,
  condition room_condition DEFAULT 'old',
  condition_updated_at TIMESTAMPTZ,
  notes TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_components_room_id ON components(room_id);

CREATE TRIGGER components_updated_at
  BEFORE UPDATE ON components
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

**Acceptance:**
- Components table exists
- Linked to rooms with cascade delete
- Type enum covers common component types

---

### Task 4: Create RenovationProject Entity (DATA-06)

**What:** Enhanced project type for renovations with workflow status.

**SQL Migration:** `supabase/migrations/011_renovation_project.sql`

```sql
-- Renovation project status enum
CREATE TYPE renovation_status AS ENUM (
  'planned', 'active', 'blocked', 'finished', 'approved'
);

-- Renovation projects table (extends concept of projects)
CREATE TABLE IF NOT EXISTS renovation_projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  unit_id UUID NOT NULL REFERENCES units(id),
  template_id UUID, -- Links to template (Phase 8)
  name TEXT NOT NULL,
  description TEXT,
  status renovation_status DEFAULT 'planned',

  -- Scheduling
  planned_start_date DATE,
  planned_end_date DATE,
  actual_start_date DATE,
  actual_end_date DATE,

  -- Budget
  estimated_cost DECIMAL(12,2),
  actual_cost DECIMAL(12,2),

  -- Metadata
  created_by UUID REFERENCES users(id),
  approved_by UUID REFERENCES users(id),
  approved_at TIMESTAMPTZ,

  -- Visibility (preserve v1 pattern)
  visible_to_imeri BOOLEAN DEFAULT false,

  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_renovation_projects_unit_id ON renovation_projects(unit_id);
CREATE INDEX IF NOT EXISTS idx_renovation_projects_status ON renovation_projects(status);
CREATE INDEX IF NOT EXISTS idx_renovation_projects_template_id ON renovation_projects(template_id);

CREATE TRIGGER renovation_projects_updated_at
  BEFORE UPDATE ON renovation_projects
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

**Acceptance:**
- RenovationProject table with full status workflow
- Links to unit and future template
- Budget tracking fields
- Approval workflow fields

---

### Task 5: Enhance Task with Dependencies (DATA-07)

**What:** Add task dependencies and checklist functionality.

**SQL Migration:** `supabase/migrations/012_task_enhancements.sql`

```sql
-- Add task enhancements
ALTER TABLE tasks
ADD COLUMN IF NOT EXISTS parent_task_id UUID REFERENCES tasks(id),
ADD COLUMN IF NOT EXISTS checklist_items JSONB DEFAULT '[]',
ADD COLUMN IF NOT EXISTS estimated_hours DECIMAL(6,2),
ADD COLUMN IF NOT EXISTS actual_hours DECIMAL(6,2),
ADD COLUMN IF NOT EXISTS room_id UUID REFERENCES rooms(id),
ADD COLUMN IF NOT EXISTS renovation_project_id UUID REFERENCES renovation_projects(id);

-- Task dependencies (many-to-many)
CREATE TABLE IF NOT EXISTS task_dependencies (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  depends_on_task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(task_id, depends_on_task_id)
);

CREATE INDEX IF NOT EXISTS idx_task_dependencies_task_id ON task_dependencies(task_id);
CREATE INDEX IF NOT EXISTS idx_task_dependencies_depends_on ON task_dependencies(depends_on_task_id);
CREATE INDEX IF NOT EXISTS idx_tasks_room_id ON tasks(room_id);
CREATE INDEX IF NOT EXISTS idx_tasks_renovation_project_id ON tasks(renovation_project_id);

-- Checklist item structure (for documentation):
-- { "id": "uuid", "text": "string", "completed": boolean, "completed_at": "timestamp" }
```

**Acceptance:**
- Tasks can have parent task (subtasks)
- Checklist items stored as JSONB array
- Task dependencies via junction table
- Tasks linkable to rooms and renovation projects

---

### Task 6: Create WorkOrder Entity (DATA-08)

**What:** WorkOrder/Ticket for external contractor assignments.

**SQL Migration:** `supabase/migrations/013_work_order.sql`

```sql
-- WorkOrder status enum (full workflow)
CREATE TYPE work_order_status AS ENUM (
  'draft',
  'sent',
  'viewed',
  'accepted',
  'rejected',
  'in_progress',
  'done',
  'inspected',
  'closed'
);

-- WorkOrders table
CREATE TABLE IF NOT EXISTS work_orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Relationships
  renovation_project_id UUID REFERENCES renovation_projects(id),
  task_id UUID REFERENCES tasks(id),
  room_id UUID REFERENCES rooms(id),
  partner_id UUID, -- Will reference partners table

  -- Content
  title TEXT NOT NULL,
  description TEXT,
  scope_of_work TEXT, -- Detailed work description

  -- Status workflow
  status work_order_status DEFAULT 'draft',

  -- Scheduling
  requested_start_date DATE,
  requested_end_date DATE,
  proposed_start_date DATE, -- Contractor's proposal
  proposed_end_date DATE,
  actual_start_date DATE,
  actual_end_date DATE,

  -- Magic link for external access
  access_token UUID DEFAULT gen_random_uuid(),
  token_expires_at TIMESTAMPTZ,
  acceptance_deadline TIMESTAMPTZ,

  -- Tracking
  viewed_at TIMESTAMPTZ,
  accepted_at TIMESTAMPTZ,
  rejected_at TIMESTAMPTZ,
  rejection_reason TEXT,

  -- Cost
  estimated_cost DECIMAL(12,2),
  proposed_cost DECIMAL(12,2), -- Contractor's price
  final_cost DECIMAL(12,2),

  -- Notes
  internal_notes TEXT, -- KEWA only
  contractor_notes TEXT, -- From contractor

  -- Metadata
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_work_orders_project_id ON work_orders(renovation_project_id);
CREATE INDEX IF NOT EXISTS idx_work_orders_partner_id ON work_orders(partner_id);
CREATE INDEX IF NOT EXISTS idx_work_orders_status ON work_orders(status);
CREATE INDEX IF NOT EXISTS idx_work_orders_access_token ON work_orders(access_token);

CREATE TRIGGER work_orders_updated_at
  BEFORE UPDATE ON work_orders
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

**Acceptance:**
- WorkOrder table with full status workflow
- Magic link token for external access
- Deadline and proposal tracking
- Internal vs contractor notes separation

---

### Task 7: Create Partner Entity (DATA-09)

**What:** Partners (Handwerker, Lieferanten) with trade categories.

**SQL Migration:** `supabase/migrations/014_partner.sql`

```sql
-- Partner type enum
CREATE TYPE partner_type AS ENUM ('contractor', 'supplier');

-- Trade category enum
CREATE TYPE trade_category AS ENUM (
  'general', 'plumbing', 'electrical', 'hvac', 'painting',
  'flooring', 'carpentry', 'roofing', 'masonry', 'glazing',
  'landscaping', 'cleaning', 'demolition', 'other'
);

-- Partners table
CREATE TABLE IF NOT EXISTS partners (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Basic info
  partner_type partner_type NOT NULL,
  company_name TEXT NOT NULL,
  contact_name TEXT,

  -- Contact details
  email TEXT,
  phone TEXT,
  address TEXT,

  -- Trade info (for contractors)
  trade_categories trade_category[] DEFAULT '{}',

  -- Status
  is_active BOOLEAN DEFAULT true,

  -- Notes
  notes TEXT,

  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_partners_type ON partners(partner_type);
CREATE INDEX IF NOT EXISTS idx_partners_active ON partners(is_active);

-- Add foreign key to work_orders
ALTER TABLE work_orders
ADD CONSTRAINT fk_work_orders_partner
FOREIGN KEY (partner_id) REFERENCES partners(id);

CREATE TRIGGER partners_updated_at
  BEFORE UPDATE ON partners
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();
```

**Acceptance:**
- Partners table with type (contractor/supplier)
- Trade categories as array for multi-trade contractors
- Contact details stored
- Linked to WorkOrders

---

### Task 8: Create Media Entity with Metadata (DATA-14)

**What:** Unified Media entity with before/after metadata.

**SQL Migration:** `supabase/migrations/015_media.sql`

```sql
-- Media type enum
CREATE TYPE media_type AS ENUM ('photo', 'video', 'document', 'audio');
CREATE TYPE media_context AS ENUM ('before', 'after', 'during', 'documentation', 'other');

-- Unified media table
CREATE TABLE IF NOT EXISTS media (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Polymorphic relationship
  entity_type TEXT NOT NULL, -- 'task', 'work_order', 'room', 'project', etc.
  entity_id UUID NOT NULL,

  -- Media info
  media_type media_type NOT NULL,
  context media_context DEFAULT 'other',

  -- Storage
  storage_path TEXT NOT NULL,
  file_name TEXT NOT NULL,
  file_size INTEGER,
  mime_type TEXT,

  -- Metadata
  description TEXT,
  taken_at TIMESTAMPTZ, -- When photo/video was captured

  -- For audio
  duration_seconds INTEGER,
  transcription TEXT,
  transcription_status TEXT,

  -- Upload info
  uploaded_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_media_entity ON media(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_media_type ON media(media_type);
CREATE INDEX IF NOT EXISTS idx_media_context ON media(context);

-- View to unify old task_photos and task_audio with new media
CREATE OR REPLACE VIEW all_media AS
SELECT
  id,
  'task' as entity_type,
  task_id as entity_id,
  'photo' as media_type,
  photo_type as context,
  storage_path,
  file_name,
  file_size,
  NULL as mime_type,
  NULL as description,
  NULL as taken_at,
  NULL as duration_seconds,
  NULL as transcription,
  NULL as transcription_status,
  uploaded_by,
  created_at
FROM task_photos
UNION ALL
SELECT
  id,
  'task' as entity_type,
  task_id as entity_id,
  'audio' as media_type,
  audio_type as context,
  storage_path,
  file_name,
  file_size,
  NULL as mime_type,
  NULL as description,
  NULL as taken_at,
  duration_seconds,
  transcription,
  transcription_status,
  uploaded_by,
  created_at
FROM task_audio
UNION ALL
SELECT
  id,
  entity_type,
  entity_id,
  media_type::TEXT,
  context::TEXT,
  storage_path,
  file_name,
  file_size,
  mime_type,
  description,
  taken_at,
  duration_seconds,
  transcription,
  transcription_status,
  uploaded_by,
  created_at
FROM media;
```

**Acceptance:**
- Unified media table for all attachment types
- Before/after context tracking
- Polymorphic relationship to any entity
- View combines old tables with new

---

### Task 9: Create AuditLog Entity (DATA-15)

**What:** Comprehensive audit logging for all changes.

**SQL Migration:** `supabase/migrations/016_audit_log.sql`

```sql
-- Audit action enum
CREATE TYPE audit_action AS ENUM ('create', 'update', 'delete', 'archive', 'restore');

-- Audit log table
CREATE TABLE IF NOT EXISTS audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- What changed
  table_name TEXT NOT NULL,
  record_id UUID NOT NULL,
  action audit_action NOT NULL,

  -- Who changed it
  user_id UUID REFERENCES users(id),
  user_role TEXT,

  -- Change details
  old_values JSONB,
  new_values JSONB,
  changed_fields TEXT[],

  -- Context
  ip_address TEXT,
  user_agent TEXT,

  -- Timestamp
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_audit_logs_table_record ON audit_logs(table_name, record_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_user ON audit_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_audit_logs_created ON audit_logs(created_at);
CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action);

-- Function to create audit log entry
CREATE OR REPLACE FUNCTION create_audit_log(
  p_table_name TEXT,
  p_record_id UUID,
  p_action audit_action,
  p_user_id UUID,
  p_user_role TEXT,
  p_old_values JSONB DEFAULT NULL,
  p_new_values JSONB DEFAULT NULL
) RETURNS UUID AS $$
DECLARE
  v_changed_fields TEXT[];
  v_log_id UUID;
BEGIN
  -- Calculate changed fields
  IF p_old_values IS NOT NULL AND p_new_values IS NOT NULL THEN
    SELECT array_agg(key)
    INTO v_changed_fields
    FROM (
      SELECT key FROM jsonb_object_keys(p_new_values) AS key
      WHERE p_old_values->key IS DISTINCT FROM p_new_values->key
    ) changed;
  END IF;

  INSERT INTO audit_logs (
    table_name, record_id, action, user_id, user_role,
    old_values, new_values, changed_fields
  ) VALUES (
    p_table_name, p_record_id, p_action, p_user_id, p_user_role,
    p_old_values, p_new_values, v_changed_fields
  )
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$$ LANGUAGE plpgsql;
```

**Acceptance:**
- AuditLog table captures all changes
- Function to create entries with diff calculation
- Indexes for efficient querying by table/record/user/time
- Stores old and new values as JSONB

---

### Task 10: Update TypeScript Types

**What:** Update type definitions to match new schema.

**Files:** `src/types/database.ts`, `src/types/index.ts`

**Acceptance:**
- All new entities have TypeScript interfaces
- Enums match database enums
- Existing types extended (not broken)

---

## Verification

```bash
# Run all migrations
cd supabase && supabase db push

# Verify tables exist
supabase db query "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'"

# Verify enums
supabase db query "SELECT typname FROM pg_type WHERE typtype = 'e'"

# TypeScript compilation
npm run type-check
```

## Success Criteria

- [ ] All 9 new migrations applied successfully
- [ ] 15 entities exist in database
- [ ] TypeScript types match database schema
- [ ] Existing v1 data preserved
- [ ] Foreign key relationships intact
- [ ] Indexes created for performance

## Output

**New Files:**
- `supabase/migrations/008_property_building.sql`
- `supabase/migrations/009_unit_room.sql`
- `supabase/migrations/010_component.sql`
- `supabase/migrations/011_renovation_project.sql`
- `supabase/migrations/012_task_enhancements.sql`
- `supabase/migrations/013_work_order.sql`
- `supabase/migrations/014_partner.sql`
- `supabase/migrations/015_media.sql`
- `supabase/migrations/016_audit_log.sql`

**Modified Files:**
- `src/types/database.ts`
- `src/types/index.ts`
