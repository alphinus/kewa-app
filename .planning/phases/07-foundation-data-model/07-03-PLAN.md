# Plan: Cost & Finance Data Model

```yaml
---
phase: 07
plan: 03
name: cost-finance-model
wave: 1
autonomous: true
scope: medium
requirements:
  - DATA-10
  - DATA-11
  - DATA-12
  - DATA-13
must_haves:
  - Offer table with status workflow (draft, sent, accepted, rejected, expired)
  - Invoice table with PDF storage path and payment status
  - Expense table for manual cash/petty cash entries
  - Payment table with method enum (cash, transfer, card)
  - All cost entities linked to partners and work_orders
---
```

## Objective

Create financial data model for cost tracking: Offers → Invoices → Payments plus manual Expenses. Enables full cost workflow for Phase 10.

## Context

**Cost Workflow:**
```
Partner submits Offer → KEWA accepts → WorkOrder created →
Work done → Invoice received → Payment made → Closed
```

**Additional Costs:**
- Expenses: Cash purchases, petty cash, travel costs
- Not tied to formal Offer/Invoice workflow

**Requirements:**
- Track variance: Offer amount vs Invoice amount
- Multiple invoices per WorkOrder possible
- Multiple payments per Invoice possible
- All costs traceable to: Project, Unit, Room, Partner, Trade

## Tasks

### Task 1: Create Offer Entity (DATA-10)

**What:** Offers (Offerten) from contractors/suppliers.

**SQL Migration:** `supabase/migrations/017_offer.sql`

```sql
-- Offer status enum
CREATE TYPE offer_status AS ENUM (
  'draft',
  'sent',
  'received',
  'under_review',
  'accepted',
  'rejected',
  'expired',
  'superseded'
);

-- Offers table
CREATE TABLE IF NOT EXISTS offers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Relationships
  partner_id UUID NOT NULL REFERENCES partners(id),
  work_order_id UUID REFERENCES work_orders(id),
  renovation_project_id UUID REFERENCES renovation_projects(id),

  -- Offer details
  offer_number TEXT, -- External reference number
  title TEXT NOT NULL,
  description TEXT,

  -- Amounts
  amount DECIMAL(12,2) NOT NULL,
  currency TEXT DEFAULT 'CHF',
  tax_rate DECIMAL(5,2) DEFAULT 7.7, -- Swiss VAT
  tax_amount DECIMAL(12,2),
  total_amount DECIMAL(12,2),

  -- Line items (optional detailed breakdown)
  line_items JSONB DEFAULT '[]',

  -- Status workflow
  status offer_status DEFAULT 'received',

  -- Dates
  offer_date DATE,
  valid_until DATE,
  received_at TIMESTAMPTZ,
  reviewed_at TIMESTAMPTZ,
  accepted_at TIMESTAMPTZ,
  rejected_at TIMESTAMPTZ,

  -- Decision
  accepted_by UUID REFERENCES users(id),
  rejected_by UUID REFERENCES users(id),
  rejection_reason TEXT,

  -- Documents
  document_storage_path TEXT, -- PDF of offer

  -- Notes
  internal_notes TEXT,

  -- Metadata
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_offers_partner ON offers(partner_id);
CREATE INDEX IF NOT EXISTS idx_offers_work_order ON offers(work_order_id);
CREATE INDEX IF NOT EXISTS idx_offers_project ON offers(renovation_project_id);
CREATE INDEX IF NOT EXISTS idx_offers_status ON offers(status);

CREATE TRIGGER offers_updated_at
  BEFORE UPDATE ON offers
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Auto-calculate tax and total
CREATE OR REPLACE FUNCTION calculate_offer_totals()
RETURNS TRIGGER AS $$
BEGIN
  NEW.tax_amount = NEW.amount * (NEW.tax_rate / 100);
  NEW.total_amount = NEW.amount + NEW.tax_amount;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER offers_calculate_totals
  BEFORE INSERT OR UPDATE OF amount, tax_rate ON offers
  FOR EACH ROW EXECUTE FUNCTION calculate_offer_totals();
```

**Acceptance:**
- Offers table created with full workflow
- Tax calculation automatic
- Line items as JSONB for flexibility
- Document storage path for PDF

---

### Task 2: Create Invoice Entity (DATA-11)

**What:** Invoices (Rechnungen) from partners.

**SQL Migration:** `supabase/migrations/018_invoice.sql`

```sql
-- Invoice status enum
CREATE TYPE invoice_status AS ENUM (
  'received',
  'under_review',
  'approved',
  'disputed',
  'partially_paid',
  'paid',
  'cancelled'
);

-- Invoices table
CREATE TABLE IF NOT EXISTS invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Relationships
  partner_id UUID NOT NULL REFERENCES partners(id),
  offer_id UUID REFERENCES offers(id), -- Links to accepted offer
  work_order_id UUID REFERENCES work_orders(id),
  renovation_project_id UUID REFERENCES renovation_projects(id),

  -- Invoice details
  invoice_number TEXT NOT NULL, -- External invoice number
  title TEXT,
  description TEXT,

  -- Amounts
  amount DECIMAL(12,2) NOT NULL,
  currency TEXT DEFAULT 'CHF',
  tax_rate DECIMAL(5,2) DEFAULT 7.7,
  tax_amount DECIMAL(12,2),
  total_amount DECIMAL(12,2),

  -- Payment tracking
  amount_paid DECIMAL(12,2) DEFAULT 0,
  amount_outstanding DECIMAL(12,2),

  -- Line items
  line_items JSONB DEFAULT '[]',

  -- Status
  status invoice_status DEFAULT 'received',

  -- Dates
  invoice_date DATE NOT NULL,
  due_date DATE,
  received_at TIMESTAMPTZ DEFAULT NOW(),
  approved_at TIMESTAMPTZ,
  paid_at TIMESTAMPTZ,

  -- Approval
  approved_by UUID REFERENCES users(id),

  -- Variance tracking (vs offer)
  offer_amount DECIMAL(12,2), -- Copied from linked offer
  variance_amount DECIMAL(12,2), -- invoice - offer
  variance_reason TEXT,

  -- Documents
  document_storage_path TEXT NOT NULL, -- PDF of invoice (required)

  -- Notes
  internal_notes TEXT,

  -- Metadata
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_invoices_partner ON invoices(partner_id);
CREATE INDEX IF NOT EXISTS idx_invoices_offer ON invoices(offer_id);
CREATE INDEX IF NOT EXISTS idx_invoices_work_order ON invoices(work_order_id);
CREATE INDEX IF NOT EXISTS idx_invoices_project ON invoices(renovation_project_id);
CREATE INDEX IF NOT EXISTS idx_invoices_status ON invoices(status);
CREATE INDEX IF NOT EXISTS idx_invoices_due_date ON invoices(due_date);

CREATE TRIGGER invoices_updated_at
  BEFORE UPDATE ON invoices
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Auto-calculate totals and outstanding
CREATE OR REPLACE FUNCTION calculate_invoice_totals()
RETURNS TRIGGER AS $$
BEGIN
  NEW.tax_amount = NEW.amount * (NEW.tax_rate / 100);
  NEW.total_amount = NEW.amount + NEW.tax_amount;
  NEW.amount_outstanding = NEW.total_amount - COALESCE(NEW.amount_paid, 0);

  -- Calculate variance if linked to offer
  IF NEW.offer_id IS NOT NULL AND NEW.offer_amount IS NULL THEN
    SELECT total_amount INTO NEW.offer_amount FROM offers WHERE id = NEW.offer_id;
  END IF;

  IF NEW.offer_amount IS NOT NULL THEN
    NEW.variance_amount = NEW.total_amount - NEW.offer_amount;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER invoices_calculate_totals
  BEFORE INSERT OR UPDATE OF amount, tax_rate, amount_paid, offer_id ON invoices
  FOR EACH ROW EXECUTE FUNCTION calculate_invoice_totals();
```

**Acceptance:**
- Invoices table with full payment tracking
- Automatic variance calculation vs offer
- Outstanding amount auto-updated
- PDF storage required

---

### Task 3: Create Expense Entity (DATA-12)

**What:** Manual expense entries (cash, petty cash, travel).

**SQL Migration:** `supabase/migrations/019_expense.sql`

```sql
-- Expense category enum
CREATE TYPE expense_category AS ENUM (
  'material',
  'labor',
  'equipment_rental',
  'travel',
  'permits',
  'disposal',
  'utilities',
  'other'
);

-- Expense payment method
CREATE TYPE expense_payment_method AS ENUM (
  'cash',
  'petty_cash',
  'company_card',
  'personal_reimbursement'
);

-- Expenses table
CREATE TABLE IF NOT EXISTS expenses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Relationships (at least one required)
  renovation_project_id UUID REFERENCES renovation_projects(id),
  work_order_id UUID REFERENCES work_orders(id),
  unit_id UUID REFERENCES units(id),
  room_id UUID REFERENCES rooms(id),

  -- Expense details
  title TEXT NOT NULL,
  description TEXT,
  category expense_category NOT NULL,

  -- Amounts
  amount DECIMAL(12,2) NOT NULL,
  currency TEXT DEFAULT 'CHF',
  tax_included BOOLEAN DEFAULT true,

  -- Payment
  payment_method expense_payment_method NOT NULL,
  paid_by UUID REFERENCES users(id),
  paid_at TIMESTAMPTZ DEFAULT NOW(),

  -- Vendor (not necessarily a registered partner)
  vendor_name TEXT,
  partner_id UUID REFERENCES partners(id), -- Optional link to partner

  -- Receipt
  receipt_storage_path TEXT,
  receipt_number TEXT,

  -- Trade category (for reporting)
  trade_category trade_category,

  -- Notes
  notes TEXT,

  -- Metadata
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_expenses_project ON expenses(renovation_project_id);
CREATE INDEX IF NOT EXISTS idx_expenses_work_order ON expenses(work_order_id);
CREATE INDEX IF NOT EXISTS idx_expenses_unit ON expenses(unit_id);
CREATE INDEX IF NOT EXISTS idx_expenses_category ON expenses(category);
CREATE INDEX IF NOT EXISTS idx_expenses_paid_at ON expenses(paid_at);

CREATE TRIGGER expenses_updated_at
  BEFORE UPDATE ON expenses
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Validation: at least one relationship required
CREATE OR REPLACE FUNCTION validate_expense_relationship()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.renovation_project_id IS NULL
     AND NEW.work_order_id IS NULL
     AND NEW.unit_id IS NULL
     AND NEW.room_id IS NULL THEN
    RAISE EXCEPTION 'Expense must be linked to at least one entity (project, work_order, unit, or room)';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER expenses_validate_relationship
  BEFORE INSERT OR UPDATE ON expenses
  FOR EACH ROW EXECUTE FUNCTION validate_expense_relationship();
```

**Acceptance:**
- Expenses table for cash/petty cash entries
- Categories for reporting
- Receipt storage optional but supported
- Must link to at least one entity

---

### Task 4: Create Payment Entity (DATA-13)

**What:** Payments made against invoices.

**SQL Migration:** `supabase/migrations/020_payment.sql`

```sql
-- Payment method enum
CREATE TYPE payment_method AS ENUM (
  'bank_transfer',
  'cash',
  'check',
  'credit_card',
  'debit_card',
  'other'
);

-- Payment status enum
CREATE TYPE payment_status AS ENUM (
  'pending',
  'processing',
  'completed',
  'failed',
  'cancelled',
  'refunded'
);

-- Payments table
CREATE TABLE IF NOT EXISTS payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Relationship
  invoice_id UUID NOT NULL REFERENCES invoices(id),

  -- Payment details
  amount DECIMAL(12,2) NOT NULL,
  currency TEXT DEFAULT 'CHF',
  payment_method payment_method NOT NULL,
  status payment_status DEFAULT 'completed',

  -- Bank details
  bank_reference TEXT, -- Transaction reference
  bank_account TEXT, -- Paid from account (partial, last 4 digits)

  -- Dates
  payment_date DATE NOT NULL,
  value_date DATE, -- When funds cleared

  -- Notes
  notes TEXT,

  -- Metadata
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_payments_invoice ON payments(invoice_id);
CREATE INDEX IF NOT EXISTS idx_payments_date ON payments(payment_date);
CREATE INDEX IF NOT EXISTS idx_payments_status ON payments(status);

CREATE TRIGGER payments_updated_at
  BEFORE UPDATE ON payments
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- Auto-update invoice amount_paid
CREATE OR REPLACE FUNCTION update_invoice_paid_amount()
RETURNS TRIGGER AS $$
BEGIN
  -- Update the related invoice's paid amount
  UPDATE invoices
  SET amount_paid = (
    SELECT COALESCE(SUM(amount), 0)
    FROM payments
    WHERE invoice_id = COALESCE(NEW.invoice_id, OLD.invoice_id)
      AND status = 'completed'
  )
  WHERE id = COALESCE(NEW.invoice_id, OLD.invoice_id);

  -- Update invoice status if fully paid
  UPDATE invoices
  SET status = CASE
    WHEN amount_outstanding <= 0 THEN 'paid'
    WHEN amount_paid > 0 THEN 'partially_paid'
    ELSE status
  END,
  paid_at = CASE
    WHEN amount_outstanding <= 0 THEN NOW()
    ELSE paid_at
  END
  WHERE id = COALESCE(NEW.invoice_id, OLD.invoice_id);

  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER payments_update_invoice
  AFTER INSERT OR UPDATE OR DELETE ON payments
  FOR EACH ROW EXECUTE FUNCTION update_invoice_paid_amount();
```

**Acceptance:**
- Payments table with method enum
- Auto-updates invoice paid amount
- Auto-updates invoice status when fully paid
- Bank reference tracking

---

### Task 5: Create Cost Aggregation Views

**What:** Views for cost reporting by project, unit, room, partner, trade.

**SQL Migration:** `supabase/migrations/021_cost_views.sql`

```sql
-- Cost summary by project
CREATE OR REPLACE VIEW project_costs AS
SELECT
  rp.id as project_id,
  rp.name as project_name,
  rp.unit_id,
  rp.estimated_cost,

  -- Offers
  COALESCE(SUM(CASE WHEN o.status = 'accepted' THEN o.total_amount END), 0) as total_accepted_offers,

  -- Invoices
  COALESCE(SUM(i.total_amount), 0) as total_invoiced,
  COALESCE(SUM(i.amount_paid), 0) as total_paid,
  COALESCE(SUM(i.amount_outstanding), 0) as total_outstanding,

  -- Expenses
  COALESCE(SUM(e.amount), 0) as total_expenses,

  -- Totals
  COALESCE(SUM(i.total_amount), 0) + COALESCE(SUM(e.amount), 0) as total_cost,

  -- Variance
  COALESCE(SUM(i.total_amount), 0) + COALESCE(SUM(e.amount), 0) - COALESCE(rp.estimated_cost, 0) as variance_from_budget

FROM renovation_projects rp
LEFT JOIN offers o ON o.renovation_project_id = rp.id
LEFT JOIN invoices i ON i.renovation_project_id = rp.id
LEFT JOIN expenses e ON e.renovation_project_id = rp.id
GROUP BY rp.id, rp.name, rp.unit_id, rp.estimated_cost;

-- Cost summary by unit
CREATE OR REPLACE VIEW unit_costs AS
SELECT
  u.id as unit_id,
  u.name as unit_name,
  u.rent_amount,

  -- From projects
  COALESCE(SUM(pc.total_cost), 0) as total_project_costs,

  -- Direct expenses
  COALESCE(SUM(e.amount), 0) as direct_expenses,

  -- Total
  COALESCE(SUM(pc.total_cost), 0) + COALESCE(SUM(e.amount), 0) as total_investment,

  -- ROI indicator (years to recover via rent)
  CASE
    WHEN u.rent_amount > 0 THEN
      (COALESCE(SUM(pc.total_cost), 0) + COALESCE(SUM(e.amount), 0)) / (u.rent_amount * 12)
    ELSE NULL
  END as years_to_recover

FROM units u
LEFT JOIN project_costs pc ON pc.unit_id = u.id
LEFT JOIN expenses e ON e.unit_id = u.id AND e.renovation_project_id IS NULL
GROUP BY u.id, u.name, u.rent_amount;

-- Cost summary by partner
CREATE OR REPLACE VIEW partner_costs AS
SELECT
  p.id as partner_id,
  p.company_name,
  p.partner_type,

  COUNT(DISTINCT o.id) as total_offers,
  COUNT(DISTINCT CASE WHEN o.status = 'accepted' THEN o.id END) as accepted_offers,
  COALESCE(SUM(CASE WHEN o.status = 'accepted' THEN o.total_amount END), 0) as total_offer_value,

  COUNT(DISTINCT i.id) as total_invoices,
  COALESCE(SUM(i.total_amount), 0) as total_invoiced,
  COALESCE(SUM(i.amount_paid), 0) as total_paid,
  COALESCE(SUM(i.amount_outstanding), 0) as outstanding,

  -- Average variance (invoice vs offer)
  AVG(i.variance_amount) as avg_variance

FROM partners p
LEFT JOIN offers o ON o.partner_id = p.id
LEFT JOIN invoices i ON i.partner_id = p.id
GROUP BY p.id, p.company_name, p.partner_type;

-- Cost by trade category
CREATE OR REPLACE VIEW trade_costs AS
SELECT
  e.trade_category,
  COUNT(*) as expense_count,
  SUM(e.amount) as total_expenses
FROM expenses e
WHERE e.trade_category IS NOT NULL
GROUP BY e.trade_category

UNION ALL

SELECT
  unnest(p.trade_categories) as trade_category,
  COUNT(DISTINCT i.id) as invoice_count,
  SUM(i.total_amount) as total_invoiced
FROM partners p
JOIN invoices i ON i.partner_id = p.id
GROUP BY unnest(p.trade_categories);
```

**Acceptance:**
- project_costs view aggregates all costs per project
- unit_costs view shows investment per unit with ROI indicator
- partner_costs view shows partner payment history
- trade_costs view for trade-based reporting

---

### Task 6: Update TypeScript Types for Cost Entities

**What:** Add TypeScript interfaces for all cost entities.

**Files:** `src/types/database.ts`

**Acceptance:**
- Offer, Invoice, Expense, Payment interfaces
- Enum types match database
- View result types defined

---

## Verification

```bash
# Run migrations
cd supabase && supabase db push

# Verify tables
supabase db query "SELECT table_name FROM information_schema.tables WHERE table_name IN ('offers', 'invoices', 'expenses', 'payments')"

# Verify views
supabase db query "SELECT table_name FROM information_schema.views WHERE table_name LIKE '%costs'"

# Test triggers
supabase db query "INSERT INTO invoices (...) VALUES (...) RETURNING total_amount, tax_amount"

# TypeScript
npm run type-check
```

## Success Criteria

- [ ] Offers table with automatic tax calculation
- [ ] Invoices table with payment tracking
- [ ] Expenses table with category validation
- [ ] Payments table with invoice auto-update
- [ ] Cost aggregation views functional
- [ ] TypeScript types complete

## Output

**New Files:**
- `supabase/migrations/017_offer.sql`
- `supabase/migrations/018_invoice.sql`
- `supabase/migrations/019_expense.sql`
- `supabase/migrations/020_payment.sql`
- `supabase/migrations/021_cost_views.sql`

**Modified Files:**
- `src/types/database.ts`
