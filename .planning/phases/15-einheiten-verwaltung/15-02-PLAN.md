---
phase: 15-einheiten-verwaltung
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/rooms/route.ts
  - src/app/api/rooms/[id]/route.ts
  - src/types/database.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/rooms?unit_id=X returns rooms for that unit"
    - "POST /api/rooms creates room with type, name, and optional area"
    - "PATCH /api/rooms/:id updates room fields"
    - "DELETE /api/rooms/:id removes room (kewa role only)"
  artifacts:
    - path: "src/app/api/rooms/route.ts"
      provides: "Room collection CRUD (GET list, POST create)"
      exports: ["GET", "POST"]
    - path: "src/app/api/rooms/[id]/route.ts"
      provides: "Room single CRUD (GET, PATCH, DELETE)"
      exports: ["GET", "PATCH", "DELETE"]
  key_links:
    - from: "src/app/api/rooms/route.ts"
      to: "supabase.from('rooms')"
      via: "unit_id filter in query"
      pattern: "eq\\('unit_id'"
---

<objective>
Create Room API with full CRUD operations for managing rooms within units.

Purpose: Enable room management for condition tracking (Digital Twin). Rooms can be added to units with type, name, and optional area. Room condition is managed by existing Digital Twin automation.

Output: Complete Room API supporting unit-scoped listing, room creation, update, and admin-only delete.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-einheiten-verwaltung/15-CONTEXT.md
@.planning/phases/15-einheiten-verwaltung/15-RESEARCH.md
@src/app/api/partners/route.ts
@src/app/api/partners/[id]/route.ts
@src/types/database.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Room input types to database.ts</name>
  <files>src/types/database.ts</files>
  <action>
Add CreateRoomInput and UpdateRoomInput interfaces:

```typescript
/**
 * Input for creating a new room
 */
export interface CreateRoomInput {
  unit_id: string
  name: string
  room_type: RoomType
  area_sqm?: number | null
  notes?: string | null
}

/**
 * Input for updating a room
 */
export interface UpdateRoomInput {
  name?: string
  room_type?: RoomType
  area_sqm?: number | null
  notes?: string | null
  // Note: condition is NOT updatable via API - managed by Digital Twin automation
}
```

These types will be used by the Room API routes.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>CreateRoomInput and UpdateRoomInput types exist in database.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create rooms collection route with GET and POST</name>
  <files>src/app/api/rooms/route.ts</files>
  <action>
Create new file following partners/route.ts pattern:

GET /api/rooms:
- Auth check: require x-user-id and x-user-role headers
- Role check: 'kewa' and 'imeri' can view rooms
- Parse unit_id from query params (required for listing)
- If unit_id missing, return 400 (rooms must be fetched per-unit)
- Query rooms where unit_id matches
- Order by room_type, then name
- Return { rooms: Room[] }

POST /api/rooms:
- Auth check: require x-user-id and x-user-role headers
- Role check: only 'kewa' and 'imeri' can create rooms
- Validate required fields: unit_id, name, room_type
- Validate room_type is valid enum (RoomType from types/index.ts)
- Insert with provided fields, defaults: condition='old', condition_updated_at=null
- Return created room with 201 status

Valid room_type values from existing enum:
'living_room', 'bedroom', 'kitchen', 'bathroom', 'toilet', 'hallway', 'balcony', 'storage', 'laundry', 'garage', 'office', 'other'

Reference existing patterns for:
- Error handling (try/catch with console.error)
- Response format ({ rooms } or { room } with status)
- Auth header extraction
  </action>
  <verify>
Manual test:
- GET /api/rooms returns 400 (unit_id required)
- GET /api/rooms?unit_id=<uuid> returns rooms for unit
- POST /api/rooms with valid body returns 201
- POST /api/rooms without unit_id returns 400
  </verify>
  <done>Rooms collection route handles GET (with unit_id filter) and POST</done>
</task>

<task type="auto">
  <name>Task 3: Create rooms single route with GET, PATCH, DELETE</name>
  <files>src/app/api/rooms/[id]/route.ts</files>
  <action>
Create new file following partners/[id]/route.ts pattern:

GET /api/rooms/[id]:
- Auth check: require x-user-id and x-user-role headers
- Role check: 'kewa' and 'imeri' can view rooms
- Fetch single room by ID
- Return 404 if not found (PGRST116 error code)
- Return { room: Room }

PATCH /api/rooms/[id]:
- Auth check: require x-user-id and x-user-role headers
- Role check: only 'kewa' and 'imeri' can update
- Accept partial updates (name, room_type, area_sqm, notes)
- Do NOT allow updating condition - that's managed by Digital Twin
- Validate at least one field provided
- Return updated room

DELETE /api/rooms/[id]:
- Auth check: require x-user-id and x-user-role headers
- Role check: ONLY 'kewa' can delete (admin-only)
- Log warning if room has condition_history entries
- Delete room from database
- Return 204 on success

Use Next.js 15 params pattern:
```typescript
export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  // ...
}
```
  </action>
  <verify>
Manual test:
- GET /api/rooms/:id returns single room
- PATCH /api/rooms/:id with partial body returns updated room
- DELETE /api/rooms/:id as kewa returns 204
- DELETE /api/rooms/:id as imeri returns 403
  </verify>
  <done>Rooms single route handles GET, PATCH, DELETE with proper authorization</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. GET /api/rooms?unit_id=X returns rooms for that unit
3. POST /api/rooms creates room with default condition='old'
4. PATCH /api/rooms/:id updates room fields (not condition)
5. DELETE /api/rooms/:id works for kewa role only
</verification>

<success_criteria>
- Rooms can be listed per-unit with GET /api/rooms?unit_id=X
- Rooms can be created with name, type, and optional area
- Rooms can be updated (excluding condition which is automated)
- Admin can delete rooms with appropriate warnings
- All operations respect role-based access control
</success_criteria>

<output>
After completion, create `.planning/phases/15-einheiten-verwaltung/15-02-SUMMARY.md`
</output>
