---
phase: 32-database-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/supabase/cached-queries.ts
  - src/lib/dashboard/dashboard-queries.ts
  - src/lib/dashboard/heatmap-queries.ts
autonomous: true

must_haves:
  truths:
    - "Heatmap page loads without N+1 queries"
    - "Dashboard summary uses single consolidated query"
    - "React cache() wraps database query functions"
  artifacts:
    - path: "src/lib/supabase/cached-queries.ts"
      provides: "React cache() wrappers for server queries"
      exports: ["getCachedBuilding", "getCachedUnitsWithRooms"]
      min_lines: 20
    - path: "src/lib/dashboard/heatmap-queries.ts"
      provides: "Optimized heatmap query without N+1"
      contains: "embedded join"
  key_links:
    - from: "cached-queries.ts"
      to: "heatmap-queries.ts"
      via: "import and reuse"
      pattern: "getCachedUnitsWithRooms"
---

<objective>
Eliminate N+1 query patterns from dashboard and heatmap pages using React cache() and query consolidation.

Purpose: PERF-04 requires N+1 elimination. Current heatmap makes 2 separate queries and merges in JS.
Output: Cached query module and refactored dashboard queries.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key files:
@src/lib/dashboard/heatmap-queries.ts (current N+1 pattern)
@src/lib/dashboard/dashboard-queries.ts (current N+1 pattern)
@src/lib/supabase/server.ts (Supabase client)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cached query module</name>
  <files>src/lib/supabase/cached-queries.ts</files>
  <action>
Create `src/lib/supabase/cached-queries.ts` with React cache() wrappers for common server queries.

```typescript
/**
 * Cached Query Module
 *
 * React cache() wrappers for Supabase queries to prevent N+1 in Server Components.
 * Request-level deduplication - same query called multiple times in one request returns cached result.
 *
 * Phase 32-02: PERF-04 N+1 elimination
 */

import { cache } from 'react'
import 'server-only'
import { createClient } from '@/lib/supabase/server'

/**
 * Get units with embedded rooms for a building (single query, no N+1)
 *
 * Replaces pattern: query units, then query rooms separately
 * Now: single query with embedded relation
 */
export const getCachedUnitsWithRooms = cache(async (buildingId: string) => {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('units')
    .select(`
      id, name, floor, position, unit_type, tenant_name, parking_status,
      rooms (id, name, room_type, condition)
    `)
    .eq('building_id', buildingId)
    .order('floor', { ascending: false })

  if (error) throw error
  return data ?? []
})

/**
 * Get unit condition summaries for a building (single query)
 *
 * Uses the unit_condition_summary view which aggregates room conditions.
 */
export const getCachedUnitConditionSummary = cache(async (buildingId: string) => {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('unit_condition_summary')
    .select('*')
    .eq('building_id', buildingId)

  if (error) throw error
  return data ?? []
})

/**
 * Get active project count for units (single query with IN clause)
 */
export const getCachedActiveProjectCount = cache(async (unitIds: string[]) => {
  if (unitIds.length === 0) return 0

  const supabase = await createClient()

  const { count, error } = await supabase
    .from('renovation_projects')
    .select('id', { count: 'exact', head: true })
    .in('unit_id', unitIds)
    .in('status', ['planned', 'active', 'blocked'])

  if (error) throw error
  return count ?? 0
})
```

The `cache()` function from React provides request-level memoization - if the same function with same arguments is called multiple times during a single request render, only one database query executes.

`'server-only'` import ensures this module cannot be accidentally imported into client components.
  </action>
  <verify>File exists at `src/lib/supabase/cached-queries.ts`</verify>
  <done>Cached query module created with React cache() wrappers</done>
</task>

<task type="auto">
  <name>Task 2: Refactor heatmap queries to eliminate N+1</name>
  <files>src/lib/dashboard/heatmap-queries.ts</files>
  <action>
Refactor `fetchHeatmapData` to use a single query with embedded rooms instead of 2 queries merged in JS.

Current pattern (N+1):
1. Query unit_condition_summary for building
2. Query units with rooms for building
3. Merge in JavaScript

New pattern (single query):
1. Query units with embedded rooms
2. Compute condition summary in TypeScript (or use view in single query)

Update the function:

```typescript
/**
 * Heatmap Query Module
 *
 * Fetch unit data with room conditions for building heatmap display.
 * Uses single query with embedded rooms relation (no N+1).
 *
 * Phase 12-02: Property Dashboard & Heatmap
 * Phase 32-02: PERF-04 N+1 elimination
 */

import { getCachedUnitsWithRooms } from '@/lib/supabase/cached-queries'
import type { RoomCondition } from '@/types'

export interface HeatmapUnit {
  id: string
  name: string
  floor: number | null
  position: string | null
  unit_type: string
  tenant_name: string | null
  total_rooms: number
  new_rooms: number
  partial_rooms: number
  old_rooms: number
  renovation_percentage: number | null
  overall_condition: RoomCondition | null
  rooms: Array<{
    id: string
    name: string
    room_type: string
    condition: RoomCondition
  }>
}

/**
 * Fetch heatmap data for all units in a building
 *
 * Single query fetches units with embedded rooms.
 * Condition aggregation computed in TypeScript to avoid second query.
 */
export async function fetchHeatmapData(
  buildingId: string
): Promise<HeatmapUnit[]> {
  // Single query with embedded rooms (uses React cache)
  const units = await getCachedUnitsWithRooms(buildingId)

  // Filter to apartments and compute condition summary
  return units
    .filter(unit => unit.unit_type === 'apartment')
    .map(unit => {
      const rooms = (unit.rooms || []) as Array<{
        id: string
        name: string
        room_type: string
        condition: RoomCondition
      }>

      const totalRooms = rooms.length
      const newRooms = rooms.filter(r => r.condition === 'new').length
      const partialRooms = rooms.filter(r => r.condition === 'partial').length
      const oldRooms = rooms.filter(r => r.condition === 'old').length

      const renovationPercentage = totalRooms > 0
        ? Math.round((newRooms / totalRooms) * 100 * 10) / 10
        : 0

      let overallCondition: RoomCondition | null = null
      if (totalRooms > 0) {
        if (newRooms === totalRooms) overallCondition = 'new'
        else if (oldRooms === totalRooms) overallCondition = 'old'
        else overallCondition = 'partial'
      }

      return {
        id: unit.id,
        name: unit.name,
        floor: unit.floor,
        position: unit.position,
        unit_type: unit.unit_type,
        tenant_name: unit.tenant_name,
        total_rooms: totalRooms,
        new_rooms: newRooms,
        partial_rooms: partialRooms,
        old_rooms: oldRooms,
        renovation_percentage: renovationPercentage,
        overall_condition: overallCondition,
        rooms
      }
    })
}
```

This eliminates the N+1 by:
1. Using embedded `rooms()` in Supabase query (single round-trip)
2. Computing aggregates in TypeScript instead of separate view query
3. Wrapping with React cache() for request deduplication
  </action>
  <verify>File updated, `grep -n "getCachedUnitsWithRooms" src/lib/dashboard/heatmap-queries.ts` shows import</verify>
  <done>Heatmap uses single query with embedded rooms, N+1 eliminated</done>
</task>

<task type="auto">
  <name>Task 3: Refactor dashboard queries to use cached functions</name>
  <files>src/lib/dashboard/dashboard-queries.ts</files>
  <action>
Update `fetchDashboardSummary` to use cached query functions.

Current pattern:
1. Query unit_condition_summary
2. Query renovation_projects count (separate)

New pattern:
1. Use getCachedUnitConditionSummary (with React cache)
2. Use getCachedActiveProjectCount (with React cache)

```typescript
/**
 * Dashboard Query Module
 *
 * Server-side queries for dashboard data aggregation.
 * Uses React cache() for request-level deduplication.
 *
 * Phase 12-02: Property Dashboard & Heatmap
 * Phase 32-02: PERF-04 N+1 elimination
 */

import {
  getCachedUnitConditionSummary,
  getCachedActiveProjectCount
} from '@/lib/supabase/cached-queries'

export interface DashboardSummary {
  totalUnits: number
  totalRooms: number
  renovatedRooms: number
  averageRenovationPercent: number
  unitsWithProjects: number
  activeProjects: number
}

/**
 * Fetch dashboard summary statistics for a building
 *
 * Uses cached queries for N+1 prevention across components.
 */
export async function fetchDashboardSummary(
  buildingId: string
): Promise<DashboardSummary> {
  // Get unit condition summaries (cached)
  const summaries = await getCachedUnitConditionSummary(buildingId)

  // Get active projects count (cached)
  const unitIds = summaries.map(s => s.unit_id)
  const activeProjects = await getCachedActiveProjectCount(unitIds)

  const totalRooms = summaries.reduce((sum, u) => sum + (u.total_rooms || 0), 0)
  const renovatedRooms = summaries.reduce((sum, u) => sum + (u.new_rooms || 0), 0)
  const avgPercent = summaries.length > 0
    ? summaries.reduce((sum, u) => sum + (u.renovation_percentage || 0), 0) / summaries.length
    : 0

  return {
    totalUnits: summaries.length,
    totalRooms,
    renovatedRooms,
    averageRenovationPercent: Math.round(avgPercent),
    unitsWithProjects: summaries.filter(u => (u.new_rooms || 0) > 0 || (u.partial_rooms || 0) > 0).length,
    activeProjects
  }
}
```

The key benefit: if the same page loads both dashboard summary and heatmap, and both call `getCachedUnitConditionSummary(buildingId)`, only ONE database query executes.
  </action>
  <verify>`grep -n "getCachedUnitConditionSummary" src/lib/dashboard/dashboard-queries.ts` shows import</verify>
  <done>Dashboard queries use cached functions for N+1 prevention</done>
</task>

</tasks>

<verification>
1. `grep -r "from 'react'" src/lib/supabase/cached-queries.ts` shows React cache import
2. `grep -r "server-only" src/lib/supabase/cached-queries.ts` shows server-only marker
3. Heatmap query makes single Supabase call (verify with console.log or network tab)
4. Both dashboard and heatmap can reuse cached queries in same request
</verification>

<success_criteria>
- N+1 query patterns eliminated from dashboard and heatmap (PERF-04)
- React cache() used for request-level query deduplication
- Supabase query log shows single query per table, not per-row
</success_criteria>

<output>
After completion, create `.planning/phases/32-database-optimization/32-02-SUMMARY.md`
</output>
