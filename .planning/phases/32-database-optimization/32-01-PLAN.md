---
phase: 32-database-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/071_performance_indexes.sql
  - .planning/baselines/v3.1-phase32-query-profile.md
autonomous: true

must_haves:
  truths:
    - "pg_stat_statements is enabled and accessible"
    - "Slow queries are identified with execution times"
    - "New indexes exist for identified slow query patterns"
  artifacts:
    - path: "supabase/migrations/071_performance_indexes.sql"
      provides: "Performance-focused composite indexes"
      contains: "CREATE INDEX"
    - path: ".planning/baselines/v3.1-phase32-query-profile.md"
      provides: "Query profiling results and index decisions"
      min_lines: 30
  key_links:
    - from: "071_performance_indexes.sql"
      to: "unit_condition_summary view"
      via: "index on rooms(unit_id, condition)"
      pattern: "idx_rooms_unit_condition"
---

<objective>
Profile database queries using pg_stat_statements and create targeted indexes for slow query patterns.

Purpose: PERF-03 requires p95 query latency < 100ms. Must identify actual slow queries before blindly adding indexes.
Output: Query profiling document and migration with performance indexes.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-database-optimization/32-CONTEXT.md (if exists)

Key files:
@supabase/migrations/027_condition_tracking.sql (unit_condition_summary view)
@src/lib/dashboard/heatmap-queries.ts (uses unit_condition_summary)
@src/lib/dashboard/dashboard-queries.ts (uses unit_condition_summary)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Profile queries with pg_stat_statements</name>
  <files>.planning/baselines/v3.1-phase32-query-profile.md</files>
  <action>
Run Supabase local database and enable pg_stat_statements extension if not already enabled:

```sql
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
SELECT pg_stat_statements_reset(); -- Clear previous stats
```

Execute typical user flows to generate query load:
1. Load dashboard page (hits unit_condition_summary, renovation_projects)
2. Load heatmap page for a building with 10+ units
3. Load project detail page

Query pg_stat_statements for top queries by total_time:

```sql
SELECT
  substring(query, 1, 100) as query_preview,
  calls,
  round(total_exec_time::numeric, 2) as total_ms,
  round(mean_exec_time::numeric, 2) as mean_ms,
  round(max_exec_time::numeric, 2) as max_ms,
  rows
FROM pg_stat_statements
WHERE dbid = (SELECT oid FROM pg_database WHERE datname = current_database())
ORDER BY total_exec_time DESC
LIMIT 20;
```

Document findings in `.planning/baselines/v3.1-phase32-query-profile.md`:
- Top 10 slowest queries by mean time
- Queries with max_time > 100ms (our target threshold)
- Index recommendations based on WHERE/JOIN patterns

If local Supabase is not running, use the existing query patterns from dashboard code to derive index recommendations based on:
- `unit_condition_summary` grouped by building_id (rooms JOIN units)
- `renovation_projects` filtered by unit_id array and status
- `units` filtered by building_id with rooms subquery
  </action>
  <verify>File `.planning/baselines/v3.1-phase32-query-profile.md` exists with query analysis</verify>
  <done>Slow query patterns documented with specific column combinations for indexing</done>
</task>

<task type="auto">
  <name>Task 2: Create performance index migration</name>
  <files>supabase/migrations/071_performance_indexes.sql</files>
  <action>
Create migration `071_performance_indexes.sql` with targeted composite indexes based on profiling.

Expected indexes (validate against actual profiling results):

```sql
-- KEWA Renovations Operations System
-- Migration: 071_performance_indexes.sql
-- PERF-03: Performance indexes for dashboard/heatmap queries

-- =============================================
-- COMPOSITE INDEXES FOR VIEW PERFORMANCE
-- =============================================

-- Optimize unit_condition_summary view (rooms grouped by unit with condition)
-- Pattern: SELECT ... FROM rooms WHERE unit_id = X GROUP BY condition
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_rooms_unit_condition
ON rooms(unit_id, condition);

-- Optimize renovation_projects lookup by unit with status filter
-- Pattern: SELECT ... FROM renovation_projects WHERE unit_id IN (...) AND status IN (...)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_renovation_projects_unit_status
ON renovation_projects(unit_id, status);

-- Optimize units lookup by building with apartment filter
-- Pattern: SELECT ... FROM units WHERE building_id = X AND unit_type = 'apartment'
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_units_building_type
ON units(building_id, unit_type);

-- =============================================
-- ANALYZE TABLES
-- =============================================

ANALYZE rooms;
ANALYZE units;
ANALYZE renovation_projects;
```

Use CONCURRENTLY to avoid locking tables during index creation.
Include ANALYZE to update statistics after index creation.
  </action>
  <verify>`npx supabase migration list` shows 071_performance_indexes.sql</verify>
  <done>Migration created with composite indexes for dashboard query patterns</done>
</task>

<task type="auto">
  <name>Task 3: Apply and verify indexes</name>
  <files>None (verification only)</files>
  <action>
Apply the migration to local Supabase:

```bash
npx supabase db reset
```

Or if you want to keep existing data:

```bash
npx supabase migration up
```

Verify indexes exist and are being used:

```sql
-- Check indexes exist
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename IN ('rooms', 'units', 'renovation_projects')
AND indexname LIKE 'idx_%';

-- Verify index usage with EXPLAIN ANALYZE on heatmap query pattern
EXPLAIN ANALYZE
SELECT u.id, u.name, u.building_id,
  COUNT(r.id) as total_rooms,
  COUNT(CASE WHEN r.condition = 'new' THEN 1 END) as new_rooms
FROM units u
LEFT JOIN rooms r ON r.unit_id = u.id
WHERE u.building_id = '00000000-0000-0000-0000-000000000001'
GROUP BY u.id, u.name, u.building_id;
```

If EXPLAIN shows sequential scan where index scan expected, check:
1. Table statistics (run ANALYZE)
2. Query cost threshold (too small dataset for index to be beneficial)
  </action>
  <verify>EXPLAIN ANALYZE shows Index Scan for unit_condition queries</verify>
  <done>Indexes applied and verified with EXPLAIN ANALYZE showing index usage</done>
</task>

</tasks>

<verification>
1. `npx supabase migration list` includes 071_performance_indexes.sql
2. Query profiling document exists at `.planning/baselines/v3.1-phase32-query-profile.md`
3. Running `EXPLAIN ANALYZE` on dashboard queries shows index usage (or documents why sequential scan is optimal for small dataset)
</verification>

<success_criteria>
- Slow queries identified in profiling have indexes (PERF-03)
- EXPLAIN ANALYZE confirms index usage on key query patterns
- Migration ready for production deployment
</success_criteria>

<output>
After completion, create `.planning/phases/32-database-optimization/32-01-SUMMARY.md`
</output>
