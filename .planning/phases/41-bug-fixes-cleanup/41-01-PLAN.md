---
phase: 41-bug-fixes-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/inspections/signature-utils.ts
  - "src/app/api/inspections/[id]/signature/route.ts"
  - src/app/api/properties/route.ts
  - src/app/api/buildings/route.ts
  - src/components/navigation/PropertySelector.tsx
  - src/lib/supabase/cached-queries.ts
  - src/lib/dashboard/heatmap-queries.ts
  - src/lib/dashboard/dashboard-queries.ts
autonomous: true
requirements:
  - STOR-02
  - NAV-03

must_haves:
  truths:
    - "Signature upload uses org-scoped Supabase client — storage RLS INSERT passes because current_organization_id() returns the correct org UUID"
    - "hauswart role can call GET /api/properties and GET /api/buildings without 403 — CombinedSelector loads"
    - "cached-queries.ts server component queries return tenant-scoped data (not empty arrays) because set_org_context is called with orgId"
    - "PropertySelector.tsx no longer exists in the codebase"
  artifacts:
    - path: "src/lib/inspections/signature-utils.ts"
      provides: "Signature upload/download with injected SupabaseClient"
      contains: "supabase: SupabaseClient"
    - path: "src/app/api/inspections/[id]/signature/route.ts"
      provides: "Signature route passing org-scoped client to utils"
      contains: "createOrgClient"
    - path: "src/app/api/properties/route.ts"
      provides: "Properties API accessible to all internal roles"
      contains: "isInternalRole"
    - path: "src/app/api/buildings/route.ts"
      provides: "Buildings API accessible to all internal roles"
      contains: "isInternalRole"
    - path: "src/lib/supabase/cached-queries.ts"
      provides: "Org-scoped cached queries with orgId parameter"
      contains: "set_org_context"
  key_links:
    - from: "src/app/api/inspections/[id]/signature/route.ts"
      to: "src/lib/inspections/signature-utils.ts"
      via: "passes createOrgClient(req) result as first argument"
      pattern: "uploadSignature\\(supabase"
    - from: "src/app/api/properties/route.ts"
      to: "src/lib/permissions.ts"
      via: "imports and calls isInternalRole for authorization"
      pattern: "isInternalRole\\("
    - from: "src/lib/dashboard/heatmap-queries.ts"
      to: "src/lib/supabase/cached-queries.ts"
      via: "passes orgId to getCachedUnitsWithRooms"
      pattern: "getCachedUnitsWithRooms\\(buildingId,\\s*orgId\\)"
---

<objective>
Fix four integration bugs and tech debt items identified by the v4.0 milestone audit: signature storage RLS failure (INT-01), hauswart 403 on property/building APIs (INT-02), cached-queries server component regression, and orphaned PropertySelector.tsx.

Purpose: Close all known integration gaps from the v4.0 milestone audit so the multi-tenant architecture is fully functional.
Output: 8 files modified, 1 file deleted. All bugs resolved.
</objective>

<execution_context>
@C:/Users/Mario Giacchino/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mario Giacchino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-bug-fixes-cleanup/41-RESEARCH.md
@src/lib/supabase/with-org.ts
@src/lib/permissions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix signature-utils.ts to accept org-scoped Supabase client (INT-01)</name>
  <files>
    src/lib/inspections/signature-utils.ts
    src/app/api/inspections/[id]/signature/route.ts
  </files>
  <action>
**signature-utils.ts:**

1. Remove `import { createPublicClient } from '@/lib/supabase/with-org'`
2. Add `import type { SupabaseClient } from '@supabase/supabase-js'`
3. Change `uploadSignature` signature: add `supabase: SupabaseClient` as the FIRST parameter (before `orgId`). Remove the `const supabase = await createPublicClient()` line inside the function body. The rest of the function stays identical — it already uses `supabase` as the variable name.
4. Change `getSignatureUrl` signature: add `supabase: SupabaseClient` as the FIRST parameter (before `storagePath`). Remove the `const supabase = await createPublicClient()` line inside the function body. The rest stays identical.
5. Keep `import { inspectionSignaturePath } from '@/lib/storage/paths'` — still needed.

**route.ts (inspections/[id]/signature):**

1. Add import: `import { createOrgClient, OrgContextMissingError } from '@/lib/supabase/with-org'`
2. After the existing `if (!orgId)` guard (line 71-73), add: `const supabase = await createOrgClient(req)`
3. Update the `uploadSignature` call: change `uploadSignature(orgId, inspectionId, image_data_url)` to `uploadSignature(supabase, orgId, inspectionId, image_data_url)`
4. Update the `getSignatureUrl` call: change `getSignatureUrl(storagePath)` to `getSignatureUrl(supabase, storagePath)`
5. Wrap the existing catch block to also handle `OrgContextMissingError`: add `if (error instanceof OrgContextMissingError) { return NextResponse.json({ error: 'Organization context required' }, { status: 401 }) }` before the generic error handler. Add `OrgContextMissingError` to the import.
  </action>
  <verify>
Run `npx tsc --noEmit --pretty` — no type errors on signature-utils.ts or the route.ts file. Grep for `createPublicClient` in signature-utils.ts — should return zero matches. Grep for `SupabaseClient` in signature-utils.ts — should match the import and both function signatures.
  </verify>
  <done>
uploadSignature and getSignatureUrl accept a SupabaseClient as first parameter. The signature route creates an org-scoped client via createOrgClient(req) and passes it to both functions. No createPublicClient usage remains in signature-utils.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace ALLOWED_ROLES with isInternalRole in properties and buildings routes + delete orphaned PropertySelector (INT-02)</name>
  <files>
    src/app/api/properties/route.ts
    src/app/api/buildings/route.ts
    src/components/navigation/PropertySelector.tsx
  </files>
  <action>
**properties/route.ts:**

1. Remove `import type { Role } from '@/types'`
2. Add `import { isInternalRole } from '@/lib/permissions'`
3. Delete `const ALLOWED_ROLES: Role[] = ['kewa', 'imeri']` (line 16)
4. In GET handler: replace the block that reads `x-user-role` and checks ALLOWED_ROLES (lines 32-47) with:
   ```
   const roleName = request.headers.get('x-user-role-name')
   if (!roleName || !isInternalRole(roleName)) {
     return NextResponse.json(
       { error: 'Forbidden: Insufficient permissions' },
       { status: 403 }
     )
   }
   ```
   Remove the `userId` check entirely — middleware already guarantees auth. Actually keep the userId null check for the 401 response but remove the userRole variable and ALLOWED_ROLES check. Replace with roleName + isInternalRole.
5. In POST handler: same replacement — replace the `x-user-role` + ALLOWED_ROLES check with `x-user-role-name` + `isInternalRole(roleName)`.
6. If `Role` type is no longer used anywhere in the file after removal, confirm the import is removed.

**buildings/route.ts:**

Same exact changes as properties/route.ts:
1. Remove `import type { Role } from '@/types'`
2. Add `import { isInternalRole } from '@/lib/permissions'`
3. Delete `const ALLOWED_ROLES: Role[] = ['kewa', 'imeri']` (line 15)
4. In GET handler: replace `x-user-role` + `ALLOWED_ROLES.includes(userRole)` with `x-user-role-name` + `isInternalRole(roleName)`.
5. In POST handler: same replacement.

**PropertySelector.tsx deletion:**

Delete `src/components/navigation/PropertySelector.tsx`. It has zero imports anywhere — confirmed orphaned. No other files reference it.
  </action>
  <verify>
Run `npx tsc --noEmit --pretty` — no type errors. Grep for `ALLOWED_ROLES` in properties/route.ts and buildings/route.ts — zero matches. Grep for `isInternalRole` in both files — should match. Verify `PropertySelector.tsx` does not exist: `ls src/components/navigation/PropertySelector.tsx` should fail.
  </verify>
  <done>
Both /api/properties and /api/buildings use isInternalRole(roleName) from x-user-role-name header — hauswart users pass authorization. ALLOWED_ROLES pattern eliminated from both files. PropertySelector.tsx deleted.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix cached-queries.ts to use org-scoped client and propagate orgId through callers</name>
  <files>
    src/lib/supabase/cached-queries.ts
    src/lib/dashboard/heatmap-queries.ts
    src/lib/dashboard/dashboard-queries.ts
  </files>
  <action>
**cached-queries.ts:**

1. Remove `import { createPublicClient } from '@/lib/supabase/with-org'`
2. Add imports:
   ```typescript
   import { createServerClient } from '@supabase/ssr'
   import { cookies } from 'next/headers'
   ```
3. Add a private helper function `createOrgScopedClient` at the top (after imports, before the exported functions):
   ```typescript
   async function createOrgScopedClient(orgId: string) {
     const cookieStore = await cookies()
     const supabase = createServerClient(
       process.env.NEXT_PUBLIC_SUPABASE_URL!,
       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
       {
         cookies: {
           getAll() { return cookieStore.getAll() },
           setAll(cookiesToSet) {
             try {
               cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options))
             } catch { /* server component */ }
           },
         },
       }
     )
     await supabase.rpc('set_org_context', { org_id: orgId })
     return supabase
   }
   ```
4. Update `getCachedUnitsWithRooms`: add `orgId: string` as SECOND parameter (after `buildingId`). Replace `const supabase = await createPublicClient()` with `const supabase = await createOrgScopedClient(orgId)`.
5. Update `getCachedUnitConditionSummary`: add `orgId: string` as SECOND parameter. Same client replacement.
6. Update `getCachedActiveProjectCount`: add `orgId: string` as SECOND parameter (after `unitIds`). Same client replacement.

IMPORTANT: orgId MUST be a parameter (not read from cookies inside cache) because `cache()` keys on arguments. Reading from cookies inside would break cache isolation between orgs.

**heatmap-queries.ts:**

1. Add `orgId: string` as SECOND parameter to `fetchHeatmapData(buildingId: string, orgId: string)`.
2. Update the call: `getCachedUnitsWithRooms(buildingId)` becomes `getCachedUnitsWithRooms(buildingId, orgId)`.

**dashboard-queries.ts:**

1. Add `orgId: string` as SECOND parameter to `fetchDashboardSummary(buildingId: string, orgId: string)`.
2. Update calls: `getCachedUnitConditionSummary(buildingId)` becomes `getCachedUnitConditionSummary(buildingId, orgId)`.
3. Update call: `getCachedActiveProjectCount(unitIds)` becomes `getCachedActiveProjectCount(unitIds, orgId)`.

**Callers of heatmap-queries.ts and dashboard-queries.ts:**

The callers are server components `PropertyDashboard.tsx` and `BuildingHeatmap.tsx`. These accept `buildingId` as a prop but not `orgId`. They need `orgId` propagated from somewhere.

Check: these components are rendered from `LiegenschaftContainer.tsx` (a client component) which fetches via `/api/buildings/${id}/heatmap` — BUT PropertyDashboard and BuildingHeatmap are async server components that call the query functions directly.

For the server components, read `orgId` from the `organization_id` cookie using `cookies()` from `next/headers`:

In `PropertyDashboard.tsx`:
1. Add `import { cookies } from 'next/headers'`
2. At start of the async function body: `const orgId = (await cookies()).get('organization_id')?.value ?? ''`
3. Pass `orgId` to `fetchDashboardSummary(buildingId, orgId)`

In `BuildingHeatmap.tsx`:
1. Add `import { cookies } from 'next/headers'`
2. At start of the async function body: `const orgId = (await cookies()).get('organization_id')?.value ?? ''`
3. Pass `orgId` to `fetchHeatmapData(buildingId, orgId)`
  </action>
  <verify>
Run `npx tsc --noEmit --pretty` — no type errors. Grep for `createPublicClient` in cached-queries.ts — zero matches. Grep for `set_org_context` in cached-queries.ts — should match inside createOrgScopedClient. Grep for `orgId` in heatmap-queries.ts and dashboard-queries.ts — should match in function signatures and calls.
  </verify>
  <done>
All three cached query functions accept orgId as a parameter and call set_org_context via the private createOrgScopedClient helper. cache() correctly keys on orgId preventing cross-tenant cache hits. Both callers (heatmap-queries.ts, dashboard-queries.ts) propagate orgId. Server components read orgId from the organization_id cookie.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit --pretty` — full project compiles with zero errors
2. `grep -r "createPublicClient" src/lib/inspections/signature-utils.ts src/lib/supabase/cached-queries.ts` — zero matches (both files migrated off createPublicClient)
3. `grep -r "ALLOWED_ROLES" src/app/api/properties/route.ts src/app/api/buildings/route.ts` — zero matches
4. `grep -r "isInternalRole" src/app/api/properties/route.ts src/app/api/buildings/route.ts` — matches in both
5. `ls src/components/navigation/PropertySelector.tsx` — file does not exist (deleted)
6. `grep -r "set_org_context" src/lib/supabase/cached-queries.ts` — matches (org context set)
7. `grep -r "SupabaseClient" src/lib/inspections/signature-utils.ts` — matches (client injection)
</verification>

<success_criteria>
- signature-utils.ts accepts SupabaseClient, no createPublicClient
- Signature route creates org-scoped client and passes to utils
- properties/route.ts and buildings/route.ts use isInternalRole, no ALLOWED_ROLES
- cached-queries.ts uses createOrgScopedClient with orgId parameter
- PropertySelector.tsx deleted
- Full TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/41-bug-fixes-cleanup/41-01-SUMMARY.md`
</output>
