---
phase: 40-storage-multi-tenancy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/storage/paths.ts
  - supabase/migrations/084_storage_rls.sql
autonomous: true
requirements:
  - STOR-01
  - STOR-02
must_haves:
  truths:
    - "buildStoragePath(orgId, ...segments) returns orgId as first path segment"
    - "Storage RLS policies on all 4 buckets enforce (storage.foldername(name))[1] = current_organization_id()::text"
    - "Old unscoped storage policies from 041 and 059 are dropped"
  artifacts:
    - path: "src/lib/storage/paths.ts"
      provides: "Centralised org-prefixed path builder for all storage uploads"
      exports: ["buildStoragePath", "BUCKETS", "taskPhotoPath", "taskAudioPath", "workOrderDocumentPath", "workOrderPhotoPath", "changeOrderPhotoPath", "kbAttachmentPath", "ticketPhotoPath", "ticketMessageAttachmentPath", "inspectionItemPhotoPath", "inspectionDefectPhotoPath", "inspectionSignaturePath"]
    - path: "supabase/migrations/084_storage_rls.sql"
      provides: "Storage RLS policies for media, task-photos, task-audio, inspections buckets"
      contains: "CREATE POLICY"
  key_links:
    - from: "src/lib/storage/paths.ts"
      to: "storage buckets"
      via: "path string with orgId as first segment"
      pattern: "\\[orgId, \\.\\.\\.segments\\]\\.join"
    - from: "supabase/migrations/084_storage_rls.sql"
      to: "supabase/migrations/076_rls_helpers.sql"
      via: "current_organization_id() function"
      pattern: "current_organization_id"
---

<objective>
Create the centralised storage path builder and Storage RLS policies for all four buckets.

Purpose: Establishes the two foundational pieces for storage multi-tenancy: (1) a TypeScript helper that all upload sites will import to generate org-prefixed paths, and (2) SQL policies on storage.objects that enforce the org prefix at the database level.

Output: `src/lib/storage/paths.ts` and `supabase/migrations/084_storage_rls.sql`
</objective>

<execution_context>
@C:/Users/Mario Giacchino/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mario Giacchino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/40-storage-multi-tenancy/40-RESEARCH.md
@supabase/migrations/041_storage_buckets.sql
@supabase/migrations/059_inspections.sql
@supabase/migrations/076_rls_helpers.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create centralised storage path builder</name>
  <files>src/lib/storage/paths.ts</files>
  <action>
Create `src/lib/storage/paths.ts` with the following exports:

1. `BUCKETS` const object mapping logical names to bucket IDs:
   - `media: 'media'`
   - `taskPhotos: 'task-photos'`
   - `taskAudio: 'task-audio'`
   - `inspections: 'inspections'`

2. `BucketName` type derived from BUCKETS values.

3. `buildStoragePath(orgId: string, ...segments: string[]): string` — joins `[orgId, ...segments]` with `/`. This is the core function; all typed builders below delegate to it.

4. Typed path builders (each calls buildStoragePath internally):
   - `taskPhotoPath(orgId, taskId, photoType, uuid, ext)` → `{orgId}/{taskId}/{photoType}/{uuid}.{ext}`
   - `taskAudioPath(orgId, taskId, audioType, uuid, ext)` → `{orgId}/{taskId}/{audioType}/{uuid}.{ext}`
   - `workOrderDocumentPath(orgId, workOrderId, uuid, ext)` → `{orgId}/work_orders/{workOrderId}/documents/{uuid}.{ext}`
   - `workOrderPhotoPath(orgId, workOrderId, context, uuid, ext)` → `{orgId}/work_orders/{workOrderId}/photos/{context}/{uuid}.{ext}`
   - `changeOrderPhotoPath(orgId, coId, timestamp, filename)` → `{orgId}/change_orders/{coId}/photos/{timestamp}-{filename}`
   - `kbAttachmentPath(orgId, articleId, uuid, ext)` → `{orgId}/kb_articles/{articleId}/attachments/{uuid}.{ext}`
   - `ticketPhotoPath(orgId, ticketId, uuid, ext)` → `{orgId}/tickets/{ticketId}/photos/{uuid}.{ext}`
   - `ticketMessageAttachmentPath(orgId, ticketId, messageId, uuid, ext)` → `{orgId}/tickets/{ticketId}/messages/{messageId}/{uuid}.{ext}`
   - `inspectionItemPhotoPath(orgId, inspectionId, uuid)` → `{orgId}/{inspectionId}/items/{uuid}.webp`
   - `inspectionDefectPhotoPath(orgId, inspectionId, uuid)` → `{orgId}/{inspectionId}/defects/{uuid}.webp`
   - `inspectionSignaturePath(orgId, inspectionId)` → `{orgId}/inspections/{inspectionId}/signature.png`

Use the exact path patterns from the research file's "New Path Convention" section. Export everything.
  </action>
  <verify>Run `npx tsc --noEmit src/lib/storage/paths.ts` — compiles without errors.</verify>
  <done>paths.ts exports buildStoragePath, BUCKETS, BucketName, and all 11 typed path builders. Each builder produces a string with orgId as the first path segment.</done>
</task>

<task type="auto">
  <name>Task 2: Create Storage RLS migration</name>
  <files>supabase/migrations/084_storage_rls.sql</files>
  <action>
Create migration `084_storage_rls.sql` with the following sections:

**Section 1: Drop old unscoped policies**

Drop ALL existing storage.objects policies from 041_storage_buckets.sql:
```sql
DROP POLICY IF EXISTS "Authenticated users can read photos" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can upload photos" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can delete photos" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can read audio" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can upload audio" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can delete audio" ON storage.objects;
```

Note: 059_inspections.sql used `storage.policies` table inserts (not CREATE POLICY on storage.objects). Those policies may or may not exist depending on whether the deprecated `storage.policies` table was used. Add a safety DROP for them too if they created policies on storage.objects:
```sql
DROP POLICY IF EXISTS "Authenticated users can view inspections" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated users can upload to inspections" ON storage.objects;
```

**Section 2: Create org-scoped policies for each bucket**

For EACH of the 4 buckets (`media`, `task-photos`, `task-audio`, `inspections`), create 4 policies (SELECT, INSERT, UPDATE, DELETE) with this pattern:

```sql
CREATE POLICY "{bucket}_org_select" ON storage.objects FOR SELECT
TO authenticated
USING (
  bucket_id = '{bucket}'
  AND (storage.foldername(name))[1] = current_organization_id()::text
);

CREATE POLICY "{bucket}_org_insert" ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = '{bucket}'
  AND (storage.foldername(name))[1] = current_organization_id()::text
);

CREATE POLICY "{bucket}_org_update" ON storage.objects FOR UPDATE
TO authenticated
USING (
  bucket_id = '{bucket}'
  AND (storage.foldername(name))[1] = current_organization_id()::text
)
WITH CHECK (
  bucket_id = '{bucket}'
  AND (storage.foldername(name))[1] = current_organization_id()::text
);

CREATE POLICY "{bucket}_org_delete" ON storage.objects FOR DELETE
TO authenticated
USING (
  bucket_id = '{bucket}'
  AND (storage.foldername(name))[1] = current_organization_id()::text
);
```

Bucket IDs in the policies: `media`, `task-photos`, `task-audio`, `inspections`. Use underscored names for the policy name prefix: `media_org_`, `task_photos_org_`, `task_audio_org_`, `inspections_org_`.

Total: 8 DROPs + 16 CREATEs = 24 statements.

Add header comment explaining the purpose: "Replace unscoped storage policies with org-scoped policies using current_organization_id()."
  </action>
  <verify>Review the SQL file: exactly 8 DROP POLICY statements and 16 CREATE POLICY statements. Each CREATE POLICY references `current_organization_id()::text` and `storage.foldername(name))[1]`.</verify>
  <done>Migration 084 drops all old unscoped storage policies and creates 16 new org-scoped policies (4 per bucket x 4 buckets). Policies use current_organization_id() from 076_rls_helpers.sql.</done>
</task>

</tasks>

<verification>
1. `src/lib/storage/paths.ts` compiles without TypeScript errors
2. `084_storage_rls.sql` contains exactly 8 DROP and 16 CREATE POLICY statements
3. Every bucket (media, task-photos, task-audio, inspections) has SELECT/INSERT/UPDATE/DELETE policies
4. All policies use `(storage.foldername(name))[1] = current_organization_id()::text` pattern
</verification>

<success_criteria>
- Path builder helper exists and exports buildStoragePath + all typed builders
- Storage RLS migration exists with org-scoped policies for all 4 buckets
- Old unscoped policies are dropped
</success_criteria>

<output>
After completion, create `.planning/phases/40-storage-multi-tenancy/40-01-SUMMARY.md`
</output>
