---
phase: 13-partner-modul
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/partners/route.ts
  - src/app/api/partners/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/partners returns list of partners with pagination"
    - "GET /api/partners?is_active=true filters to active partners only"
    - "GET /api/partners?type=contractor filters to contractors only"
    - "POST /api/partners creates a new partner with validation"
    - "GET /api/partners/[id] returns single partner by ID"
    - "PATCH /api/partners/[id] updates partner fields"
    - "PATCH /api/partners/[id] with is_active toggles active status"
  artifacts:
    - path: "src/app/api/partners/route.ts"
      provides: "Collection routes: GET list with filters, POST create"
      exports: ["GET", "POST"]
    - path: "src/app/api/partners/[id]/route.ts"
      provides: "Single resource routes: GET, PATCH, DELETE"
      exports: ["GET", "PATCH", "DELETE"]
  key_links:
    - from: "src/app/api/partners/route.ts"
      to: "partners table"
      via: "Supabase client query"
      pattern: "supabase\\.from\\('partners'\\)"
---

<objective>
Implement Partner API routes for full CRUD operations on partner/contractor master data.

Purpose: Enable admin management of partners (Handwerker/Lieferanten) through REST API endpoints. WorkOrderForm already expects `/api/partners` to exist (lines 156-162), so this unblocks that integration.

Output: Two API route files providing GET/POST on collection and GET/PATCH/DELETE on single resources.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-partner-modul/13-RESEARCH.md

# Existing patterns to follow exactly
@src/app/api/expenses/route.ts
@src/app/api/invoices/[id]/route.ts

# Partner type definition
@src/types/database.ts (lines 322-335)

# Partner schema (already exists)
@supabase/migrations/014_partner.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create partner collection routes (GET/POST)</name>
  <files>src/app/api/partners/route.ts</files>
  <action>
Create `/api/partners` route following existing expenses/route.ts pattern exactly:

**GET /api/partners:**
- Extract user from headers (x-user-id, x-user-role)
- Check authorization: roles 'kewa' and 'imeri' allowed
- Parse query params:
  - `type`: Filter by partner_type ('contractor' or 'supplier')
  - `is_active`: Filter by is_active boolean ('true' or 'false')
  - `trade`: Filter by trade_categories array contains (use `.contains()`)
  - `limit`: Default 50
  - `offset`: Default 0
- Query partners table with filters, order by company_name ascending
- Use `{ count: 'exact' }` for pagination
- Return `{ partners, total, limit, offset }`

**POST /api/partners:**
- Same auth check as GET
- Validate required fields:
  - `company_name`: Required, trim whitespace
  - `partner_type`: Required, must be 'contractor' or 'supplier'
  - `email`: Required for contractors (regex validate), optional for suppliers
  - `trade_categories`: Must be array if provided
- Insert with all fields from body:
  - partner_type, company_name, contact_name, email, phone, address
  - trade_categories (array), is_active (default true), notes
- Return `{ partner }` with status 201

**Important:** Do NOT use Zod or external validation libraries - use manual validation like expenses/route.ts does. Import `createClient` from '@/lib/supabase/server'.
  </action>
  <verify>
```bash
# Start dev server if needed, then test endpoints
curl -X GET 'http://localhost:3000/api/partners' -H 'x-user-id: test' -H 'x-user-role: kewa'
# Should return { partners: [], total: 0, limit: 50, offset: 0 }

curl -X GET 'http://localhost:3000/api/partners?type=contractor&is_active=true' -H 'x-user-id: test' -H 'x-user-role: kewa'
# Should return filtered results

# TypeScript compilation check
npx tsc --noEmit src/app/api/partners/route.ts
```
  </verify>
  <done>GET /api/partners returns partners list with filters. POST /api/partners creates partner with validation.</done>
</task>

<task type="auto">
  <name>Task 2: Create partner single-resource routes (GET/PATCH/DELETE)</name>
  <files>src/app/api/partners/[id]/route.ts</files>
  <action>
Create `/api/partners/[id]` route following existing invoices/[id]/route.ts pattern exactly:

**Setup:**
- Define RouteContext interface: `{ params: Promise<{ id: string }> }`
- Define UUID_REGEX constant for validation
- Define UpdatePartnerInput interface with all optional fields

**GET /api/partners/[id]:**
- Auth check (kewa, imeri roles)
- Validate UUID format with regex
- Query single partner by id
- Handle PGRST116 error as 404
- Return `{ partner }`

**PATCH /api/partners/[id]:**
- Auth check
- Validate UUID format
- Parse body as UpdatePartnerInput
- Check partner exists first (404 if not)
- Build updateData object with only provided fields:
  - company_name, contact_name, email, phone, address
  - trade_categories (array), is_active (boolean), notes
- Validate email format if provided
- Return `{ partner }` after update

**DELETE /api/partners/[id]:**
- Auth check (kewa role only - admin)
- Validate UUID format
- Check partner exists
- Optional: Check for active work orders and return warning (soft validation)
- Delete partner
- Return `{ success: true }`

**Important:** Use `await context.params` to get id (Next.js 16 async params pattern).
  </action>
  <verify>
```bash
# Create a test partner first via POST, then test:
curl -X GET 'http://localhost:3000/api/partners/{id}' -H 'x-user-id: test' -H 'x-user-role: kewa'
# Should return { partner: {...} }

curl -X PATCH 'http://localhost:3000/api/partners/{id}' \
  -H 'Content-Type: application/json' \
  -H 'x-user-id: test' -H 'x-user-role: kewa' \
  -d '{"is_active": false}'
# Should return updated partner with is_active: false

# TypeScript compilation check
npx tsc --noEmit src/app/api/partners/[id]/route.ts
```
  </verify>
  <done>Single partner CRUD operations work: GET returns partner, PATCH updates fields, DELETE removes partner.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **API smoke test:**
```bash
# Test full CRUD cycle
# 1. Create
curl -X POST 'http://localhost:3000/api/partners' \
  -H 'Content-Type: application/json' \
  -H 'x-user-id: test' -H 'x-user-role: kewa' \
  -d '{"partner_type":"contractor","company_name":"Test GmbH","email":"test@example.com","trade_categories":["plumbing"]}'

# 2. List (should include new partner)
curl -X GET 'http://localhost:3000/api/partners' -H 'x-user-id: test' -H 'x-user-role: kewa'

# 3. Get single
curl -X GET 'http://localhost:3000/api/partners/{id}' -H 'x-user-id: test' -H 'x-user-role: kewa'

# 4. Update
curl -X PATCH 'http://localhost:3000/api/partners/{id}' \
  -H 'Content-Type: application/json' \
  -H 'x-user-id: test' -H 'x-user-role: kewa' \
  -d '{"is_active":false}'

# 5. Delete
curl -X DELETE 'http://localhost:3000/api/partners/{id}' -H 'x-user-id: test' -H 'x-user-role: kewa'
```

2. **Type check:** `npx tsc --noEmit`

3. **WorkOrderForm compatibility:** GET /api/partners?type=contractor returns `{ partners: Partner[] }` format expected by WorkOrderForm.tsx line 159.
</verification>

<success_criteria>
- [ ] GET /api/partners returns list with pagination metadata
- [ ] GET /api/partners?type=contractor filters to contractors
- [ ] GET /api/partners?is_active=true filters to active only
- [ ] POST /api/partners creates partner with validation (email required for contractors)
- [ ] GET /api/partners/[id] returns single partner or 404
- [ ] PATCH /api/partners/[id] updates allowed fields
- [ ] PATCH with is_active toggles partner active status
- [ ] DELETE /api/partners/[id] removes partner (admin only)
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/13-partner-modul/13-01-SUMMARY.md`
</output>
