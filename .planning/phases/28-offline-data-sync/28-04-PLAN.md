---
phase: 28-offline-data-sync
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/dashboard/liegenschaft/[id]/page.tsx
  - src/app/dashboard/auftraege/[id]/page.tsx
  - src/app/dashboard/einheiten/[id]/page.tsx
  - src/app/dashboard/aufgaben/[id]/page.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Property detail page caches entity data in IndexedDB when loaded online"
    - "Work order detail page caches entity data in IndexedDB when loaded online"
    - "Unit detail page caches entity data in IndexedDB when loaded online"
    - "Task detail page caches entity data in IndexedDB when loaded online"
    - "Entity detail pages show StalenessIndicator with cached timestamp when offline"
    - "Entity detail pages fall back to IndexedDB cached data when fetch fails while offline"
  artifacts:
    - path: "src/app/dashboard/liegenschaft/[id]/page.tsx"
      provides: "Property caching on view, offline fallback, staleness indicator"
      contains: "cacheEntityOnView"
    - path: "src/app/dashboard/auftraege/[id]/page.tsx"
      provides: "Work order caching on view, offline fallback, staleness indicator"
      contains: "cacheEntityOnView"
    - path: "src/app/dashboard/einheiten/[id]/page.tsx"
      provides: "Unit caching on view, offline fallback, staleness indicator"
      contains: "cacheEntityOnView"
    - path: "src/app/dashboard/aufgaben/[id]/page.tsx"
      provides: "Task caching on view, offline fallback, staleness indicator"
      contains: "cacheEntityOnView"
  key_links:
    - from: "src/app/dashboard/auftraege/[id]/page.tsx"
      to: "src/lib/db/operations.ts"
      via: "cacheEntityOnView('workOrder', id, data)"
      pattern: "cacheEntityOnView"
    - from: "src/app/dashboard/auftraege/[id]/page.tsx"
      to: "src/hooks/useOfflineEntity.ts"
      via: "useOfflineEntity('workOrder', id)"
      pattern: "useOfflineEntity"
    - from: "src/app/dashboard/liegenschaft/[id]/page.tsx"
      to: "src/lib/db/operations.ts"
      via: "cacheEntityOnView('property', id, data)"
      pattern: "cacheEntityOnView"
---

<objective>
Wire entity caching into the 4 most-viewed entity detail pages so that recently viewed data is readable from IndexedDB when offline.

Purpose: Phase 28 built complete offline infrastructure (Dexie schema, caching operations, hooks, staleness indicator) but no entity pages call cacheEntityOnView. Users cannot read any cached data offline. This plan closes Gap 1 from verification.

Output: 4 entity detail pages that (1) cache data on successful fetch, (2) fall back to cached data when fetch fails offline, and (3) show StalenessIndicator when displaying cached data.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-offline-data-sync/28-CONTEXT.md
@.planning/phases/28-offline-data-sync/28-01-SUMMARY.md

Key infrastructure files (read these first):
@src/lib/db/operations.ts -- cacheEntityOnView(entityType, entityId, data)
@src/hooks/useOfflineEntity.ts -- useOfflineEntity(entityType, entityId) returns { data, cachedAt, pinned, isLoading }
@src/components/StalenessIndicator.tsx -- <StalenessIndicator cachedAt={cachedAt} /> only renders when offline
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire entity caching into property and work order detail pages</name>
  <files>
    src/app/dashboard/liegenschaft/[id]/page.tsx
    src/app/dashboard/auftraege/[id]/page.tsx
  </files>
  <action>
    For each page, apply the same 3-step integration pattern:

    **Step 1: Import caching infrastructure**
    Add imports at the top of the file:
    ```
    import { cacheEntityOnView } from '@/lib/db/operations'
    import { useOfflineEntity } from '@/hooks/useOfflineEntity'
    import { StalenessIndicator } from '@/components/StalenessIndicator'
    import { useConnectivity } from '@/contexts/ConnectivityContext'
    ```

    **Step 2: Add caching on successful fetch + offline fallback**
    After the existing `useEffect` fetch succeeds and sets data, add a call to `cacheEntityOnView`.
    Add a second path: if the fetch fails AND isOnline is false, fall back to useOfflineEntity data.

    Pattern for liegenschaft/[id]/page.tsx:
    - Add `const { isOnline } = useConnectivity()` and `const offlineCache = useOfflineEntity('property', id)` in the component body
    - In the existing fetchBuilding function, after `setBuilding(data.building)`, add: `cacheEntityOnView('property', id, data.building)`
    - In the catch block, if `!isOnline && offlineCache.data`, set `setBuilding(offlineCache.data)` and `setError(null)` instead of showing error
    - Also add a `useEffect` that handles the case where the page loads while already offline: if `!isOnline && !building && offlineCache.data`, set building from cache

    Pattern for auftraege/[id]/page.tsx:
    - Same as above but with entityType 'workOrder'
    - After `setWorkOrder(data.workOrder)`, add: `cacheEntityOnView('workOrder', id, data.workOrder)`
    - Offline fallback: if `!isOnline && offlineCache.data`, set workOrder from cache

    **Step 3: Add StalenessIndicator**
    Add `<StalenessIndicator cachedAt={offlineCache.cachedAt} />` below each page's header/title area.
    For liegenschaft: below the h1 heading inside the header div.
    For auftraege: below the h1/badge row inside the header div.

    IMPORTANT: The useOfflineEntity hook uses useLiveQuery which returns `undefined` initially. Handle the loading state by checking `offlineCache.isLoading`.
    IMPORTANT: Do NOT wrap the entire fetch in an offline check -- always attempt fetch first (network-first strategy), only fall back to cache on failure when offline.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no TypeScript errors.
    Grep for `cacheEntityOnView` in both files to confirm import and usage.
    Grep for `StalenessIndicator` in both files to confirm rendering.
  </verify>
  <done>
    liegenschaft/[id] and auftraege/[id] pages cache entity data on view, fall back to IndexedDB when offline, and show StalenessIndicator.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire entity caching into unit and task detail pages</name>
  <files>
    src/app/dashboard/einheiten/[id]/page.tsx
    src/app/dashboard/aufgaben/[id]/page.tsx
  </files>
  <action>
    Apply the same 3-step integration pattern from Task 1 to these two pages.

    For einheiten/[id]/page.tsx:
    - entityType: 'unit'
    - This page fetches both unit and rooms in parallel. Cache the unit data: `cacheEntityOnView('unit', id, unitData.unit)`
    - Also cache rooms as children: `import { cacheChildren } from '@/lib/db/operations'` and call `cacheChildren('unit', id, roomsData.rooms.map(r => ({ entityType: 'unit' as const, entityId: r.id, data: r })))` -- actually rooms are not a cached entity type, so just cache the unit itself.
    - Offline fallback: if fetch fails and offline, use `useOfflineEntity('unit', id)` to populate unit state. Do NOT try to load rooms from cache (rooms are not independently cacheable entities) -- just show the unit header without rooms when offline.
    - Add StalenessIndicator below the unit name heading.

    For aufgaben/[id]/page.tsx:
    - entityType: 'task'
    - This page uses useParams instead of page props to get the task ID
    - After `setTask(data.task)` in fetchTask, add: `cacheEntityOnView('task', taskId, data.task)`
    - Offline fallback: if fetchTask fails and offline, populate task from cache. Photos and audio will not be available offline (they require separate API calls).
    - Add StalenessIndicator below the task title in the header Card.

    IMPORTANT: For aufgaben/[id], the offline fallback only covers the task entity itself. Photos, audio, and user role will not be available offline. The page should gracefully show the task info without those sections when using cached data.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no TypeScript errors.
    Grep for `cacheEntityOnView` in both files.
    Grep for `StalenessIndicator` in both files.
    Grep for `useOfflineEntity` in both files.
  </verify>
  <done>
    einheiten/[id] and aufgaben/[id] pages cache entity data on view, fall back to IndexedDB when offline, and show StalenessIndicator.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. All 4 entity detail pages import and call `cacheEntityOnView`
3. All 4 pages import and use `useOfflineEntity` for fallback
4. All 4 pages render `<StalenessIndicator />` component
5. No existing functionality is broken (pages still work normally when online)
</verification>

<success_criteria>
- `grep -r "cacheEntityOnView" src/app/` returns 4 files
- `grep -r "useOfflineEntity" src/app/` returns 4 files
- `grep -r "StalenessIndicator" src/app/` returns 4 files
- TypeScript compilation succeeds
- Entity data is cached in IndexedDB on page view (observable via DevTools > Application > IndexedDB > KeWaDB > cachedEntities)
</success_criteria>

<output>
After completion, create `.planning/phases/28-offline-data-sync/28-04-SUMMARY.md`
</output>
