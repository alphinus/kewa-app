---
phase: 28-offline-data-sync
plan: 03
type: execute
wave: 3
depends_on: ["28-02"]
files_modified:
  - src/lib/sync/conflict-resolver.ts
  - src/lib/sync/photo-uploader.ts
  - src/lib/db/sync-queue.ts
  - src/hooks/useOfflinePhoto.ts
  - src/contexts/ConnectivityContext.tsx
autonomous: true

must_haves:
  truths:
    - "Conflicts are detected by comparing local updated_at with server updated_at after sync"
    - "Server wins in LWW resolution and user is notified via auto-dismiss toast"
    - "Photos captured offline are compressed and queued in IndexedDB photoQueue"
    - "Photos upload sequentially on reconnect with per-photo progress feedback"
    - "Failed photo uploads retry with exponential backoff; form data syncs independently"
  artifacts:
    - path: "src/lib/sync/conflict-resolver.ts"
      provides: "Last-Write-Wins conflict detection and resolution"
      exports: ["detectAndResolveConflict"]
    - path: "src/lib/sync/photo-uploader.ts"
      provides: "Sequential photo upload with compression and progress"
      exports: ["processPhotoQueue", "queueOfflinePhoto"]
    - path: "src/hooks/useOfflinePhoto.ts"
      provides: "Hook for capturing and queueing photos offline"
      exports: ["useOfflinePhoto"]
  key_links:
    - from: "src/lib/db/sync-queue.ts"
      to: "src/lib/sync/conflict-resolver.ts"
      via: "detectAndResolveConflict called after successful sync"
      pattern: "detectAndResolveConflict"
    - from: "src/lib/sync/photo-uploader.ts"
      to: "src/lib/db/schema.ts"
      via: "Dexie photoQueue table"
      pattern: "db\\.photoQueue"
    - from: "src/contexts/ConnectivityContext.tsx"
      to: "src/lib/sync/photo-uploader.ts"
      via: "processPhotoQueue on reconnect after sync queue"
      pattern: "processPhotoQueue"
---

<objective>
Add conflict detection with Last-Write-Wins resolution, offline photo capture with compression and sequential upload, and wire photo queue processing into the reconnect flow.

Purpose: This completes Phase 28 by adding the remaining data integrity features. Conflict resolution ensures users know when server data takes precedence. Photo queueing enables offline inspection workflows where photos are critical evidence.
Output: Conflict resolver, photo uploader with compression, offline photo hook, and updated sync pipeline.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-offline-data-sync/28-CONTEXT.md
@.planning/phases/28-offline-data-sync/28-RESEARCH.md
@.planning/phases/28-offline-data-sync/28-01-SUMMARY.md
@.planning/phases/28-offline-data-sync/28-02-SUMMARY.md
@src/lib/db/schema.ts
@src/lib/db/sync-queue.ts
@src/lib/sync/retry-strategy.ts
@src/contexts/ConnectivityContext.tsx
@src/lib/imageCompression.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Conflict resolver and sync queue integration</name>
  <files>
    src/lib/sync/conflict-resolver.ts
    src/lib/db/sync-queue.ts
  </files>
  <action>
Create `src/lib/sync/conflict-resolver.ts`:
- Import db from '@/lib/db/schema'
- Import toast from 'sonner'
- Import cacheEntityOnView from '@/lib/db/operations'

- Export `detectAndResolveConflict(params: { entityType: string, entityId: string, localUpdatedAt: string, serverResponse: any })`:
  - Compare timestamps: localTime = new Date(localUpdatedAt).getTime(), serverTime = new Date(serverResponse.updated_at).getTime()
  - If serverTime > localTime (server wins):
    1. Update local cache with server data via cacheEntityOnView(entityType, entityId, serverResponse)
    2. Show auto-dismiss toast: toast('Ihre Aenderungen wurden ueberschrieben', { duration: 4000 })
    3. Return { winner: 'server', serverData: serverResponse }
  - If serverTime <= localTime (local wins — no conflict):
    1. Update local cache with server response (which includes server-side computed fields)
    2. Return { winner: 'local', serverData: serverResponse }
  - This function is called AFTER a successful sync, not during. The sync itself always succeeds (POST/PUT to server). Conflict detection is about whether someone else modified the entity between when we cached it and when we synced.

- Export type `ConflictResult = { winner: 'local' | 'server', serverData: any }`

Modify `src/lib/db/sync-queue.ts` — update processSyncQueue:
- Import detectAndResolveConflict from '@/lib/sync/conflict-resolver'
- After a successful sync of an 'update' operation:
  1. Parse the response JSON
  2. If the sync item payload contains an `updated_at` field (meaning it was an entity update, not a create):
     Call detectAndResolveConflict({ entityType: item.entityType, entityId: item.entityId, localUpdatedAt: item.payload.updated_at, serverResponse: responseData })
  3. For 'create' operations: just cache the response entity data via cacheEntityOnView
  4. For 'delete' operations: remove from cachedEntities
- Add a return field to processSyncQueue result: `conflicts: number` (count of server-wins)
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify conflict-resolver.ts exports detectAndResolveConflict. Verify sync-queue.ts calls detectAndResolveConflict for update operations.
  </verify>
  <done>
Conflicts are detected after sync by comparing updated_at timestamps. Server wins with LWW and user receives an auto-dismiss toast notification. Sync queue updates local cache with server response data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Photo queue with compression and sequential upload</name>
  <files>
    src/lib/sync/photo-uploader.ts
    src/hooks/useOfflinePhoto.ts
    src/contexts/ConnectivityContext.tsx
  </files>
  <action>
Install browser-image-compression via: `npm install browser-image-compression`

Create `src/lib/sync/photo-uploader.ts`:
- Import db and PhotoQueueItem from '@/lib/db/schema'
- Import { executeWithRetry } from '@/lib/sync/retry-strategy'
- Import imageCompression from 'browser-image-compression'
- Import toast from 'sonner'

- Export `queueOfflinePhoto(params: { entityType: string, entityId: string, file: File, fileName?: string })`:
  1. Compress the photo using browser-image-compression with options: { maxSizeMB: 1, maxWidthOrHeight: 1920, useWebWorker: true, initialQuality: 0.8 }
  2. Convert compressed result to Blob
  3. Add to db.photoQueue: { entityType, entityId, blob: compressedBlob, fileName: fileName || file.name, createdAt: Date.now(), retryCount: 0, status: 'pending' }
  4. Return the queue item id

- Export `processPhotoQueue(onProgress?: (current: number, total: number, fileName: string) => void)`:
  1. Get all items with status='pending' ordered by createdAt (FIFO)
  2. Process sequentially (one at a time — CONTEXT.md decision)
  3. For each item (index i of total):
     a. Set status='processing'
     b. Call onProgress?.(i + 1, total, item.fileName)
     c. Create FormData with blob and fileName
     d. Use executeWithRetry to upload: fetch(`/api/media/upload`, { method: 'POST', body: formData }) — include entityType and entityId as form fields
     e. On success: delete from photoQueue
     f. On final failure: update with status='failed', retryCount incremented, lastError. Show toast.error(`Foto konnte nicht hochgeladen werden: ${item.fileName} — wird erneut versucht`)
  4. Return { uploaded: number, failed: number }

- Export `getPhotoQueueCount()`: Return count of pending/processing items in photoQueue

- Export `retryFailedPhoto(itemId: number)`: Reset status to 'pending', clear lastError

- Export `discardFailedPhoto(itemId: number)`: Delete from photoQueue

Create `src/hooks/useOfflinePhoto.ts`:
- 'use client' directive
- Import queueOfflinePhoto from '@/lib/sync/photo-uploader'
- Import useConnectivity from '@/contexts/ConnectivityContext'
- Import useLiveQuery from 'dexie-react-hooks'
- Import db from '@/lib/db/schema'
- Export `useOfflinePhoto(entityType: string, entityId: string)` hook:
  - Get { isOnline } from useConnectivity()
  - Use useLiveQuery to get photo queue count for this entity: db.photoQueue.where({ entityType, entityId }).count()
  - Return:
    - `queuePhoto(file: File)`: If online, upload directly via fetch. If offline, call queueOfflinePhoto. Always compress before upload (use browser-image-compression in both paths).
    - `pendingPhotoCount`: number of photos in queue for this entity
    - `isOnline`: for callers to show appropriate UI

Modify `src/contexts/ConnectivityContext.tsx`:
- Import processPhotoQueue from '@/lib/sync/photo-uploader'
- In the handleOnline callback, after processSyncQueue completes:
  - Call processPhotoQueue() (no progress callback needed for background sync)
  - Wrap in try-catch
  - Show toast on photo upload completion if any were uploaded: toast.success(`${result.uploaded} Foto(s) synchronisiert`)
- Photo queue processes AFTER sync queue (form data is the critical payload per CONTEXT.md — photos are secondary)
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify browser-image-compression is in package.json. Verify photo-uploader.ts exports queueOfflinePhoto and processPhotoQueue. Verify ConnectivityContext processes photo queue after sync queue on reconnect.
  </verify>
  <done>
Photos are compressed client-side (1920px max, 80% JPEG) before IndexedDB storage. Sequential upload on reconnect with per-photo progress. Failed photos retry with exponential backoff. Form data syncs independently from photos (partial sync). ConnectivityContext orchestrates: sync queue first, then photo queue.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- browser-image-compression is in package.json dependencies
- src/lib/sync/conflict-resolver.ts exports detectAndResolveConflict
- src/lib/sync/photo-uploader.ts exports queueOfflinePhoto and processPhotoQueue
- src/hooks/useOfflinePhoto.ts exports useOfflinePhoto hook
- sync-queue.ts calls detectAndResolveConflict after update syncs
- ConnectivityContext processes: sync queue -> photo queue on reconnect
- Conflict toast: "Ihre Aenderungen wurden ueberschrieben" (4s auto-dismiss)
- Photo failure toast: "Foto konnte nicht hochgeladen werden" with file name
</verification>

<success_criteria>
- LWW conflict resolution compares updated_at timestamps and notifies user
- Photos compress to 1920px max / 80% JPEG before IndexedDB storage
- Photos upload sequentially on reconnect (not parallel)
- Failed photos retry with exponential backoff (8 max attempts)
- Form data syncs independently from failed photos (partial sync works)
- ConnectivityContext orchestrates full reconnect pipeline: sync queue then photos
- All 7 OFFL requirements (05-11) are addressed across the three plans
</success_criteria>

<output>
After completion, create `.planning/phases/28-offline-data-sync/28-03-SUMMARY.md`
</output>
