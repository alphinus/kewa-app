---
phase: 28-offline-data-sync
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - src/lib/db/sync-queue.ts
  - src/lib/sync/retry-strategy.ts
  - src/hooks/useOfflineSubmit.ts
  - src/hooks/useSyncStatus.ts
  - src/components/SyncStatusBadge.tsx
  - src/contexts/ConnectivityContext.tsx
autonomous: true

must_haves:
  truths:
    - "Form submissions made while offline are stored in IndexedDB sync queue"
    - "Queued operations process automatically when connectivity returns"
    - "Sync status badge in header shows pending operation count"
    - "Failed sync operations retry with exponential backoff (up to 8 attempts)"
    - "Permanently failed items remain in queue with 'failed' status for user to retry or discard"
  artifacts:
    - path: "src/lib/db/sync-queue.ts"
      provides: "Sync queue CRUD: enqueue, process, mark failed, retry, discard"
      exports: ["enqueueSyncItem", "processSyncQueue", "retryFailedItem", "discardFailedItem", "getPendingCount", "getFailedItems"]
    - path: "src/lib/sync/retry-strategy.ts"
      provides: "Exponential backoff with max 8 attempts"
      exports: ["executeWithRetry"]
    - path: "src/hooks/useOfflineSubmit.ts"
      provides: "Hook to queue form submissions for offline sync"
      exports: ["useOfflineSubmit"]
    - path: "src/hooks/useSyncStatus.ts"
      provides: "Hook returning pending count and last sync time"
      exports: ["useSyncStatus"]
    - path: "src/components/SyncStatusBadge.tsx"
      provides: "Header badge showing pending sync count"
      contains: "pendingCount"
  key_links:
    - from: "src/lib/db/sync-queue.ts"
      to: "src/lib/db/schema.ts"
      via: "Dexie syncQueue table"
      pattern: "db\\.syncQueue"
    - from: "src/lib/db/sync-queue.ts"
      to: "src/lib/sync/retry-strategy.ts"
      via: "executeWithRetry for API calls"
      pattern: "executeWithRetry"
    - from: "src/contexts/ConnectivityContext.tsx"
      to: "src/lib/db/sync-queue.ts"
      via: "processSyncQueue on online event"
      pattern: "processSyncQueue"
    - from: "src/components/SyncStatusBadge.tsx"
      to: "src/hooks/useSyncStatus.ts"
      via: "useSyncStatus hook"
      pattern: "useSyncStatus"
---

<objective>
Build the sync queue system for offline form submissions with automatic background sync on reconnect and a header status indicator.

Purpose: This enables users to submit work order updates, notes, time entries, and status changes while offline. Submissions queue in IndexedDB and sync automatically when connectivity returns. A header badge provides feedback on pending operations.
Output: Sync queue operations, retry strategy, offline submit hook, sync status hook, and header badge component.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-offline-data-sync/28-CONTEXT.md
@.planning/phases/28-offline-data-sync/28-RESEARCH.md
@.planning/phases/28-offline-data-sync/28-01-SUMMARY.md
@src/contexts/ConnectivityContext.tsx
@src/components/navigation/header.tsx
@src/lib/db/schema.ts
@src/lib/db/operations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sync queue operations and retry strategy</name>
  <files>
    src/lib/sync/retry-strategy.ts
    src/lib/db/sync-queue.ts
  </files>
  <action>
Create `src/lib/sync/retry-strategy.ts`:
- Export `wait(ms: number)`: Returns a promise that resolves after ms milliseconds
- Export `executeWithRetry<T>(fn: () => Promise<T>, maxDepth = 7)`: Executes fn, on failure retries with exponential backoff (2^depth * 10ms). Depth 0 has no delay (first attempt is immediate). Returns the result on success. On final failure (depth > maxDepth), throws the error. Total max 8 attempts (depth 0-7). Backoff sequence: 0ms, 10ms, 20ms, 40ms, 80ms, 160ms, 320ms, 640ms.
- Export `MAX_RETRY_DEPTH = 7` constant

Create `src/lib/db/sync-queue.ts`:
- Import db and SyncQueueItem from '@/lib/db/schema'
- Import executeWithRetry from '@/lib/sync/retry-strategy'
- Import toast from 'sonner'

- `enqueueSyncItem(item: Omit<SyncQueueItem, 'id' | 'createdAt' | 'retryCount' | 'status'>)`: Add to syncQueue with createdAt=Date.now(), retryCount=0, status='pending'. Return the new item id.

- `processSyncQueue()`:
  1. Get all items with status='pending' ordered by createdAt (FIFO)
  2. Process sequentially (NOT parallel — order matters for dependent mutations)
  3. For each item:
     a. Set status='processing'
     b. Call executeWithRetry(() => fetch(item.endpoint, { method: item.method, headers: {'Content-Type': 'application/json'}, body: JSON.stringify(item.payload) }))
     c. Check response.ok. If not ok, throw new Error with response status text.
     d. On success: delete item from syncQueue. Return the response JSON (needed for conflict detection in Plan 03).
     e. On final failure: update item with status='failed', lastError=error.message, retryCount incremented. Show toast.error('Synchronisierung fehlgeschlagen: ' + item.entityType). Continue to next item (don't abort queue).
  4. Return { synced: number, failed: number }

- `retryFailedItem(itemId: number)`: Reset item status to 'pending', clear lastError, set retryCount=0. Returns void.

- `discardFailedItem(itemId: number)`: Delete item from syncQueue. Returns void.

- `getPendingCount()`: Return count of items where status is 'pending' or 'processing'. Use db.syncQueue.where('status').anyOf(['pending', 'processing']).count()

- `getFailedItems()`: Return all items with status='failed'. Ordered by createdAt desc.

- `getLastSyncTime()`: Read a metadata key from localStorage (not IndexedDB — simple string). Key: 'kewa_last_sync_time'. Updated to Date.now().toString() after each successful processSyncQueue run. Return number or null.

- `setLastSyncTime()`: Write Date.now().toString() to localStorage key 'kewa_last_sync_time'.

All functions async with try-catch. Console.error on failures. Never throw from queue processing (resilient).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify sync-queue.ts exports all 6 functions. Verify retry-strategy.ts exports executeWithRetry and wait.
  </verify>
  <done>
Sync queue enqueues offline mutations, processes them sequentially with exponential backoff retry, and tracks failed items for user action. Last sync time persists in localStorage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Offline submit hook, sync status hook, badge, and auto-sync wiring</name>
  <files>
    src/hooks/useOfflineSubmit.ts
    src/hooks/useSyncStatus.ts
    src/components/SyncStatusBadge.tsx
    src/contexts/ConnectivityContext.tsx
    src/components/navigation/header.tsx
  </files>
  <action>
Create `src/hooks/useOfflineSubmit.ts`:
- 'use client' directive
- Import useConnectivity from '@/contexts/ConnectivityContext'
- Import enqueueSyncItem from '@/lib/db/sync-queue'
- Import toast from 'sonner'
- Export `useOfflineSubmit()` hook:
  - Get { isOnline } from useConnectivity()
  - Return `submitOrQueue(params: { operation, entityType, entityId, endpoint, method, payload })`:
    - If online: attempt direct fetch to endpoint with method and payload. On success return response JSON. On failure: fall through to queue.
    - If offline OR direct fetch failed: enqueue via enqueueSyncItem. Show toast.info('Aenderung wird synchronisiert, sobald die Verbindung wiederhergestellt ist'). Return { queued: true, id: queueItemId }.
  - Return `isOnline` as part of the hook return value for callers to show optimistic UI

Create `src/hooks/useSyncStatus.ts`:
- 'use client' directive
- Import useLiveQuery from 'dexie-react-hooks'
- Import db from '@/lib/db/schema'
- Import { getLastSyncTime } from '@/lib/db/sync-queue'
- Export `useSyncStatus()` hook:
  - Use useLiveQuery to get count of syncQueue items where status is 'pending' or 'processing': `db.syncQueue.where('status').anyOf(['pending', 'processing']).count()`
  - Use useState + useEffect to load lastSyncTime from localStorage (SSR-safe)
  - Return { pendingCount: count ?? 0, failedCount (from another useLiveQuery for status='failed'), lastSyncTime: number | null }

Create `src/components/SyncStatusBadge.tsx`:
- 'use client' directive
- Import useSyncStatus from '@/hooks/useSyncStatus'
- Import useConnectivity from '@/contexts/ConnectivityContext'
- Import RefreshCw icon from lucide-react
- Only render when pendingCount > 0 OR failedCount > 0
- Render a small pill badge next to the offline indicator in header:
  - If pendingCount > 0: blue background (bg-blue-100 text-blue-700 dark:bg-blue-900/30 dark:text-blue-400), show RefreshCw icon (h-3 w-3, animate-spin when processing) + count number
  - If failedCount > 0 and pendingCount === 0: red background (bg-red-100 text-red-700 dark:bg-red-900/30 dark:text-red-400), show count + "fehlgeschlagen" tooltip
- Style: rounded-full text-xs font-medium px-2 py-0.5, consistent with the existing offline badge style
- Show lastSyncTime as tooltip: "Letzte Synchronisierung: {formatted time}" using date-fns formatDistanceToNow with de locale

Modify `src/contexts/ConnectivityContext.tsx`:
- Import processSyncQueue and setLastSyncTime from '@/lib/db/sync-queue'
- In the handleOnline callback (after setting isOnline to true and showing toast):
  - Call processSyncQueue().then((result) => { if (result.synced > 0) setLastSyncTime(); })
  - Wrap in try-catch to prevent sync errors from breaking connectivity context
  - Only trigger if not initial mount

Modify `src/components/navigation/header.tsx`:
- Import SyncStatusBadge from '@/components/SyncStatusBadge'
- Add SyncStatusBadge next to the existing offline indicator (after the offline badge div, before the spacer). The badge should show regardless of online/offline state (user needs to see pending count even when back online during sync).
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify ConnectivityContext.tsx now imports and calls processSyncQueue on reconnect. Verify header.tsx renders SyncStatusBadge. Verify useSyncStatus uses useLiveQuery for reactive count.
  </verify>
  <done>
Offline form submissions queue automatically. Sync triggers on reconnect via ConnectivityContext. Header badge shows pending/failed counts with reactive updates. useOfflineSubmit provides a single API for callers to submit-or-queue transparently.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- src/lib/db/sync-queue.ts exports enqueueSyncItem, processSyncQueue, retryFailedItem, discardFailedItem, getPendingCount, getFailedItems
- src/lib/sync/retry-strategy.ts exports executeWithRetry with exponential backoff
- src/hooks/useOfflineSubmit.ts provides transparent online/offline submission
- src/hooks/useSyncStatus.ts provides reactive pending count via useLiveQuery
- src/components/SyncStatusBadge.tsx renders pending count badge in header
- ConnectivityContext triggers processSyncQueue on reconnect event
- Header renders SyncStatusBadge component
</verification>

<success_criteria>
- Sync queue stores offline mutations with operation, endpoint, method, and payload
- Queue processes sequentially on reconnect with exponential backoff retry
- Failed items persist with error details for retry or discard
- Header badge shows live pending count (reactive via useLiveQuery)
- useOfflineSubmit transparently handles online direct-submit vs offline queue
- No app crashes from sync failures (resilient error handling throughout)
</success_criteria>

<output>
After completion, create `.planning/phases/28-offline-data-sync/28-02-SUMMARY.md`
</output>
