---
phase: 28-offline-data-sync
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/tasks/TaskForm.tsx
  - src/components/tasks/CompleteTaskModal.tsx
  - src/components/photos/PhotoUpload.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Task edit form uses useOfflineSubmit to queue submissions when offline"
    - "Task completion modal uses useOfflineSubmit to queue status update when offline"
    - "Photo upload component uses useOfflinePhoto to queue photos when offline"
    - "Form payloads include updated_at timestamp for conflict detection"
    - "Queued submissions show a toast confirming offline queue"
  artifacts:
    - path: "src/components/tasks/TaskForm.tsx"
      provides: "Offline-capable task edit form"
      contains: "useOfflineSubmit"
    - path: "src/components/tasks/CompleteTaskModal.tsx"
      provides: "Offline-capable task completion"
      contains: "useOfflineSubmit"
    - path: "src/components/photos/PhotoUpload.tsx"
      provides: "Offline-capable photo upload"
      contains: "useOfflinePhoto"
  key_links:
    - from: "src/components/tasks/TaskForm.tsx"
      to: "src/hooks/useOfflineSubmit.ts"
      via: "submitOrQueue({ operation: 'update', ... })"
      pattern: "submitOrQueue"
    - from: "src/components/tasks/CompleteTaskModal.tsx"
      to: "src/hooks/useOfflineSubmit.ts"
      via: "submitOrQueue({ operation: 'update', ... })"
      pattern: "submitOrQueue"
    - from: "src/components/photos/PhotoUpload.tsx"
      to: "src/hooks/useOfflinePhoto.ts"
      via: "queuePhoto(file)"
      pattern: "queuePhoto"
---

<objective>
Wire offline submission into task forms and photo upload so that form submissions and photos queue when offline and sync on reconnect.

Purpose: Phase 28 built useOfflineSubmit and useOfflinePhoto hooks but no forms use them. Users cannot submit any data offline. This plan closes Gap 2 (form submission) and Gap 3 (photo capture) from verification.

Output: Task forms that transparently queue offline submissions, and photo upload that queues photos for upload on reconnect.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-offline-data-sync/28-CONTEXT.md
@.planning/phases/28-offline-data-sync/28-02-SUMMARY.md
@.planning/phases/28-offline-data-sync/28-03-SUMMARY.md

Key infrastructure files (read these first):
@src/hooks/useOfflineSubmit.ts -- useOfflineSubmit() returns { submitOrQueue, isOnline }
@src/hooks/useOfflinePhoto.ts -- useOfflinePhoto(entityType, entityId) returns { queuePhoto, pendingPhotoCount, isOnline }
@src/lib/db/schema.ts -- SyncQueueItem interface (operation, entityType, entityId, endpoint, method, payload)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire useOfflineSubmit into TaskForm and CompleteTaskModal</name>
  <files>
    src/components/tasks/TaskForm.tsx
    src/components/tasks/CompleteTaskModal.tsx
  </files>
  <action>
    **TaskForm.tsx (edit mode):**

    1. Add import: `import { useOfflineSubmit } from '@/hooks/useOfflineSubmit'`
    2. Add in component body: `const { submitOrQueue } = useOfflineSubmit()`
    3. Find the existing save handler that calls `fetch` to update/create a task. It will look like:
       ```
       const response = await fetch(`/api/tasks/${task.id}`, {
         method: 'PUT',  // or PATCH
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify(payload),
       })
       ```
    4. For **edit mode only** (mode === 'edit'), replace the direct fetch with:
       ```
       const result = await submitOrQueue({
         operation: 'update',
         entityType: 'task',
         entityId: task!.id,
         endpoint: `/api/tasks/${task!.id}`,
         method: 'PUT',
         payload: { ...payload, updated_at: task!.updated_at },
       })
       ```
    5. Handle the result: if `result.queued`, call `onSave(task as unknown as Task)` with the existing task data (optimistic). If `result.data`, call `onSave(result.data.task)`.
    6. For **create mode**, keep the existing direct fetch. Creating new tasks offline is NOT in scope per CONTEXT.md ("NOT: creating new properties, units, suppliers, or other master data"). Task creation is similar -- keep it online-only.
    7. Add `updated_at` to the payload so the sync queue can detect conflicts. Read the current task's `updated_at` from the task prop and include it.

    **CompleteTaskModal.tsx:**

    1. Add import: `import { useOfflineSubmit } from '@/hooks/useOfflineSubmit'`
    2. Add in component body: `const { submitOrQueue } = useOfflineSubmit()`
    3. Find the existing completion handler that calls `fetch` to mark the task complete. It will look like:
       ```
       const response = await fetch(`/api/tasks/${task.id}/complete`, {
         method: 'POST',
         headers: { 'Content-Type': 'application/json' },
         body: JSON.stringify({ completion_note: note }),
       })
       ```
    4. Replace with:
       ```
       const result = await submitOrQueue({
         operation: 'update',
         entityType: 'task',
         entityId: task.id,
         endpoint: `/api/tasks/${task.id}/complete`,
         method: 'POST',
         payload: { completion_note: note, updated_at: task.updated_at },
       })
       ```
    5. Handle result: if `result.queued`, still call `onComplete()` (optimistic UI). If `result.data`, call `onComplete()` normally.
    6. Keep existing error handling but add a fallback to queue on network errors.

    IMPORTANT: Read each file fully before modifying. Understand the exact fetch call structure, response handling, and error flows.
    IMPORTANT: Do not change the create-mode flow in TaskForm. Only edit mode gets offline queueing.
    IMPORTANT: Include `updated_at` in payloads for conflict detection. The task prop should have this field from the API response.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no TypeScript errors.
    Grep for `useOfflineSubmit` in both files.
    Grep for `submitOrQueue` in both files.
    Grep for `updated_at` in both file payloads.
  </verify>
  <done>
    TaskForm (edit mode) and CompleteTaskModal queue submissions via useOfflineSubmit with updated_at timestamps for conflict detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire useOfflinePhoto into PhotoUpload component</name>
  <files>
    src/components/photos/PhotoUpload.tsx
  </files>
  <action>
    1. Add import: `import { useOfflinePhoto } from '@/hooks/useOfflinePhoto'`
    2. The PhotoUpload component receives `taskId` as a prop. Add `useOfflinePhoto('task', taskId)` in the component body:
       ```
       const { queuePhoto, pendingPhotoCount, isOnline } = useOfflinePhoto('task', taskId)
       ```
    3. Find the existing upload handler. It will compress the image and then call `fetch` to upload via FormData to something like `/api/photos`. The existing flow:
       - User selects file -> compress -> preview -> confirm upload -> fetch POST
    4. In the upload function, replace the direct fetch upload with offline-aware logic:
       ```
       if (isOnline) {
         // Keep existing direct upload via fetch + FormData
         // (existing code)
       } else {
         // Queue for later upload
         await queuePhoto(selectedFile)
         toast.info('Foto wird hochgeladen, sobald die Verbindung wiederhergestellt ist', { duration: 4000 })
         // Reset upload state
         setUploadState('success')
         // Don't call onUploadComplete since photo isn't actually on server yet
       }
       ```
    5. If the online upload fails (catch block), also fall back to queuePhoto:
       ```
       } catch (error) {
         if (!isOnline) {
           await queuePhoto(selectedFile)
           toast.info('Foto wird hochgeladen, sobald die Verbindung wiederhergestellt ist')
         } else {
           // existing error handling
         }
       }
       ```
    6. Show pending photo count badge if pendingPhotoCount > 0:
       Add a small indicator near the upload area:
       ```
       {pendingPhotoCount > 0 && (
         <p className="text-xs text-amber-600 dark:text-amber-400">
           {pendingPhotoCount} Foto(s) warten auf Upload
         </p>
       )}
       ```

    IMPORTANT: Read the full PhotoUpload.tsx file first. Understand the complete upload flow including compression, retry logic, and state management.
    IMPORTANT: The existing compression in PhotoUpload uses `compressImage`. The useOfflinePhoto hook also compresses via `compressImage`. When offline, let the hook handle compression. When online, keep the existing compression flow.
    IMPORTANT: Keep the existing online upload path completely intact. Only add the offline branch.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm no TypeScript errors.
    Grep for `useOfflinePhoto` in PhotoUpload.tsx.
    Grep for `queuePhoto` in PhotoUpload.tsx.
    Grep for `pendingPhotoCount` in PhotoUpload.tsx.
  </verify>
  <done>
    PhotoUpload component queues photos via useOfflinePhoto when offline, shows pending count indicator, and falls back to queue on upload failure.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. TaskForm.tsx imports and uses useOfflineSubmit for edit mode
3. CompleteTaskModal.tsx imports and uses useOfflineSubmit
4. PhotoUpload.tsx imports and uses useOfflinePhoto
5. All form payloads include updated_at for conflict detection
6. No existing online functionality is broken
</verification>

<success_criteria>
- `grep -r "useOfflineSubmit" src/components/` returns TaskForm.tsx and CompleteTaskModal.tsx
- `grep -r "useOfflinePhoto" src/components/` returns PhotoUpload.tsx
- `grep -r "submitOrQueue" src/components/` returns TaskForm.tsx and CompleteTaskModal.tsx
- `grep -r "updated_at" src/components/tasks/` shows timestamp in payloads
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/28-offline-data-sync/28-05-SUMMARY.md`
</output>
