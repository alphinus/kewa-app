---
phase: 035-schema-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - 35-01
  - 35-02
files_modified:
  - supabase/migrations/076_rls_helpers.sql
  - supabase/migrations/077_org_sync_triggers.sql
autonomous: true
requirements:
  - SCHEMA-05
  - SCHEMA-07

must_haves:
  truths:
    - "set_org_context('some-uuid') sets the transaction-local config so current_organization_id() returns that UUID"
    - "current_organization_id() returns NULL (not error) when no org context is set"
    - "Inserting a building with a property_id auto-populates building.organization_id from that property"
    - "Updating a building's property_id updates its organization_id to match the new property"
    - "Trigger fires BEFORE INSERT OR UPDATE OF property_id — not on every UPDATE (avoids performance hit)"
    - "No infinite trigger loop: trigger sets NEW.organization_id in-memory, not via UPDATE statement"
  artifacts:
    - path: "supabase/migrations/076_rls_helpers.sql"
      provides: "current_organization_id() and set_org_context() functions"
      contains: "CREATE OR REPLACE FUNCTION current_organization_id"
    - path: "supabase/migrations/077_org_sync_triggers.sql"
      provides: "BEFORE INSERT/UPDATE triggers for org_id propagation"
      contains: "CREATE TRIGGER trg_buildings_org_id"
  key_links:
    - from: "set_org_context()"
      to: "current_organization_id()"
      via: "set_config('app.current_organization_id', org_id::text, true)"
      pattern: "set_config.*true"
    - from: "trg_buildings_org_id"
      to: "properties.organization_id"
      via: "SELECT organization_id INTO NEW.organization_id FROM properties WHERE id = NEW.property_id"
      pattern: "SELECT organization_id INTO NEW.organization_id"
    - from: "trg_units_org_id"
      to: "buildings.organization_id"
      via: "SELECT organization_id INTO NEW.organization_id FROM buildings WHERE id = NEW.building_id"
      pattern: "trg_units_org_id"
---

<objective>
Create the two function-layer migrations: RLS helper functions (076) and org_id sync triggers (077). The helpers enable future RLS policies; the triggers make org_id propagation automatic and mandatory at the database level.

Purpose: Without these, every API route inserting buildings/units/tasks would need to manually pass organization_id — trivially forgotten. Triggers enforce it at DB level. RLS functions are the building blocks Phase 37 will use for all policies.
Output: Migration files 076 and 077 — pure function/trigger DDL, no data changes.
</objective>

<execution_context>
@C:/Users/Mario Giacchino/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mario Giacchino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/035-schema-foundation/35-CONTEXT.md
@.planning/phases/035-schema-foundation/35-RESEARCH.md
@.planning/phases/035-schema-foundation/35-01-SUMMARY.md
@.planning/phases/035-schema-foundation/35-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create 076_rls_helpers.sql — current_organization_id() and set_org_context()</name>
  <files>supabase/migrations/076_rls_helpers.sql</files>
  <action>
Create `supabase/migrations/076_rls_helpers.sql` with two PostgreSQL functions. These functions are the foundation for all future RLS policies (Phase 37).

**Critical implementation details (from RESEARCH.md):**
1. `set_config(..., true)` — the `true` parameter means LOCAL (transaction-scoped). Using `false` would be session-level and poison the PgBouncer connection pool. This is a locked requirement.
2. `NULLIF(current_setting(..., true), '')::UUID` — the NULLIF prevents empty string `''` from causing a UUID cast error. The second `true` in current_setting means "return NULL if not set" (not raise error).
3. Both functions use `SECURITY DEFINER` — required so RLS policies can call them without privilege escalation issues.
4. `current_organization_id()` is `STABLE` — it reads from a config that doesn't change within a transaction, so PostgreSQL can optimize multiple calls.

**Functions to create:**
```sql
-- KEWA v4.0: Multi-Tenant Schema Foundation
-- Migration: 076_rls_helpers.sql
-- Creates: current_organization_id(), set_org_context() RPC
-- Requirements: SCHEMA-05
-- Phase 35: Schema Foundation
--
-- CRITICAL: set_config uses is_local=true for transaction scope.
-- Using false would contaminate PgBouncer connection pool.

-- current_organization_id() — reads per-transaction context
-- Called from RLS policies: WHERE organization_id = current_organization_id()
-- Returns NULL (not error) if no context set — RLS query returns empty set, not error
CREATE OR REPLACE FUNCTION current_organization_id()
RETURNS UUID AS $$
  SELECT NULLIF(current_setting('app.current_organization_id', true), '')::UUID;
$$ LANGUAGE SQL STABLE SECURITY DEFINER;

COMMENT ON FUNCTION current_organization_id() IS
  'Returns the organization UUID set for the current transaction via set_org_context().
   Returns NULL if no context is set. Called by RLS policies for data isolation.
   SECURITY DEFINER: can be called safely from RLS without privilege escalation.';

-- set_org_context(org_id) — called via supabase.rpc() from API routes BEFORE any data query
-- true = LOCAL flag = transaction-scoped ONLY
-- This is safe with PgBouncer: the setting is cleared at transaction end
CREATE OR REPLACE FUNCTION set_org_context(org_id UUID)
RETURNS void AS $$
BEGIN
  PERFORM set_config('app.current_organization_id', org_id::text, true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

COMMENT ON FUNCTION set_org_context(UUID) IS
  'Sets the current organization context for the transaction.
   Use is_local=true (third parameter) to ensure transaction scope.
   Called via supabase.rpc("set_org_context", {org_id: "..."}) in API routes.
   PgBouncer-safe: setting is cleared at transaction end.';
```

Add a verification comment at the end:
```sql
-- Verification:
-- SELECT set_org_context('00000000-0000-0000-0000-000000000001');
-- SELECT current_organization_id();
-- Expected: returns '00000000-0000-0000-0000-000000000001'::UUID
--
-- Without context:
-- SELECT current_organization_id();
-- Expected: returns NULL (not error)
```
  </action>
  <verify>
Run: `node -e "const sql=require('fs').readFileSync('supabase/migrations/076_rls_helpers.sql','utf8'); const checks=['CREATE OR REPLACE FUNCTION current_organization_id','CREATE OR REPLACE FUNCTION set_org_context','SECURITY DEFINER','NULLIF(current_setting','set_config.*true'.replace('.*','(')); ['current_organization_id','set_org_context','SECURITY DEFINER','NULLIF(current_setting'].forEach(c=>{ if(!sql.includes(c)) throw new Error('MISSING: '+c); }); if(!sql.includes(\"'app.current_organization_id'\")) throw new Error('Wrong config key'); console.log('076 OK');"`

Verify the LOCAL flag: `node -e "const sql=require('fs').readFileSync('supabase/migrations/076_rls_helpers.sql','utf8'); if(!sql.includes('set_config') || !sql.includes(', true)')) throw new Error('Missing LOCAL flag in set_config call'); console.log('LOCAL flag OK');"`
  </verify>
  <done>
076_rls_helpers.sql exists with both functions, both SECURITY DEFINER, current_organization_id uses NULLIF pattern, set_org_context uses set_config with true (LOCAL) flag, and both have COMMENT ON FUNCTION.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create 077_org_sync_triggers.sql — BEFORE INSERT/UPDATE triggers for org_id propagation</name>
  <files>supabase/migrations/077_org_sync_triggers.sql</files>
  <action>
Create `supabase/migrations/077_org_sync_triggers.sql` with BEFORE INSERT/UPDATE triggers for the property hierarchy. These triggers auto-populate organization_id from parent tables when a child row is inserted.

**Critical anti-patterns to avoid (from RESEARCH.md Pitfall 3):**
1. NEVER use `AFTER UPDATE ON buildings` — use `BEFORE INSERT OR UPDATE OF property_id` (column-specific)
2. NEVER run `UPDATE buildings SET organization_id = ...` inside the trigger — this fires the trigger again creating infinite recursion
3. The correct pattern: set `NEW.organization_id` in-memory in a BEFORE trigger — no recursive fire

**Trigger hierarchy to implement:**
- buildings ← properties (property_id FK)
- units ← buildings (building_id FK)
- rooms ← units (unit_id FK)
- projects ← units (unit_id FK)
- tasks ← projects (project_id FK)
- work_orders ← tasks (task_id FK)
- renovation_projects ← units (unit_id FK)
- offers ← work_orders (work_order_id FK)
- invoices ← work_orders (work_order_id FK — check actual FK column name in migration 018)
- expenses ← projects or work_orders (check migration 019 for actual FK column)
- payments ← invoices (invoice_id FK)
- change_orders ← work_orders (work_order_id FK)
- change_order_versions ← change_orders (change_order_id FK)
- change_order_photos ← change_orders (change_order_id FK)
- change_order_approval_tokens ← change_orders (change_order_id FK)
- inspection_defects ← inspections (inspection_id FK)
- inspection_portal_tokens ← inspections (inspection_id FK)
- tickets ← units (unit_id FK)
- ticket_messages ← tickets (ticket_id FK)
- ticket_attachments ← tickets (ticket_id FK)
- ticket_work_orders ← tickets OR work_orders (check migration 070)
- work_order_events ← work_orders (work_order_id FK)
- kb_articles ← kb_categories (category_id FK)
- kb_articles_history ← kb_articles (article_id FK)
- kb_workflow_transitions ← kb_articles (article_id FK)
- kb_attachments ← kb_articles (article_id FK)
- deliveries ← purchase_orders (purchase_order_id FK)
- purchase_order_allocations ← purchase_orders (purchase_order_id FK)

**Polymorphic tables (no single parent trigger — skip triggers, backfill manually in Phase 36):**
- media (entity_type/entity_id — no single FK to join)
- audit_logs (entity_type/entity_id — no single FK)
- comments (entity_type/entity_id — no single FK)
- condition_history (entity_type/entity_id — no single FK)
- storage_metadata (entity_type/entity_id — no single FK)

**Direct org tables (no parent to inherit from — backfill in Phase 36):**
- partners, kb_categories, kb_dashboard_shortcuts, push_subscriptions, notification_preferences, notifications, user_notifications, magic_link_tokens, approval_thresholds, inventory_movements, app_settings, inspection_templates

**Template for each trigger function:**
```sql
CREATE OR REPLACE FUNCTION sync_org_id_from_{parent_table_name}()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.{parent_id_column} IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM {parent_table} WHERE id = NEW.{parent_id_column};
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_{child_table}_org_id
  BEFORE INSERT OR UPDATE OF {parent_id_column} ON {child_table}
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_{parent_table_name}();
```

**Full implementation for the primary hierarchy:**

```sql
-- KEWA v4.0: Multi-Tenant Schema Foundation
-- Migration: 077_org_sync_triggers.sql
-- BEFORE INSERT/UPDATE triggers: auto-propagate organization_id through hierarchy
-- Requirements: SCHEMA-07
-- Phase 35: Schema Foundation
--
-- IMPORTANT: All triggers use BEFORE (not AFTER) to set NEW.organization_id in-memory.
-- Column-specific UPDATE triggers prevent infinite loops:
--   BEFORE INSERT OR UPDATE OF property_id (fires only when property_id changes, not org_id)
-- NEVER update the same table inside the trigger function — use NEW.field instead.

-- ============================================================
-- LEVEL 1: buildings inherits from properties
-- ============================================================
CREATE OR REPLACE FUNCTION sync_org_id_from_property()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.property_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM properties WHERE id = NEW.property_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_buildings_org_id ON buildings;
CREATE TRIGGER trg_buildings_org_id
  BEFORE INSERT OR UPDATE OF property_id ON buildings
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_property();

-- ============================================================
-- LEVEL 2: units inherits from buildings
-- ============================================================
CREATE OR REPLACE FUNCTION sync_org_id_from_building()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.building_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM buildings WHERE id = NEW.building_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_units_org_id ON units;
CREATE TRIGGER trg_units_org_id
  BEFORE INSERT OR UPDATE OF building_id ON units
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_building();

-- ============================================================
-- LEVEL 3: rooms, projects, renovation_projects inherit from units
-- ============================================================
CREATE OR REPLACE FUNCTION sync_org_id_from_unit()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.unit_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM units WHERE id = NEW.unit_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_rooms_org_id ON rooms;
CREATE TRIGGER trg_rooms_org_id
  BEFORE INSERT OR UPDATE OF unit_id ON rooms
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_unit();

DROP TRIGGER IF EXISTS trg_projects_org_id ON projects;
CREATE TRIGGER trg_projects_org_id
  BEFORE INSERT OR UPDATE OF unit_id ON projects
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_unit();

DROP TRIGGER IF EXISTS trg_renovation_projects_org_id ON renovation_projects;
CREATE TRIGGER trg_renovation_projects_org_id
  BEFORE INSERT OR UPDATE OF unit_id ON renovation_projects
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_unit();

DROP TRIGGER IF EXISTS trg_tickets_org_id ON tickets;
CREATE TRIGGER trg_tickets_org_id
  BEFORE INSERT OR UPDATE OF unit_id ON tickets
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_unit();

-- ============================================================
-- LEVEL 4: tasks inherits from projects
-- ============================================================
CREATE OR REPLACE FUNCTION sync_org_id_from_project()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.project_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM projects WHERE id = NEW.project_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_tasks_org_id ON tasks;
CREATE TRIGGER trg_tasks_org_id
  BEFORE INSERT OR UPDATE OF project_id ON tasks
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_project();

-- ============================================================
-- LEVEL 5: work_orders inherit from tasks
-- ============================================================
CREATE OR REPLACE FUNCTION sync_org_id_from_task()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.task_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM tasks WHERE id = NEW.task_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_work_orders_org_id ON work_orders;
CREATE TRIGGER trg_work_orders_org_id
  BEFORE INSERT OR UPDATE OF task_id ON work_orders
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_task();

-- ============================================================
-- LEVEL 6: work_order children inherit from work_orders
-- ============================================================
CREATE OR REPLACE FUNCTION sync_org_id_from_work_order()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.work_order_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM work_orders WHERE id = NEW.work_order_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_work_order_events_org_id ON work_order_events;
CREATE TRIGGER trg_work_order_events_org_id
  BEFORE INSERT OR UPDATE OF work_order_id ON work_order_events
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_work_order();

DROP TRIGGER IF EXISTS trg_offers_org_id ON offers;
CREATE TRIGGER trg_offers_org_id
  BEFORE INSERT OR UPDATE OF work_order_id ON offers
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_work_order();

DROP TRIGGER IF EXISTS trg_change_orders_org_id ON change_orders;
CREATE TRIGGER trg_change_orders_org_id
  BEFORE INSERT OR UPDATE OF work_order_id ON change_orders
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_work_order();

DROP TRIGGER IF EXISTS trg_magic_link_tokens_org_id ON magic_link_tokens;
CREATE TRIGGER trg_magic_link_tokens_org_id
  BEFORE INSERT OR UPDATE OF work_order_id ON magic_link_tokens
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_work_order();

-- ============================================================
-- LEVEL 7: change_order children, invoice children, ticket children
-- ============================================================
CREATE OR REPLACE FUNCTION sync_org_id_from_change_order()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.change_order_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM change_orders WHERE id = NEW.change_order_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_change_order_versions_org_id ON change_order_versions;
CREATE TRIGGER trg_change_order_versions_org_id
  BEFORE INSERT OR UPDATE OF change_order_id ON change_order_versions
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_change_order();

DROP TRIGGER IF EXISTS trg_change_order_photos_org_id ON change_order_photos;
CREATE TRIGGER trg_change_order_photos_org_id
  BEFORE INSERT OR UPDATE OF change_order_id ON change_order_photos
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_change_order();

DROP TRIGGER IF EXISTS trg_change_order_approval_tokens_org_id ON change_order_approval_tokens;
CREATE TRIGGER trg_change_order_approval_tokens_org_id
  BEFORE INSERT OR UPDATE OF change_order_id ON change_order_approval_tokens
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_change_order();

-- invoices — check migration 018 for actual FK column name (work_order_id or project_id)
-- Using work_order_id as primary FK; if invoices can also link to projects, add second trigger
CREATE OR REPLACE FUNCTION sync_org_id_for_invoice()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.work_order_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM work_orders WHERE id = NEW.work_order_id;
  ELSIF NEW.project_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM projects WHERE id = NEW.project_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_invoices_org_id ON invoices;
CREATE TRIGGER trg_invoices_org_id
  BEFORE INSERT OR UPDATE OF work_order_id, project_id ON invoices
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_for_invoice();

-- expenses — similar dual-parent pattern
CREATE OR REPLACE FUNCTION sync_org_id_for_expense()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.project_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM projects WHERE id = NEW.project_id;
  ELSIF NEW.work_order_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM work_orders WHERE id = NEW.work_order_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_expenses_org_id ON expenses;
CREATE TRIGGER trg_expenses_org_id
  BEFORE INSERT OR UPDATE OF project_id, work_order_id ON expenses
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_for_expense();

-- payments inherit from invoices
CREATE OR REPLACE FUNCTION sync_org_id_from_invoice()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.invoice_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM invoices WHERE id = NEW.invoice_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_payments_org_id ON payments;
CREATE TRIGGER trg_payments_org_id
  BEFORE INSERT OR UPDATE OF invoice_id ON payments
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_invoice();

-- ticket children inherit from tickets
CREATE OR REPLACE FUNCTION sync_org_id_from_ticket()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.ticket_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM tickets WHERE id = NEW.ticket_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_ticket_messages_org_id ON ticket_messages;
CREATE TRIGGER trg_ticket_messages_org_id
  BEFORE INSERT OR UPDATE OF ticket_id ON ticket_messages
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_ticket();

DROP TRIGGER IF EXISTS trg_ticket_attachments_org_id ON ticket_attachments;
CREATE TRIGGER trg_ticket_attachments_org_id
  BEFORE INSERT OR UPDATE OF ticket_id ON ticket_attachments
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_ticket();

-- inspections — may link to units or work_orders; check migration 059
CREATE OR REPLACE FUNCTION sync_org_id_for_inspection()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.unit_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM units WHERE id = NEW.unit_id;
  ELSIF NEW.work_order_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM work_orders WHERE id = NEW.work_order_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_inspections_org_id ON inspections;
CREATE TRIGGER trg_inspections_org_id
  BEFORE INSERT OR UPDATE OF unit_id, work_order_id ON inspections
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_for_inspection();

CREATE OR REPLACE FUNCTION sync_org_id_from_inspection()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.inspection_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM inspections WHERE id = NEW.inspection_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_inspection_defects_org_id ON inspection_defects;
CREATE TRIGGER trg_inspection_defects_org_id
  BEFORE INSERT OR UPDATE OF inspection_id ON inspection_defects
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_inspection();

DROP TRIGGER IF EXISTS trg_inspection_portal_tokens_org_id ON inspection_portal_tokens;
CREATE TRIGGER trg_inspection_portal_tokens_org_id
  BEFORE INSERT OR UPDATE OF inspection_id ON inspection_portal_tokens
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_inspection();

-- purchase_order children
CREATE OR REPLACE FUNCTION sync_org_id_from_purchase_order()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.purchase_order_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM purchase_orders WHERE id = NEW.purchase_order_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_deliveries_org_id ON deliveries;
CREATE TRIGGER trg_deliveries_org_id
  BEFORE INSERT OR UPDATE OF purchase_order_id ON deliveries
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_purchase_order();

DROP TRIGGER IF EXISTS trg_purchase_order_allocations_org_id ON purchase_order_allocations;
CREATE TRIGGER trg_purchase_order_allocations_org_id
  BEFORE INSERT OR UPDATE OF purchase_order_id ON purchase_order_allocations
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_purchase_order();

-- task_dependencies inherits from tasks (use task_id — check actual FK column in migration 012)
CREATE OR REPLACE FUNCTION sync_org_id_from_task_dep()
RETURNS TRIGGER AS $$
BEGIN
  -- task_dependencies has task_id FK — use it
  IF NEW.task_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM tasks WHERE id = NEW.task_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_task_dependencies_org_id ON task_dependencies;
CREATE TRIGGER trg_task_dependencies_org_id
  BEFORE INSERT OR UPDATE OF task_id ON task_dependencies
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_task_dep();

-- kb_articles inherit from kb_categories
CREATE OR REPLACE FUNCTION sync_org_id_from_kb_category()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.category_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM kb_categories WHERE id = NEW.category_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_kb_articles_org_id ON kb_articles;
CREATE TRIGGER trg_kb_articles_org_id
  BEFORE INSERT OR UPDATE OF category_id ON kb_articles
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_kb_category();

-- kb children inherit from kb_articles
CREATE OR REPLACE FUNCTION sync_org_id_from_kb_article()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.article_id IS NOT NULL THEN
    SELECT organization_id INTO NEW.organization_id
    FROM kb_articles WHERE id = NEW.article_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_kb_articles_history_org_id ON kb_articles_history;
CREATE TRIGGER trg_kb_articles_history_org_id
  BEFORE INSERT OR UPDATE OF article_id ON kb_articles_history
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_kb_article();

DROP TRIGGER IF EXISTS trg_kb_workflow_transitions_org_id ON kb_workflow_transitions;
CREATE TRIGGER trg_kb_workflow_transitions_org_id
  BEFORE INSERT OR UPDATE OF article_id ON kb_workflow_transitions
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_kb_article();

DROP TRIGGER IF EXISTS trg_kb_attachments_org_id ON kb_attachments;
CREATE TRIGGER trg_kb_attachments_org_id
  BEFORE INSERT OR UPDATE OF article_id ON kb_attachments
  FOR EACH ROW EXECUTE FUNCTION sync_org_id_from_kb_article();
```

**EXECUTOR NOTE:** Before writing this file, read migrations 012, 018, 019, 059, 070 to verify the exact FK column names (task_id, work_order_id, project_id, inspection_id, unit_id etc.) match what's actually in those tables. Adjust trigger column lists accordingly. If invoices has only work_order_id (not project_id), simplify the trigger. Use `DROP TRIGGER IF EXISTS` before `CREATE TRIGGER` for idempotency.
  </action>
  <verify>
Count trigger definitions: `node -e "const sql=require('fs').readFileSync('supabase/migrations/077_org_sync_triggers.sql','utf8'); const t=(sql.match(/CREATE TRIGGER/g)||[]).length; console.log('Triggers:',t,'(expect 25+)');"`

Verify BEFORE not AFTER: `node -e "const sql=require('fs').readFileSync('supabase/migrations/077_org_sync_triggers.sql','utf8'); if(sql.includes('AFTER UPDATE ON') || sql.includes('AFTER INSERT ON')) throw new Error('Found AFTER trigger — must use BEFORE'); console.log('All BEFORE triggers OK');"`

Verify no UPDATE inside trigger body: `node -e "const sql=require('fs').readFileSync('supabase/migrations/077_org_sync_triggers.sql','utf8'); const fnBodies=sql.split('LANGUAGE plpgsql'); fnBodies.slice(0,-1).forEach((b,i)=>{ const body=b.split('BEGIN').pop()||''; if(body.includes('UPDATE buildings') || body.includes('UPDATE units') || body.includes('UPDATE tasks')) throw new Error('Recursive UPDATE in trigger body at segment '+i); }); console.log('No recursive UPDATEs found');"`

Verify trg_buildings_org_id exists: `node -e "const sql=require('fs').readFileSync('supabase/migrations/077_org_sync_triggers.sql','utf8'); if(!sql.includes('trg_buildings_org_id')) throw new Error('Missing trg_buildings_org_id'); if(!sql.includes('trg_units_org_id')) throw new Error('Missing trg_units_org_id'); console.log('Core hierarchy triggers present');"`
  </verify>
  <done>
076_rls_helpers.sql: Both functions exist with SECURITY DEFINER, NULLIF pattern on current_organization_id, set_config with true (LOCAL) flag on set_org_context.

077_org_sync_triggers.sql: 25+ triggers exist, all BEFORE (not AFTER), column-specific (UPDATE OF {fk_column}), no recursive UPDATE statements inside trigger bodies, DROP TRIGGER IF EXISTS before each CREATE TRIGGER.
  </done>
</task>

</tasks>

<verification>
1. 076_rls_helpers.sql exists with current_organization_id() and set_org_context()
2. current_organization_id() uses NULLIF pattern and STABLE SECURITY DEFINER
3. set_org_context() uses set_config with third param = true (LOCAL)
4. 077_org_sync_triggers.sql exists with triggers for full hierarchy
5. All triggers are BEFORE INSERT OR UPDATE OF {specific_column}
6. No UPDATE {same_table} inside any trigger body
7. Both files use CREATE OR REPLACE (idempotent)
8. DROP TRIGGER IF EXISTS before each CREATE TRIGGER
</verification>

<success_criteria>
- 076: Two functions, both SECURITY DEFINER, correct NULLIF + LOCAL patterns
- 077: 25+ triggers covering full property→building→unit→project→task→work_order chain
- Zero infinite-loop trigger risks
- Both files idempotent
</success_criteria>

<output>
After completion, create `.planning/phases/035-schema-foundation/35-03-SUMMARY.md`
</output>
