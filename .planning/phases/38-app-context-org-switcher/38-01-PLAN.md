---
phase: 38-app-context-org-switcher
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/index.ts
  - src/lib/permissions.ts
  - src/app/api/organizations/route.ts
  - src/app/api/mandates/route.ts
  - src/app/api/properties/route.ts
autonomous: true
requirements: [CTX-01, CTX-02, CTX-04]

must_haves:
  truths:
    - "GET /api/organizations returns the current user's available organizations with isDefault flag"
    - "GET /api/mandates returns mandates scoped to the current organization"
    - "GET /api/properties accepts optional mandate_id query param to filter by mandate"
    - "hauswart role can access /dashboard routes via isInternalRole()"
  artifacts:
    - path: "src/app/api/organizations/route.ts"
      provides: "Available organizations for current user"
      exports: ["GET"]
    - path: "src/app/api/mandates/route.ts"
      provides: "Mandates for current organization"
      exports: ["GET"]
    - path: "src/types/index.ts"
      provides: "Organization and Mandate TypeScript types"
      contains: "Organization"
    - path: "src/lib/permissions.ts"
      provides: "hauswart included in internal roles"
      contains: "hauswart"
  key_links:
    - from: "src/app/api/organizations/route.ts"
      to: "organization_members JOIN organizations"
      via: "createPublicClient() query"
      pattern: "organization_members"
    - from: "src/app/api/mandates/route.ts"
      to: "mandates table"
      via: "createPublicClient() query"
      pattern: "mandates"
    - from: "src/app/api/properties/route.ts"
      to: "properties table"
      via: "mandate_id query param filter"
      pattern: "mandate_id"
---

<objective>
Create the TypeScript types, API endpoints, and permissions fix that the context providers (Plan 02) and UI components (Plan 03) depend on.

Purpose: Establish the data layer — types for Organization/Mandate, API endpoints for fetching available orgs and mandates, mandate filtering on properties, and the hauswart role fix (D7).
Output: Two new API routes, updated types, updated permissions, updated properties route.
</objective>

<execution_context>
@C:/Users/Mario Giacchino/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mario Giacchino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-app-context-org-switcher/38-CONTEXT.md
@.planning/phases/38-app-context-org-switcher/38-RESEARCH.md

@src/types/index.ts
@src/lib/permissions.ts
@src/app/api/properties/route.ts
@src/lib/supabase/with-org.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Organization/Mandate types and fix isInternalRole</name>
  <files>src/types/index.ts, src/lib/permissions.ts</files>
  <action>
**src/types/index.ts** — Add two new interfaces after the existing SessionResponse interface (around line 226):

```typescript
// =============================================
// ORGANIZATION & MANDATE TYPES (Phase 38)
// =============================================

export interface Organization {
  id: string
  name: string
  slug: string
  isDefault?: boolean
}

export interface Mandate {
  id: string
  name: string
  mandate_type: 'rental' | 'stwe' | 'mixed'
  is_active: boolean
}
```

Also add `MandateType` to the type aliases section:
```typescript
export type MandateType = 'rental' | 'stwe' | 'mixed'
```

**src/lib/permissions.ts** — Fix `isInternalRole()` (line 224-226) to include 'hauswart' per D7:

Change the includes array from:
```typescript
return ['admin', 'property_manager', 'accounting'].includes(roleName)
```
to:
```typescript
return ['admin', 'property_manager', 'accounting', 'hauswart'].includes(roleName)
```

Also add 'hauswart' to ROLE_HIERARCHY (around line 204-209) with level 40 (below accounting at 60, above tenant at 20):
```typescript
export const ROLE_HIERARCHY: Record<string, number> = {
  admin: 100,
  property_manager: 80,
  accounting: 60,
  hauswart: 40,
  tenant: 20,
  external_contractor: 10
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Grep for 'hauswart' in permissions.ts to confirm it appears in both isInternalRole and ROLE_HIERARCHY.</verify>
  <done>Organization and Mandate types exported from src/types/index.ts. isInternalRole('hauswart') returns true. ROLE_HIERARCHY includes hauswart at level 40.</done>
</task>

<task type="auto">
  <name>Task 2: Create organizations, mandates API routes and add mandate filter to properties</name>
  <files>src/app/api/organizations/route.ts, src/app/api/mandates/route.ts, src/app/api/properties/route.ts</files>
  <action>
**src/app/api/organizations/route.ts** — Create new file. GET endpoint returns available organizations for the authenticated user.

- Import `createPublicClient` from `@/lib/supabase/with-org` (organizations and organization_members tables have NO RLS)
- Read `x-user-id` header (set by middleware) for user identification
- Query: `organization_members` with select joining `organizations(id, name, slug, is_active)`, filtered by `user_id` and `organizations.is_active = true`
- Map response to `{ organizations: [{ id, name, slug, isDefault }] }`
- Return 401 if no x-user-id header

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createPublicClient } from '@/lib/supabase/with-org'

export async function GET(request: NextRequest) {
  const userId = request.headers.get('x-user-id')
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const supabase = await createPublicClient()

  const { data, error } = await supabase
    .from('organization_members')
    .select(`
      is_default,
      organizations (
        id,
        name,
        slug,
        is_active
      )
    `)
    .eq('user_id', userId)

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  const organizations = (data || [])
    .filter((m: any) => m.organizations?.is_active)
    .map((m: any) => ({
      id: m.organizations.id,
      name: m.organizations.name,
      slug: m.organizations.slug,
      isDefault: m.is_default,
    }))

  return NextResponse.json({ organizations })
}
```

**src/app/api/mandates/route.ts** — Create new file. GET endpoint returns mandates for the current organization.

- Import `createPublicClient` from `@/lib/supabase/with-org` (mandates table has NO RLS)
- Read `x-organization-id` header (set by middleware) for org scoping
- Query: `mandates` filtered by `organization_id = orgId` and `is_active = true`, ordered by name
- Return `{ mandates: [{ id, name, mandate_type, is_active }] }`
- Return 401 if no x-organization-id header

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createPublicClient } from '@/lib/supabase/with-org'

export async function GET(request: NextRequest) {
  const orgId = request.headers.get('x-organization-id')
  if (!orgId) {
    return NextResponse.json({ error: 'Organization context required' }, { status: 401 })
  }

  const supabase = await createPublicClient()

  const { data, error } = await supabase
    .from('mandates')
    .select('id, name, mandate_type, is_active')
    .eq('organization_id', orgId)
    .eq('is_active', true)
    .order('name')

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }

  return NextResponse.json({ mandates: data || [] })
}
```

**src/app/api/properties/route.ts** — Modify existing GET handler to add optional `mandate_id` query param for filtering (D1, D3, D6 support).

After the role check block (around line 47), before the `createOrgClient` call, add:
```typescript
const mandateId = request.nextUrl.searchParams.get('mandate_id')
```

Then modify the properties query (around line 52-55) to conditionally filter:
```typescript
let propertiesQuery = supabase
  .from('properties')
  .select('*')
  .order('name', { ascending: true })

if (mandateId && mandateId !== 'all') {
  propertiesQuery = propertiesQuery.eq('mandate_id', mandateId)
}

const { data: properties, error: propsError } = await propertiesQuery
```

Similarly for buildings — if mandate_id is provided, filter buildings to only those within the filtered properties. The simplest approach: after getting both properties and buildings, filter buildings by property_id matching the returned properties (already done by the existing grouping logic, so no change needed there).
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Verify the new route files exist: `ls src/app/api/organizations/route.ts src/app/api/mandates/route.ts`</verify>
  <done>GET /api/organizations returns user's available orgs from organization_members. GET /api/mandates returns org-scoped mandates. GET /api/properties accepts optional mandate_id query param. All three endpoints use createPublicClient or createOrgClient appropriately based on RLS status.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `grep -n 'hauswart' src/lib/permissions.ts` shows hauswart in both isInternalRole and ROLE_HIERARCHY
3. `ls src/app/api/organizations/route.ts src/app/api/mandates/route.ts` — both files exist
4. `grep -n 'mandate_id' src/app/api/properties/route.ts` — shows mandate filter logic
5. `grep -n 'Organization' src/types/index.ts` — shows Organization interface
</verification>

<success_criteria>
- Organization and Mandate types are importable from '@/types'
- isInternalRole('hauswart') returns true
- Three API endpoints compile without errors
- Properties endpoint accepts optional mandate_id filter
</success_criteria>

<output>
After completion, create `.planning/phases/38-app-context-org-switcher/38-01-SUMMARY.md`
</output>
