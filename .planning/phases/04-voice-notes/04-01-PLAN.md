---
phase: 04-voice-notes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/005_task_audio.sql
  - src/types/database.ts
  - src/app/api/audio/route.ts
  - src/app/api/audio/[id]/route.ts
autonomous: true

must_haves:
  truths:
    - "Audio records can be created in the database"
    - "Audio files can be uploaded to storage"
    - "Audio files can be retrieved with signed URLs"
    - "Audio records can be deleted with storage cleanup"
    - "Role-based permissions enforced (KEWA=explanation, Imeri=emergency)"
  artifacts:
    - path: "supabase/migrations/005_task_audio.sql"
      provides: "Database schema for audio attachments"
      contains: "CREATE TABLE task_audio"
    - path: "src/types/database.ts"
      provides: "TypeScript types for audio"
      contains: "AudioType"
    - path: "src/app/api/audio/route.ts"
      provides: "Audio CRUD API"
      exports: ["GET", "POST"]
    - path: "src/app/api/audio/[id]/route.ts"
      provides: "Audio delete endpoint"
      exports: ["DELETE"]
  key_links:
    - from: "api/audio POST"
      to: "supabase storage"
      via: "upload to task-audio bucket"
    - from: "api/audio GET"
      to: "task_audio table"
      via: "select with signed URL generation"
---

<objective>
Create audio storage infrastructure for voice notes with database schema, TypeScript types, and CRUD API.

Purpose: Enable audio attachments for tasks - KEWA records explanations (with later transcription), Imeri records emergencies.
Output: Database migration, TypeScript types, and complete API for audio CRUD operations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase patterns (audio follows same patterns as photos):
@.planning/phases/03-photo-documentation/03-01-SUMMARY.md

# Existing code to follow patterns from:
@src/app/api/photos/route.ts
@src/app/api/photos/[id]/route.ts
@src/types/database.ts
@supabase/migrations/003_task_photos.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create task_audio database schema</name>
  <files>supabase/migrations/005_task_audio.sql</files>
  <action>
Create migration 005_task_audio.sql with:

1. task_audio table:
   - id (UUID, primary key, default gen_random_uuid())
   - task_id (UUID, references tasks(id) ON DELETE CASCADE)
   - audio_type (TEXT, check 'explanation' or 'emergency')
   - storage_path (TEXT, not null)
   - file_name (TEXT, not null)
   - file_size (INTEGER, not null)
   - duration_seconds (INTEGER, nullable - may not be available)
   - transcription (TEXT, nullable - filled by transcription service)
   - transcription_status (TEXT, default 'pending', check 'pending', 'processing', 'completed', 'failed')
   - uploaded_by (UUID, references users(id))
   - created_at (TIMESTAMPTZ, default now())

2. Indexes:
   - task_id for foreign key lookups
   - uploaded_by for user queries
   - created_at for chronological ordering

3. Comments documenting storage bucket setup (like 003_task_photos.sql):
   - Bucket: task-audio (private)
   - Policies: authenticated read all, authenticated insert, delete own

Audio type constraint:
- 'explanation' = KEWA's recorded instructions (will be transcribed)
- 'emergency' = Imeri's emergency recordings (no transcription)

Max 1 audio per type per task (enforced at API level for flexibility).
  </action>
  <verify>Migration file syntax is valid SQL (no syntax errors)</verify>
  <done>task_audio table schema defined with transcription support fields</done>
</task>

<task type="auto">
  <name>Task 2: Add audio types to database.ts</name>
  <files>src/types/database.ts</files>
  <action>
Add to src/types/database.ts following the existing photo types pattern:

1. AudioType - 'explanation' | 'emergency'

2. TranscriptionStatus - 'pending' | 'processing' | 'completed' | 'failed'

3. TaskAudio interface:
   - id: string
   - task_id: string
   - audio_type: AudioType
   - storage_path: string
   - file_name: string
   - file_size: number
   - duration_seconds: number | null
   - transcription: string | null
   - transcription_status: TranscriptionStatus
   - uploaded_by: string
   - created_at: string

4. TaskAudioWithUrl interface (extends TaskAudio):
   - url: string

5. CreateAudioInput interface:
   - task_id: string
   - audio_type: AudioType
   - file: File

6. AudiosResponse interface:
   - audios: TaskAudioWithUrl[]

7. AudioResponse interface:
   - audio: TaskAudioWithUrl

Place these after the PHOTO TYPES section, create new section header:
// =============================================
// AUDIO TYPES
// =============================================
  </action>
  <verify>TypeScript compilation: npx tsc --noEmit src/types/database.ts</verify>
  <done>Audio types defined and exported</done>
</task>

<task type="auto">
  <name>Task 3: Create audio upload and list API</name>
  <files>src/app/api/audio/route.ts</files>
  <action>
Create src/app/api/audio/route.ts following photos/route.ts pattern:

GET /api/audio?task_id={id}:
1. Validate authentication (x-user-id, x-user-role headers)
2. Validate task_id query param required
3. Verify task exists and user has access (Imeri: check project visible_to_imeri)
4. Fetch all task_audio records for task_id, ordered by created_at
5. Generate signed URLs (1 hour expiry) for each audio file
6. Return { audios: TaskAudioWithUrl[] }

POST /api/audio:
1. Parse multipart/form-data: file, task_id, audio_type
2. Validate required fields
3. Validate audio_type is 'explanation' or 'emergency'
4. Role-based validation:
   - KEWA can only add 'explanation' audio
   - Imeri can only add 'emergency' audio
5. Check max limit: 1 audio per type per task
6. Validate file is audio (audio/webm, audio/mp4, audio/mpeg, audio/wav)
7. Generate unique storage path: {task_id}/{audio_type}/{uuid}.{ext}
8. Upload to 'task-audio' bucket
9. Insert record with transcription_status='pending' for explanation, 'completed' for emergency
10. Generate signed URL and return { audio: TaskAudioWithUrl }

Constants:
- BUCKET_NAME = 'task-audio'
- MAX_AUDIO_PER_TYPE = 1
- URL_EXPIRY_SECONDS = 3600
- MAX_FILE_SIZE = 10 * 1024 * 1024 (10MB)
- MAX_DURATION_SECONDS = 60 (1 minute - validated client-side but checked if provided)
  </action>
  <verify>API route file compiles: npx tsc --noEmit</verify>
  <done>GET returns audio list with URLs, POST uploads and returns new audio</done>
</task>

<task type="auto">
  <name>Task 4: Create audio delete API</name>
  <files>src/app/api/audio/[id]/route.ts</files>
  <action>
Create src/app/api/audio/[id]/route.ts following photos/[id]/route.ts pattern:

DELETE /api/audio/{id}:
1. Validate authentication
2. Parse audio ID from params
3. Fetch audio record, verify it exists
4. Verify ownership: uploaded_by must match current user
5. Delete from storage first (storage_path)
6. Delete from database
7. Return { success: true }

Error cases:
- 401 if not authenticated
- 404 if audio not found
- 403 if not owner
- 500 for storage/database errors

Follow delete order: storage first, then DB (orphaned storage is acceptable, orphaned DB record is not).
  </action>
  <verify>API route file compiles: npx tsc --noEmit</verify>
  <done>DELETE removes audio from storage and database with ownership check</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Migration file 005_task_audio.sql exists with valid SQL
- [ ] Types added to database.ts compile without errors
- [ ] GET /api/audio route returns proper TypeScript types
- [ ] POST /api/audio route handles multipart form data
- [ ] DELETE /api/audio/[id] route validates ownership
- [ ] npm run build succeeds (no TypeScript errors)
</verification>

<success_criteria>
- All 4 tasks completed with atomic commits
- Database schema supports transcription workflow
- API follows exact same patterns as photos API
- Role-based permissions enforced
- All TypeScript types properly defined
</success_criteria>

<output>
After completion, create `.planning/phases/04-voice-notes/04-01-SUMMARY.md`
</output>
