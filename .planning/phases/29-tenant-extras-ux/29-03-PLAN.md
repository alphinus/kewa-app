---
phase: 29-tenant-extras-ux
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/components/ui/empty-state.tsx
  - src/components/ui/error-boundary.tsx
  - src/components/ui/confirmation-dialog.tsx
  - src/components/ui/breadcrumbs.tsx
  - src/components/ui/form-field.tsx
  - src/components/skeletons/PropertyListSkeleton.tsx
  - src/components/skeletons/UnitDetailSkeleton.tsx
  - src/components/skeletons/TaskListSkeleton.tsx
  - src/components/skeletons/TicketListSkeleton.tsx
  - src/app/(dashboard)/dashboard/liegenschaften/page.tsx
  - src/app/(dashboard)/dashboard/aufgaben/page.tsx
autonomous: true

must_haves:
  truths:
    - "App displays skeleton loaders during data fetching"
    - "Empty states show meaningful messages with CTAs"
    - "Error states show German messages with retry button"
    - "Confirmation dialog appears before destructive actions"
    - "Form validation shows inline errors on fields"
    - "Breadcrumb navigation appears in deep hierarchies"
  artifacts:
    - path: "src/components/ui/empty-state.tsx"
      provides: "Reusable empty state component"
      exports: ["EmptyState"]
    - path: "src/components/ui/error-boundary.tsx"
      provides: "Error boundary with retry"
      exports: ["ErrorBoundary", "ErrorFallback"]
    - path: "src/components/ui/confirmation-dialog.tsx"
      provides: "Confirmation dialog component"
      exports: ["ConfirmationDialog"]
    - path: "src/components/ui/breadcrumbs.tsx"
      provides: "Breadcrumb navigation component"
      exports: ["Breadcrumbs"]
    - path: "src/components/ui/form-field.tsx"
      provides: "Form field with validation wrapper"
      exports: ["FormField"]
    - path: "src/components/skeletons/PropertyListSkeleton.tsx"
      provides: "Skeleton for property list"
      exports: ["PropertyListSkeleton"]
  key_links:
    - from: "src/app/(dashboard)/dashboard/liegenschaften/page.tsx"
      to: "PropertyListSkeleton"
      via: "conditional render while loading"
      pattern: "loading.*PropertyListSkeleton"
    - from: "src/app/(dashboard)/dashboard/liegenschaften/page.tsx"
      to: "EmptyState"
      via: "conditional render when list empty"
      pattern: "properties.*length.*EmptyState"
    - from: "src/app/(dashboard)/dashboard/liegenschaften/page.tsx"
      to: "Breadcrumbs"
      via: "render in page header"
      pattern: "Breadcrumbs"
---

<objective>
Implement consistent UX patterns across the app: skeleton loaders, empty states, error handling, confirmation dialogs, form validation, and breadcrumbs.

Purpose: UXPL-05 through UXPL-10 address UX debt and establish consistent patterns. This improves perceived performance (skeleton loaders), guides users when data is missing (empty states), handles errors gracefully (error boundaries), prevents accidental data loss (confirmations), provides immediate feedback (validation), and helps navigation (breadcrumbs).

Output: Reusable UI components and integration into key pages.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-tenant-extras-ux/29-CONTEXT.md
@.planning/phases/29-tenant-extras-ux/29-RESEARCH.md

# Existing UI components
@src/components/ui/button.tsx
@src/components/ui/input.tsx
@src/components/ui/dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reusable UX pattern components</name>
  <files>
    package.json
    src/components/ui/empty-state.tsx
    src/components/ui/error-boundary.tsx
    src/components/ui/confirmation-dialog.tsx
    src/components/ui/form-field.tsx
  </files>
  <action>
1. Install react-loading-skeleton:
   ```bash
   npm install react-loading-skeleton
   ```

2. Create `src/components/ui/empty-state.tsx`:
   - Props: icon? (ReactNode), title (string), description? (string), action? ({ label, onClick })
   - Centered layout with icon, title, description, CTA button
   - German text support (no hardcoded English)
   - Styling: py-12, centered, text-gray-600 dark:text-gray-400
   - Example usage in comments:
     ```tsx
     <EmptyState
       icon={<Home className="h-12 w-12" />}
       title="Keine Liegenschaften"
       description="Erstellen Sie Ihre erste Liegenschaft."
       action={{ label: "+ Liegenschaft", onClick: () => router.push('/dashboard/liegenschaften/neu') }}
     />
     ```

3. Create `src/components/ui/error-boundary.tsx`:
   - Two exports: ErrorBoundary (class component), ErrorFallback (functional component)

   ErrorFallback component:
   - Props: error, resetErrorBoundary
   - Display: German error message "Ein Fehler ist aufgetreten"
   - Show error.message in collapsible details (for debugging)
   - Retry button calling resetErrorBoundary
   - Styling: centered, red accent, padding

   ErrorBoundary class component:
   - Wraps children in error boundary
   - Catches errors, renders ErrorFallback
   - Props: fallback? (custom fallback), onReset? (callback after retry)

4. Create `src/components/ui/confirmation-dialog.tsx`:
   - Use @radix-ui/react-alert-dialog (already in project via existing dialog)
   - Props: open, onOpenChange, title, description, confirmLabel?, cancelLabel?, onConfirm, variant? ('danger' | 'primary')
   - German default labels: "Bestätigen", "Abbrechen"
   - variant='danger' uses red button for confirm
   - Accessible: proper aria labels, focus management
   - Example usage:
     ```tsx
     <ConfirmationDialog
       open={showDelete}
       onOpenChange={setShowDelete}
       title="Liegenschaft löschen?"
       description="Diese Aktion kann nicht rückgängig gemacht werden."
       confirmLabel="Löschen"
       variant="danger"
       onConfirm={handleDelete}
     />
     ```

5. Create `src/components/ui/form-field.tsx`:
   - Wrapper component for form fields with validation
   - Props: label, name, error?, required?, children (input element)
   - Renders Label, children, error message
   - Error styling: text-red-600 text-sm mt-1
   - Accessibility: aria-invalid, aria-describedby for error
   - Example usage:
     ```tsx
     <FormField label="Telefonnummer" name="phone" error={errors.phone} required>
       <Input value={phone} onChange={...} onBlur={...} />
     </FormField>
     ```
  </action>
  <verify>
    - `npm run type-check` passes
    - All four components export correctly
    - Components use German default text
    - No hardcoded English strings
  </verify>
  <done>
    - react-loading-skeleton installed
    - EmptyState component with icon, title, description, CTA
    - ErrorBoundary with ErrorFallback and retry
    - ConfirmationDialog with danger/primary variants
    - FormField wrapper with inline error display
  </done>
</task>

<task type="auto">
  <name>Task 2: Create skeleton loader components and breadcrumbs</name>
  <files>
    src/components/skeletons/PropertyListSkeleton.tsx
    src/components/skeletons/UnitDetailSkeleton.tsx
    src/components/skeletons/TaskListSkeleton.tsx
    src/components/skeletons/TicketListSkeleton.tsx
    src/components/ui/breadcrumbs.tsx
  </files>
  <action>
1. Create `src/components/skeletons/PropertyListSkeleton.tsx`:
   - Import Skeleton from 'react-loading-skeleton'
   - Import CSS: import 'react-loading-skeleton/dist/skeleton.css'
   - Render 3 card placeholders matching property card layout:
     - Avatar circle (48x48)
     - Title line (60% width)
     - Subtitle line (40% width)
     - Stats row (two badges)
   - Export as default and named export

2. Create `src/components/skeletons/UnitDetailSkeleton.tsx`:
   - Match unit detail page layout:
     - Header: title + badge
     - Info cards: 3x grid of stat cards
     - Content area: large content block
   - Use Skeleton count prop for repeated lines

3. Create `src/components/skeletons/TaskListSkeleton.tsx`:
   - Match task list layout:
     - 5 task row skeletons
     - Each row: checkbox, title, badge, date
   - More compact than property cards

4. Create `src/components/skeletons/TicketListSkeleton.tsx`:
   - Match portal ticket list layout:
     - 3 ticket card skeletons
     - Each: title, category badge, status badge, date
   - Mobile-friendly layout

5. Create `src/components/ui/breadcrumbs.tsx`:
   'use client' component:
   - Props: items? (array of { label, href }), labels? (Record<string, string> for dynamic routes)
   - If no items prop, auto-generate from usePathname()
   - Skip 'dashboard' segment (per CONTEXT.md)
   - Format: Property > Unit > Current (condensed)
   - Use ChevronRight from lucide-react as separator
   - Last item is not a link (current page)
   - Styling: text-sm, text-gray-600, hover states on links

   Auto-generation logic:
   ```typescript
   const pathname = usePathname()
   const segments = pathname.split('/').filter(Boolean)
     .filter(seg => seg !== 'dashboard')

   // Build breadcrumbs with optional labels override
   const crumbs = segments.map((segment, idx) => {
     const href = '/' + ['dashboard', ...segments.slice(0, idx + 1)].join('/')
     const label = labels?.[segment] || formatSegment(segment)
     return { label, href }
   })
   ```

   formatSegment helper: Convert kebab-case to Title Case, handle UUIDs gracefully
  </action>
  <verify>
    - `npm run type-check` passes
    - Skeleton components import CSS properly
    - Breadcrumbs auto-generate from pathname
    - Breadcrumbs accept optional labels for dynamic routes
  </verify>
  <done>
    - Four skeleton components matching different page layouts
    - Breadcrumbs component with auto-generation
    - Breadcrumbs skip Dashboard level
    - Labels prop for custom segment names
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate UX patterns into key pages</name>
  <files>
    src/app/(dashboard)/dashboard/liegenschaften/page.tsx
    src/app/(dashboard)/dashboard/aufgaben/page.tsx
    src/app/(portal)/portal/tickets/page.tsx
  </files>
  <action>
1. Update `src/app/(dashboard)/dashboard/liegenschaften/page.tsx`:

   Add skeleton loading state:
   - Add loading state: const [loading, setLoading] = useState(true)
   - Wrap data fetch in try/catch/finally with setLoading(false)
   - Render PropertyListSkeleton when loading

   Add empty state:
   - Check if properties array is empty after loading
   - Render EmptyState with:
     - icon: Building icon from lucide-react
     - title: "Keine Liegenschaften"
     - description: "Sie haben noch keine Liegenschaften erstellt."
     - action: { label: "+ Liegenschaft erstellen", onClick: navigate to create page }

   Add breadcrumbs:
   - Import Breadcrumbs component
   - Render at top of page content
   - No labels needed (auto-generates "Liegenschaften" from path)

   Add error handling:
   - Wrap main content in ErrorBoundary
   - Or use try/catch with error state and ErrorFallback

2. Update `src/app/(dashboard)/dashboard/aufgaben/page.tsx`:

   Same patterns:
   - TaskListSkeleton while loading
   - EmptyState when no tasks:
     - icon: CheckSquare icon
     - title: "Keine Aufgaben"
     - description: "Es gibt aktuell keine offenen Aufgaben."
   - Breadcrumbs at top
   - ErrorBoundary wrapper

3. Update `src/app/(portal)/portal/tickets/page.tsx`:

   Same patterns:
   - TicketListSkeleton while loading
   - EmptyState when no tickets:
     - icon: Ticket icon
     - title: "Keine Tickets"
     - description: "Sie haben noch keine Tickets erstellt."
     - action: { label: "+ Neues Ticket", onClick: navigate to create }
   - Breadcrumbs (portal version, skip 'portal' segment)
   - ErrorBoundary wrapper

4. Add confirmation dialog to delete actions:
   - Find existing delete buttons in pages
   - Wrap in confirmation dialog pattern:
     ```tsx
     const [deleteTarget, setDeleteTarget] = useState<string | null>(null)

     // In delete button onClick:
     setDeleteTarget(item.id)

     // Dialog:
     <ConfirmationDialog
       open={!!deleteTarget}
       onOpenChange={(open) => !open && setDeleteTarget(null)}
       title="Löschen bestätigen?"
       description="Diese Aktion kann nicht rückgängig gemacht werden."
       variant="danger"
       confirmLabel="Löschen"
       onConfirm={() => handleDelete(deleteTarget)}
     />
     ```
  </action>
  <verify>
    - `npm run type-check` passes
    - `npm run build` succeeds
    - Properties page shows skeleton while loading
    - Properties page shows empty state when no data
    - Tasks page shows skeleton and empty state
    - Portal tickets page shows skeleton and empty state
    - Breadcrumbs visible on all three pages
  </verify>
  <done>
    - Skeleton loaders integrated into 3 key pages
    - Empty states with German text and CTAs
    - Error boundaries protect against crashes
    - Confirmation dialogs on destructive actions
    - Breadcrumbs show navigation context
  </done>
</task>

</tasks>

<verification>
1. Type check passes: `npm run type-check`
2. Build succeeds: `npm run build`
3. Skeleton loaders render with gray placeholder shapes
4. Empty states show icon, title, description, CTA button
5. Error fallback shows German message and retry button
6. Confirmation dialog blocks until user confirms
7. Form validation shows inline errors below fields
8. Breadcrumbs skip Dashboard level and show Property > Unit > Item format
</verification>

<success_criteria>
- UXPL-05: Skeleton loaders during data fetching (not spinners)
- UXPL-06: Empty states with descriptive text and CTAs
- UXPL-07: Error handling with German messages and retry
- UXPL-08: Confirmation dialogs before delete/destructive actions
- UXPL-09: Inline form validation with German error messages
- UXPL-10: Breadcrumb navigation in hierarchical pages
- All text in German
- Consistent styling with existing design system
</success_criteria>

<output>
After completion, create `.planning/phases/29-tenant-extras-ux/29-03-SUMMARY.md`
</output>
