---
phase: 29-tenant-extras-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/emails/ticket-status-changed.tsx
  - src/emails/ticket-reply-received.tsx
  - src/lib/email/client.ts
  - src/lib/email/send.ts
  - src/lib/notifications/tenant-triggers.ts
  - src/app/api/portal/tickets/[id]/messages/route.ts
  - src/app/api/admin/tickets/[id]/status/route.ts
autonomous: true
user_setup:
  - service: resend
    why: "Email delivery for tenant notifications"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
    dashboard_config:
      - task: "Verify domain for sending emails"
        location: "Resend Dashboard -> Domains -> Add Domain"

must_haves:
  truths:
    - "Tenant receives email when ticket status changes"
    - "Tenant receives email when KEWA replies to message"
    - "Tenant receives push notification for ticket updates"
    - "Push notification click opens specific ticket in portal"
    - "If no push subscription, fallback to email-only works"
  artifacts:
    - path: "src/emails/ticket-status-changed.tsx"
      provides: "HTML email template for status changes"
      min_lines: 50
    - path: "src/emails/ticket-reply-received.tsx"
      provides: "HTML email template for new replies"
      min_lines: 50
    - path: "src/lib/email/client.ts"
      provides: "Resend client singleton"
      exports: ["resend"]
    - path: "src/lib/email/send.ts"
      provides: "Email sending helper"
      exports: ["sendEmail"]
    - path: "src/lib/notifications/tenant-triggers.ts"
      provides: "Tenant notification dispatch"
      exports: ["notifyTenantTicketStatusChange", "notifyTenantTicketReply"]
  key_links:
    - from: "src/app/api/admin/tickets/[id]/status/route.ts"
      to: "notifyTenantTicketStatusChange"
      via: "fire-and-forget call on status update"
      pattern: "notifyTenantTicketStatusChange"
    - from: "src/app/api/portal/tickets/[id]/messages/route.ts"
      to: "notifyTenantTicketReply"
      via: "fire-and-forget call when operator sends message"
      pattern: "notifyTenantTicketReply"
    - from: "src/lib/notifications/tenant-triggers.ts"
      to: "sendNotification"
      via: "push dispatch via existing Phase 24 infrastructure"
      pattern: "sendNotification.*targetUserIds"
---

<objective>
Implement tenant notifications for ticket updates via email and push notifications.

Purpose: TPRT-08 (email notifications) and TPRT-11 (push notifications) - Tenants need to be informed when their ticket status changes or when KEWA replies to their message thread. This enables timely responses and improves tenant satisfaction.

Output: React Email templates for ticket notifications, Resend email client, tenant notification triggers integrated with ticket status changes and message replies.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-tenant-extras-ux/29-CONTEXT.md
@.planning/phases/29-tenant-extras-ux/29-RESEARCH.md

# Existing notification infrastructure
@src/lib/notifications/send.ts
@src/lib/notifications/triggers.ts
@src/lib/notifications/queries.ts

# Ticket structure
@src/types/portal.ts
@src/lib/portal/ticket-queries.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create email templates</name>
  <files>
    package.json
    src/emails/ticket-status-changed.tsx
    src/emails/ticket-reply-received.tsx
    src/lib/email/client.ts
    src/lib/email/send.ts
  </files>
  <action>
1. Install resend and react-email packages:
   ```bash
   npm install resend @react-email/components
   ```

2. Create `src/lib/email/client.ts` - Resend client singleton:
   - Import Resend from 'resend'
   - Export `resend` instance initialized with process.env.RESEND_API_KEY
   - Handle missing API key gracefully (log warning, don't crash)

3. Create `src/lib/email/send.ts` - Email sending helper:
   - Export `sendEmail` function accepting: to, subject, react (React component)
   - Use resend.emails.send() with from: 'KEWA Support <support@kewa.app>' (configurable via env)
   - Return { success: boolean, error?: string, emailId?: string }
   - Wrap in try/catch, log errors but don't throw (fire-and-forget pattern)

4. Create `src/emails/ticket-status-changed.tsx` - Status change email:
   - Use @react-email/components: Html, Head, Body, Container, Section, Text, Button
   - Props: tenantName, ticketNumber, oldStatus, newStatus, ticketUrl, messageContent?
   - German content: "Hallo {name}, Ihr Ticket {number} hat einen neuen Status: {status}"
   - Map status to German labels: offen -> Offen, in_bearbeitung -> In Bearbeitung, geschlossen -> Geschlossen
   - Include CTA button "Ticket anzeigen" linking to ticketUrl
   - Use inline styles (no external CSS - email client compatibility)
   - Colors: Match existing app theme (blue primary, white background)

5. Create `src/emails/ticket-reply-received.tsx` - Reply notification email:
   - Same structure as status email
   - Props: tenantName, ticketNumber, ticketUrl, replyContent, operatorName
   - German content: "Sie haben eine neue Nachricht zu Ticket {number}"
   - Show reply content preview in styled box (max 200 chars, truncate with "...")
   - Include CTA button "Nachricht ansehen"
  </action>
  <verify>
    - `npm run type-check` passes with no errors
    - `src/emails/` directory exists with both template files
    - `src/lib/email/client.ts` exports resend
    - `src/lib/email/send.ts` exports sendEmail function
  </verify>
  <done>
    - Resend and React Email packages installed
    - Email client singleton created
    - Two email templates exist with German content and inline styles
    - sendEmail helper returns success/error without throwing
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tenant notification triggers</name>
  <files>
    src/lib/notifications/tenant-triggers.ts
  </files>
  <action>
Create `src/lib/notifications/tenant-triggers.ts` with two main functions:

1. Export `notifyTenantTicketStatusChange`:
   - Params: { ticketId, tenantUserId, tenantEmail, tenantName, ticketNumber, oldStatus, newStatus }
   - Build ticketUrl: `${process.env.NEXT_PUBLIC_APP_URL}/portal/tickets/${ticketId}`
   - Track delivery: { pushSuccess: boolean, emailSuccess: boolean }

   Push notification (try first):
   - Call existing sendNotification from '@/lib/notifications/send'
   - title: `Ticket ${ticketNumber}`
   - body: German status text using TICKET_STATUS_LABELS
   - url: `/portal/tickets/${ticketId}`
   - urgency: 'normal' (or 'urgent' if status is 'notfall' urgency)
   - targetUserIds: [tenantUserId]
   - Catch errors, set pushSuccess = false (don't throw)

   Email notification (always):
   - Call sendEmail with TicketStatusEmail template
   - Pass all props including ticketUrl
   - Catch errors, set emailSuccess = false (don't throw)

   Track delivery:
   - Create helper to log delivery status (for debugging)
   - Log: ticketId, pushSuccess, emailSuccess, timestamp
   - Don't fail if logging fails

2. Export `notifyTenantTicketReply`:
   - Params: { ticketId, tenantUserId, tenantEmail, tenantName, ticketNumber, replyContent, operatorName }
   - Same push + email pattern as above
   - Use TicketReplyEmail template for email
   - Push body: "Neue Nachricht von {operatorName}"

3. Helper function `getTenantNotificationData`:
   - Params: ticketId
   - Fetch from database: ticket with tenant user details (created_by -> users table)
   - Return: { tenantUserId, tenantEmail, tenantName, ticketNumber }
   - Used by API routes to get notification params

Follow existing fire-and-forget pattern from src/lib/notifications/triggers.ts:
- Don't throw errors
- Log errors but continue execution
- Return delivery status for debugging
  </action>
  <verify>
    - `npm run type-check` passes
    - File exports notifyTenantTicketStatusChange, notifyTenantTicketReply, getTenantNotificationData
    - Functions follow fire-and-forget pattern (try/catch with logging)
  </verify>
  <done>
    - Tenant notification triggers created following existing patterns
    - Both push and email channels implemented with fallback
    - Helper function to fetch tenant data from ticket
    - Fire-and-forget pattern prevents notification failures from breaking main flow
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire notifications into ticket API endpoints</name>
  <files>
    src/app/api/admin/tickets/[id]/status/route.ts
    src/app/api/portal/tickets/[id]/messages/route.ts
  </files>
  <action>
1. Create `src/app/api/admin/tickets/[id]/status/route.ts` - Admin ticket status update:
   - PATCH endpoint for operators to update ticket status
   - Validate: x-user-id header (authenticated operator)
   - Accept body: { status: TicketStatus }
   - Validate status transitions (only allow valid transitions):
     - offen -> in_bearbeitung, geschlossen, storniert
     - in_bearbeitung -> geschlossen, storniert
     - geschlossen -> (no transitions allowed)
     - storniert -> (no transitions allowed)
   - Update ticket in database with new status
   - If closing: set closed_at, closed_by
   - After successful update, fire notification:
     ```typescript
     const notificationData = await getTenantNotificationData(ticketId)
     // Fire and forget - don't await
     notifyTenantTicketStatusChange({
       ticketId,
       ...notificationData,
       oldStatus,
       newStatus: body.status,
     }).catch(err => console.error('Notification failed:', err))
     ```
   - Return updated ticket

2. Update `src/app/api/portal/tickets/[id]/messages/route.ts` POST handler:
   - After successfully creating operator message (sender_type === 'operator'):
   - Get ticket details for notification
   - Fire notification to tenant:
     ```typescript
     if (senderType === 'operator') {
       const notificationData = await getTenantNotificationData(ticketId)
       // Fire and forget
       notifyTenantTicketReply({
         ticketId,
         ...notificationData,
         replyContent: body.content,
         operatorName: operatorDisplayName,
       }).catch(err => console.error('Notification failed:', err))
     }
     ```
   - Don't await notification - response should return immediately

3. Create admin tickets list endpoint if needed: `src/app/api/admin/tickets/route.ts`
   - GET: List all tickets with filters (status, urgency, unit, building)
   - For operators to view and manage tickets
   - Include tenant details and message counts
  </action>
  <verify>
    - `npm run type-check` passes
    - `npm run build` succeeds
    - Admin status endpoint exists at /api/admin/tickets/[id]/status
    - Messages endpoint triggers notification on operator reply
  </verify>
  <done>
    - Admin ticket status update endpoint created with proper validation
    - Status changes trigger tenant email + push notification
    - Operator message replies trigger tenant notification
    - Notifications are fire-and-forget (don't block API response)
  </done>
</task>

</tasks>

<verification>
1. Type check passes: `npm run type-check`
2. Build succeeds: `npm run build`
3. Email templates render correctly (visual inspection of file structure)
4. Notification triggers are properly exported from tenant-triggers.ts
5. API endpoints exist and have correct middleware (authenticated operator)
</verification>

<success_criteria>
- TPRT-08: Email notifications work for status changes and replies
- TPRT-11: Push notifications use existing Phase 24 infrastructure
- Fallback chain: Push -> Email -> Log as undelivered
- Fire-and-forget pattern: Notification failures don't break ticket operations
- German content throughout emails
- Inline styles for email client compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/29-tenant-extras-ux/29-01-SUMMARY.md`
</output>
