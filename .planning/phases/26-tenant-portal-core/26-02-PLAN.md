---
phase: 26-tenant-portal-core
plan: 02
type: execute
wave: 2
depends_on: [26-01]
files_modified:
  - src/middleware.ts
  - src/lib/session.ts
  - src/lib/auth.ts
  - src/lib/portal/invite-tokens.ts
  - src/lib/portal/session.ts
  - src/app/api/portal/auth/login/route.ts
  - src/app/api/portal/auth/register/[token]/route.ts
  - src/app/api/portal/auth/verify-invite/[token]/route.ts
  - src/app/api/portal/auth/logout/route.ts
  - src/app/api/portal/auth/session/route.ts
  - src/app/api/portal/auth/qr-token/route.ts
  - src/app/api/portal/auth/qr-login/route.ts
  - src/app/portal/layout.tsx
  - src/app/portal/login/page.tsx
  - src/app/portal/register/[token]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Tenant can register via invite token link, setting email + password"
    - "Tenant can log in with email + password and receives a portal-specific session cookie"
    - "Portal routes are protected by middleware - unauthenticated users redirect to /portal/login"
    - "Operator session (existing) and tenant session (portal) use separate cookies"
    - "Deactivated tenant (is_active=false) cannot log in"
    - "Invite token is single-use and expires after 7 days"
    - "Portal layout is independent from operator layout (no shared navigation)"
    - "QR code login generates short-lived token for multi-device access"
  artifacts:
    - path: "src/middleware.ts"
      provides: "Extended middleware handling portal routes with tenant session validation"
      contains: "pathname.startsWith('/portal')"
    - path: "src/lib/portal/invite-tokens.ts"
      provides: "JWT-based invite token generation and verification"
      exports: ["generateInviteToken", "verifyInviteToken", "generateInviteUrl"]
    - path: "src/lib/portal/session.ts"
      provides: "Portal-specific session helpers with tenant role verification"
      exports: ["validatePortalSession", "createPortalSession", "PORTAL_COOKIE_NAME"]
    - path: "src/app/api/portal/auth/login/route.ts"
      provides: "Tenant email+password login endpoint"
      exports: ["POST"]
    - path: "src/app/api/portal/auth/register/[token]/route.ts"
      provides: "Invite-based registration endpoint"
      exports: ["POST"]
    - path: "src/app/portal/layout.tsx"
      provides: "Independent portal layout with own header, no operator navigation"
    - path: "src/app/portal/login/page.tsx"
      provides: "Portal login page with email/password form"
    - path: "src/app/portal/register/[token]/page.tsx"
      provides: "Invite registration page with password form"
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/portal/session.ts"
      via: "validatePortalSession for portal routes"
      pattern: "validatePortalSession"
    - from: "src/app/api/portal/auth/register/[token]/route.ts"
      to: "src/lib/portal/invite-tokens.ts"
      via: "verifyInviteToken validates invite JWT"
      pattern: "verifyInviteToken"
    - from: "src/app/(portal)/login/page.tsx"
      to: "/api/portal/auth/login"
      via: "fetch POST with email+password"
      pattern: "api/portal/auth/login"
---

<objective>
Implement tenant authentication: invite-based registration, email+password login, portal session management, route protection, and portal layout shell.

Purpose: Tenants can register, log in, and access the portal. Separate session cookie prevents interference with operator sessions. Middleware protects all portal routes.
Output: Portal auth API routes, invite token system, portal session management, middleware extension, login/register pages, portal layout.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-tenant-portal-core/26-CONTEXT.md
@.planning/phases/26-tenant-portal-core/26-RESEARCH.md
@src/middleware.ts
@src/lib/session.ts
@src/lib/auth.ts
@src/types/auth.ts
@src/app/api/auth/login/route.ts
@src/app/api/auth/register/route.ts
@src/app/layout.tsx
@src/app/dashboard/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Portal session management and invite token system</name>
  <files>
    src/lib/portal/session.ts
    src/lib/portal/invite-tokens.ts
  </files>
  <action>
**src/lib/portal/session.ts** - Portal-specific session utilities. Mirrors src/lib/session.ts pattern but with portal-specific cookie and tenant role enforcement:

Constants:
- `PORTAL_COOKIE_NAME = 'portal_session'` -- separate from operator 'session' cookie
- `PORTAL_SESSION_EXPIRATION_SECONDS = 60 * 60 * 24 * 30` -- 30 days (mobile users)
- `PORTAL_COOKIE_OPTIONS` -- same as SESSION_COOKIE_OPTIONS but with PORTAL_SESSION_EXPIRATION_SECONDS and path: '/portal'

Functions:
- `createPortalSession(userId: string)`: Create JWT with { userId, role: 'tenant', type: 'portal' } using jose SignJWT. Same SESSION_SECRET env var. Return token string.
- `validatePortalSession(token: string)`: Verify JWT with jwtVerify. Check payload has type === 'portal'. Return { userId } or null.
- `getPortalSessionFromRequest(request: NextRequest)`: Get cookie named PORTAL_COOKIE_NAME, validate. Return { userId } or null.
- `getPortalUser()`: Server component helper. Read portal_session cookie from next/headers cookies(). Validate. Return { id: userId } or null. Pattern matches getCurrentUser() from src/lib/session.ts.

**src/lib/portal/invite-tokens.ts** - Invite token generation and verification:

Constants:
- `INVITE_EXPIRATION_SECONDS = 7 * 24 * 60 * 60` -- 7 days

Functions:
- `generateInviteToken(tenantUserId: string, email: string)`: Create JWT with { tenantUserId, email, type: 'tenant_invite' } using jose SignJWT. Use SESSION_SECRET. Set expiration to 7 days. Return token string.
- `verifyInviteToken(token: string)`: Verify JWT with jwtVerify. Check type === 'tenant_invite'. Return { tenantUserId, email } or null.
- `generateInviteUrl(token: string)`: Return `${process.env.NEXT_PUBLIC_APP_URL}/portal/register/${token}`.

Note: The invite token is validated server-side only. The token itself is the URL parameter. Single-use is enforced by checking if the user already has a password_hash set.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Check: Functions are importable.
  </verify>
  <done>Portal session uses separate cookie ('portal_session') with 30-day expiration. Invite tokens are JWTs with 7-day expiration and tenant_invite type. Single-use enforced by checking password_hash on registration attempt.</done>
</task>

<task type="auto">
  <name>Task 2: Middleware extension and portal auth API routes</name>
  <files>
    src/middleware.ts
    src/app/api/portal/auth/login/route.ts
    src/app/api/portal/auth/register/[token]/route.ts
    src/app/api/portal/auth/verify-invite/[token]/route.ts
    src/app/api/portal/auth/logout/route.ts
    src/app/api/portal/auth/session/route.ts
    src/app/api/portal/auth/qr-token/route.ts
    src/app/api/portal/auth/qr-login/route.ts
  </files>
  <action>
**src/middleware.ts** - Extend matcher and add portal route handling:

Add to `config.matcher`:
```typescript
matcher: [
  '/dashboard/:path*',
  '/api/((?!auth|portal/auth).*)',  // Exclude portal auth routes too
  '/contractor/:path*',
  '/portal/:path*',                  // Add portal protection
]
```

Add portal route handling in `middleware()` function, BEFORE the existing session check:

```typescript
// Portal routes
if (pathname.startsWith('/portal')) {
  return handlePortalRoute(request)
}
```

`handlePortalRoute(request)`:
- Portal auth routes (login, register, verify-invite) are public -- allow through:
  ```
  if (pathname === '/portal/login' || pathname.startsWith('/portal/register/') || pathname.startsWith('/api/portal/auth/')) {
    return NextResponse.next()
  }
  ```
- For all other /portal/* routes, validate portal session via getPortalSessionFromRequest().
- If no valid session, redirect to /portal/login for page routes, or return 401 JSON for /api/portal/* routes.
- If valid session, check user is_active in database (query users table). If inactive, delete portal_session cookie and redirect to /portal/login.
- If valid and active, set x-portal-user-id header and continue.

Also update the config.matcher array to exclude portal auth routes from operator session checking:
```typescript
config.matcher = [
  '/dashboard/:path*',
  '/api/((?!auth|portal/auth).*)',  // Exclude both operator auth and portal auth
  '/contractor/:path*',
  '/portal/:path*',                  // Add portal route protection
]
```
Portal API routes under `/api/portal/` (non-auth) use portal session via x-portal-user-id header, not operator session.

**src/app/api/portal/auth/login/route.ts** - POST handler:

Follow pattern from src/app/api/auth/login/route.ts handleEmailAuth, adapted for portal:
- Parse { email, password } from body.
- Find user by email with auth_method = 'email_password' and role joining to 'tenant'.
- Verify password with verifyPassword().
- Check is_active. Check user has tenant role.
- Create portal session token via createPortalSession(userId).
- Set PORTAL_COOKIE_NAME cookie.
- Return { success: true, displayName }.
- Log via createAuthAuditLog with action 'auth.login.email.success' or 'auth.login.email.failure'.

**src/app/api/portal/auth/register/[token]/route.ts** - POST handler:

- Verify invite token via verifyInviteToken(params.token).
- If invalid/expired, return 400 with German error.
- Parse { password } from body (email comes from token payload).
- Validate password length >= 8.
- Look up user by tenantUserId from token. If user already has password_hash set, return 409 'Bereits registriert'.
- Hash password. Update user with password_hash, auth_method = 'email_password', email_verified = true.
- Create portal session and set cookie.
- Return { success: true }.

**src/app/api/portal/auth/verify-invite/[token]/route.ts** - GET handler:

- Verify invite token. If invalid, return { valid: false, error: 'Token ungueltig oder abgelaufen' }.
- Look up user. If already registered (has password_hash), return { valid: false, error: 'Bereits registriert' }.
- Return { valid: true, email: user.email, displayName: user.display_name }.

**src/app/api/portal/auth/logout/route.ts** - POST handler:

- Delete PORTAL_COOKIE_NAME cookie.
- Return { success: true }.

**src/app/api/portal/auth/session/route.ts** - GET handler:

- Validate portal session. Return { authenticated: true/false, userId }.

**src/app/api/portal/auth/qr-token/route.ts** - POST handler:

- Validate portal session (must be logged in to generate QR).
- Create short-lived JWT (5 minutes) with { userId, type: 'qr_login' }.
- Return { token, expiresAt }.

**src/app/api/portal/auth/qr-login/route.ts** - POST handler:

- Parse { token } from body.
- Verify JWT, check type === 'qr_login'.
- Look up user, verify is_active and tenant role.
- Create portal session and set cookie.
- Return { success: true, redirectUrl: '/portal' }.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Check: Middleware correctly routes /portal/* requests.
Check: Portal auth routes are excluded from operator session requirement.
Check: Login API returns session cookie on valid credentials.
Check: Register API creates password and session on valid invite token.
  </verify>
  <done>Middleware protects all portal routes with tenant session validation. Portal auth API routes handle login, registration, invite verification, logout, session check, and QR multi-device login. Separate portal_session cookie prevents operator/tenant interference.</done>
</task>

<task type="auto">
  <name>Task 3: Portal layout, login page, and registration page</name>
  <files>
    src/app/(portal)/layout.tsx
    src/app/(portal)/login/page.tsx
    src/app/(portal)/register/[token]/page.tsx
  </files>
  <action>
**Important route group note:** The `(portal)` route group means URLs are `/portal/login`, `/portal/register/[token]`, etc. However, Next.js route groups with parentheses do NOT appear in the URL by default. To make the URL include `/portal/`, create the routes under `src/app/(portal)/portal/` -- OR simply use `src/app/portal/` without route groups. Since we need an independent layout and the URL must be `/portal/*`, use `src/app/portal/` as a regular route segment with its own layout.tsx. This is simpler and matches the URL structure directly.

Actually, re-evaluating: use `src/app/(portal)/portal/` structure. The `(portal)` provides layout isolation. The `portal/` inside provides the URL segment. So:
- `src/app/(portal)/layout.tsx` -- portal layout (wraps all /portal/* pages)
- `src/app/(portal)/portal/login/page.tsx` -- URL: /portal/login

Wait, that nests wrong. Simplest approach: `src/app/portal/layout.tsx` for the independent layout, and `src/app/portal/login/page.tsx` for the login page. This gives URL `/portal/login` with its own layout. The route group `(portal)` is unnecessary since we want `/portal` in the URL anyway. This is the pattern the contractor portal uses at `src/app/contractor/`.

**Use: `src/app/portal/` as a regular route segment.**

Update files_modified paths accordingly. All portal pages go under `src/app/portal/`.

**src/app/portal/layout.tsx** - Independent portal layout (server component):

```typescript
import type { Metadata } from 'next'
import { Toaster } from 'sonner'

export const metadata: Metadata = {
  title: 'Mieterportal',
  description: 'KEWA AG Mieterportal',
}

export default function PortalLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="min-h-screen bg-gray-50">
      {children}
      <Toaster
        position="top-center"
        richColors
        closeButton
        toastOptions={{ duration: 4000 }}
      />
    </div>
  )
}
```

Note: The root layout.tsx already provides `<html>` and `<body>`. Portal layout is nested inside it. The PushProvider from root layout still wraps portal pages. Portal layout provides its own Toaster (top-center for mobile). The portal header is rendered per-page or in a shared component (handled in Plan 04).

**src/app/portal/login/page.tsx** - Client component login form:

'use client' directive. Mobile-first login page:
- Company name header (hardcoded for now, settings integration in Plan 04).
- "Mieterportal" subtitle.
- Email input field (type="email", required).
- Password input field (type="password", required, minLength 8).
- "Anmelden" submit button (48px min-height touch target).
- Loading state during submit.
- Error display for invalid credentials.
- Form submits POST to /api/portal/auth/login.
- On success, router.push('/portal') to redirect to dashboard.
- Link at bottom: "Noch kein Konto? Kontaktieren Sie Ihre Hausverwaltung."
- German labels throughout. Mobile-first: max-w-sm mx-auto, centered on screen.
- Use toast() from sonner for error feedback.

**src/app/portal/register/[token]/page.tsx** - Client component registration:

'use client' directive. Two-phase page:
1. On mount, call GET /api/portal/auth/verify-invite/[token] to check token validity.
2. If invalid, show error message with link to /portal/login.
3. If valid, show registration form:
   - Display email (read-only, from verify response).
   - Password input (minLength 8).
   - Confirm password input.
   - "Registrieren" submit button.
   - Client-side validation: passwords match, min length 8.
   - Submit POST to /api/portal/auth/register/[token] with { password }.
   - On success, router.push('/portal').
- German labels. Mobile-first layout.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Run: `npm run build` -- build succeeds.
Check: /portal/login renders login form.
Check: /portal/register/[token] renders registration form after token validation.
Check: Portal layout is independent (no operator navigation visible).
  </verify>
  <done>Portal has independent layout under /portal/* with own header and Toaster. Login page accepts email+password and redirects to portal dashboard. Registration page validates invite token and sets password. All UI is German and mobile-first with 48px touch targets.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all types resolve
2. `npm run build` succeeds -- no build errors
3. Middleware redirects unauthenticated /portal/* to /portal/login
4. Middleware allows /portal/login and /portal/register/* without session
5. Portal auth API routes work: login, register, verify-invite, logout, session, qr-token, qr-login
6. Portal session uses separate 'portal_session' cookie
7. Existing operator session is not affected by portal login/logout
8. Deactivated tenant (is_active=false) is rejected at login
9. Invite token is single-use (re-registration returns 409)
10. Portal layout is visually independent from operator dashboard
</verification>

<success_criteria>
- Tenant can register via invite link with email + password
- Tenant can log in and receives portal_session cookie
- Portal routes protected by middleware with tenant session validation
- Operator and tenant sessions use separate cookies (no interference)
- Deactivated tenants cannot log in
- Invite tokens are single-use and expire after 7 days
- Portal layout is independent (no operator UI leaks)
- QR token endpoint generates 5-minute login tokens
</success_criteria>

<output>
After completion, create `.planning/phases/26-tenant-portal-core/26-02-SUMMARY.md`
</output>
