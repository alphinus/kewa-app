---
phase: 26-tenant-portal-core
plan: 03
type: execute
wave: 2
depends_on: [26-01]
files_modified:
  - src/app/api/portal/tickets/route.ts
  - src/app/api/portal/tickets/[id]/route.ts
  - src/app/api/portal/tickets/[id]/messages/route.ts
  - src/app/api/portal/tickets/[id]/messages/read/route.ts
  - src/app/api/portal/tickets/[id]/cancel/route.ts
  - src/app/api/portal/tickets/[id]/attachments/route.ts
  - src/app/api/portal/categories/route.ts
  - src/app/api/portal/dashboard/route.ts
  - src/app/api/settings/route.ts
  - src/app/api/settings/categories/route.ts
  - src/app/api/settings/categories/[id]/route.ts
  - src/lib/portal/attachment-upload.ts
autonomous: true

must_haves:
  truths:
    - "Tenant can create a ticket with category, urgency, title, description, and optional photos"
    - "Tenant can list own tickets with status and last update"
    - "Tenant can view a ticket detail with all messages"
    - "Tenant can send messages on their own tickets"
    - "Tenant can cancel a ticket only when status is 'offen'"
    - "Tenant can attach up to 5 photos at ticket creation"
    - "Tenant can attach photos in follow-up messages"
    - "Read receipts are updated when tenant views operator messages"
    - "Dashboard endpoint returns open ticket count, unread message count, and recent tickets"
    - "Admin can manage ticket categories (CRUD)"
    - "All portal API routes enforce tenant data isolation"
  artifacts:
    - path: "src/app/api/portal/tickets/route.ts"
      provides: "GET (list tickets) and POST (create ticket) for tenant"
      exports: ["GET", "POST"]
    - path: "src/app/api/portal/tickets/[id]/route.ts"
      provides: "GET single ticket detail for tenant"
      exports: ["GET"]
    - path: "src/app/api/portal/tickets/[id]/messages/route.ts"
      provides: "GET (list messages) and POST (send message) for ticket thread"
      exports: ["GET", "POST"]
    - path: "src/app/api/portal/tickets/[id]/messages/read/route.ts"
      provides: "POST mark messages as read"
      exports: ["POST"]
    - path: "src/app/api/portal/tickets/[id]/cancel/route.ts"
      provides: "POST cancel ticket (only when offen)"
      exports: ["POST"]
    - path: "src/app/api/portal/tickets/[id]/attachments/route.ts"
      provides: "POST upload attachment for ticket or message"
      exports: ["POST"]
    - path: "src/app/api/portal/categories/route.ts"
      provides: "GET active ticket categories for portal"
      exports: ["GET"]
    - path: "src/app/api/portal/dashboard/route.ts"
      provides: "GET dashboard data (open count, unread count, recent tickets)"
      exports: ["GET"]
    - path: "src/lib/portal/attachment-upload.ts"
      provides: "Attachment upload and validation helpers for ticket photos"
      exports: ["uploadTicketAttachment", "validateAttachment", "MAX_TICKET_PHOTOS"]
  key_links:
    - from: "src/app/api/portal/tickets/route.ts"
      to: "src/lib/portal/ticket-queries.ts"
      via: "getTickets, createTicket query helpers"
      pattern: "getTickets|createTicket"
    - from: "src/app/api/portal/tickets/[id]/messages/route.ts"
      to: "src/lib/portal/message-queries.ts"
      via: "getTicketMessages, createMessage query helpers"
      pattern: "getTicketMessages|createMessage"
    - from: "src/app/api/portal/tickets/[id]/attachments/route.ts"
      to: "src/lib/portal/attachment-upload.ts"
      via: "uploadTicketAttachment for storage"
      pattern: "uploadTicketAttachment"
---

<objective>
Implement ticket CRUD API routes, message thread API routes, photo attachment upload, dashboard data endpoint, and admin category management.

Purpose: Full ticket lifecycle accessible via API. Tenants can create tickets, send messages, attach photos. Operators can be served by these same endpoints (with operator sender_type). Admin can configure categories.
Output: All portal data API routes, attachment upload helper, admin settings extensions.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-tenant-portal-core/26-CONTEXT.md
@.planning/phases/26-tenant-portal-core/26-RESEARCH.md
@src/lib/portal/tenant-isolation.ts
@src/lib/portal/ticket-queries.ts
@src/lib/portal/message-queries.ts
@src/lib/settings/queries.ts
@src/types/portal.ts
@src/app/api/auth/login/route.ts
@src/lib/storage/contractor-upload.ts
@src/app/api/contractor/[token]/[workOrderId]/upload/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ticket CRUD and dashboard API routes</name>
  <files>
    src/app/api/portal/tickets/route.ts
    src/app/api/portal/tickets/[id]/route.ts
    src/app/api/portal/tickets/[id]/cancel/route.ts
    src/app/api/portal/categories/route.ts
    src/app/api/portal/dashboard/route.ts
  </files>
  <action>
All portal API routes follow this pattern for auth:
```typescript
const userId = request.headers.get('x-portal-user-id')
if (!userId) {
  return NextResponse.json({ error: 'Nicht authentifiziert' }, { status: 401 })
}
```
The middleware sets x-portal-user-id for authenticated portal requests (Plan 02).

**src/app/api/portal/tickets/route.ts**:

GET handler:
- Get userId from x-portal-user-id header.
- Call getTickets(userId) from ticket-queries.ts.
- Return { tickets }.

POST handler:
- Get userId from header.
- Parse body: { category_id, title, description, urgency? }.
- Validate: category_id required (UUID), title required (non-empty, max 200 chars), description required (non-empty, max 2000 chars), urgency optional (must be valid enum value).
- Call createTicket(userId, input).
- Return { ticket } with status 201.

**src/app/api/portal/tickets/[id]/route.ts**:

GET handler:
- Get userId from header.
- Get ticketId from params.id.
- Call getTicketById(userId, ticketId). This internally verifies ownership.
- If not found/not owned, return 404.
- Return { ticket }.

**src/app/api/portal/tickets/[id]/cancel/route.ts**:

POST handler:
- Get userId from header.
- Get ticketId from params.id.
- Call cancelTicket(userId, ticketId). This internally verifies ownership and checks status = 'offen'.
- If ticket not found, return 404.
- If ticket status is not 'offen', return 400 with 'Ticket kann nur im Status "Offen" storniert werden'.
- Return { ticket } with updated status.

**src/app/api/portal/categories/route.ts**:

GET handler:
- Call getTicketCategories() from ticket-queries.ts (no auth needed for categories, but portal middleware still validates session).
- Return { categories }.

**src/app/api/portal/dashboard/route.ts**:

GET handler:
- Get userId from header.
- Call in parallel:
  - getOpenTicketCount(userId)
  - getUnreadMessageCount(userId) from message-queries.ts
  - getRecentTickets(userId, 5)
  - getTenantContext(userId) for unit info
- Query the unit details (name, building name) from supabase.
- Query getSetting('company_name') for portal header.
- Return { openTickets, unreadMessages, recentTickets, unit: { id, name, building }, companyName }.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Check: GET /api/portal/tickets returns tenant's own tickets only.
Check: POST /api/portal/tickets creates ticket linked to tenant's unit.
Check: POST /api/portal/tickets/[id]/cancel only works when status is 'offen'.
Check: GET /api/portal/dashboard returns aggregated data.
  </verify>
  <done>Ticket CRUD endpoints enforce tenant isolation. Ticket creation validates inputs and links to tenant's unit. Cancel only works for 'offen' status. Dashboard returns aggregated portal data with company name.</done>
</task>

<task type="auto">
  <name>Task 2: Message thread API routes, read receipts, and attachment upload</name>
  <files>
    src/app/api/portal/tickets/[id]/messages/route.ts
    src/app/api/portal/tickets/[id]/messages/read/route.ts
    src/app/api/portal/tickets/[id]/attachments/route.ts
    src/lib/portal/attachment-upload.ts
  </files>
  <action>
**src/app/api/portal/tickets/[id]/messages/route.ts**:

GET handler:
- Get userId, ticketId.
- Call getTicketMessages(userId, ticketId). Ownership verified internally.
- Also call markMessagesAsRead(userId, ticketId) to mark operator messages as read when tenant views them.
- Return { messages }.

POST handler:
- Get userId, ticketId.
- Parse body: { content }.
- Validate content is non-empty, max 5000 chars.
- Call createMessage(userId, ticketId, { content }).
- Return { message } with status 201.

**src/app/api/portal/tickets/[id]/messages/read/route.ts**:

POST handler:
- Get userId, ticketId.
- Call markMessagesAsRead(userId, ticketId).
- Return { success: true }.

**src/lib/portal/attachment-upload.ts** - Upload helper following patterns from src/lib/storage/contractor-upload.ts:

Constants:
- MAX_TICKET_PHOTOS = 5 (at ticket creation)
- MAX_FILE_SIZE = 10 * 1024 * 1024 (10MB)
- ALLOWED_PHOTO_TYPES = ['image/jpeg', 'image/png', 'image/webp']
- ALLOWED_OPERATOR_TYPES = [...ALLOWED_PHOTO_TYPES, 'application/pdf'] (operators can also attach PDFs)

Functions:
- `validateAttachment(file: File, senderType: 'tenant' | 'operator')`: Check file size and MIME type. Return { valid: boolean, error?: string }. German error messages.
- `uploadTicketAttachment(file: File, ticketId: string, messageId?: string)`: Upload to Supabase Storage. Path: `tickets/{ticketId}/photos/{uuid}.{ext}` or `tickets/{ticketId}/messages/{messageId}/{uuid}.{ext}`. Return { path, url }.
- `getAttachmentUrl(storagePath: string)`: Get public URL from Supabase Storage.

**src/app/api/portal/tickets/[id]/attachments/route.ts**:

POST handler (FormData):
- Get userId, ticketId.
- Verify ticket ownership.
- Parse FormData: files (multiple File objects), optional message_id.
- If no message_id (ticket-level attachments): enforce MAX_TICKET_PHOTOS limit. Query existing attachment count for this ticket where message_id IS NULL.
- Validate each file via validateAttachment().
- Upload each file via uploadTicketAttachment().
- Insert ticket_attachments rows in database.
- Return { attachments } with status 201.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Check: GET /api/portal/tickets/[id]/messages returns messages with attachments.
Check: POST creates message and marks operator messages as read on GET.
Check: POST /api/portal/tickets/[id]/attachments uploads files to storage.
Check: Ticket-level attachments enforce 5-photo limit.
  </verify>
  <done>Message thread endpoints support full send/receive with read receipts. Attachment upload validates file types and sizes. Ticket-level photos limited to 5. Message-level attachments unlimited. Storage paths follow existing conventions.</done>
</task>

<task type="auto">
  <name>Task 3: Admin settings and category management API routes</name>
  <files>
    src/app/api/settings/route.ts
    src/app/api/settings/categories/route.ts
    src/app/api/settings/categories/[id]/route.ts
  </files>
  <action>
**src/app/api/settings/route.ts** - Extend existing route:

The existing GET handler reads from system_settings. Extend it to ALSO read from app_settings (new table). Add a PUT handler for updating settings.

PUT handler:
- Verify admin role (x-user-role === 'kewa' or x-user-role-name === 'admin').
- Parse body: { key, value }.
- Call updateSetting(key, value, userId) from settings/queries.ts.
- Return { setting }.

If the existing GET already works with system_settings, keep it working. Add a separate endpoint or extend to include app_settings. The simplest approach: check if existing system_settings table is the same concept as app_settings. If they're different tables, the GET should merge both. If system_settings was already intended for this purpose, use it directly and add the new keys there instead of creating app_settings.

**Decision:** Check migration 062 -- if app_settings is a new table, the settings route should read from app_settings. If system_settings already exists, consider whether to use it instead. The existing settings route reads from system_settings. The new app_settings table is separate for portal-specific settings. Keep both. The existing /api/settings serves system_settings (operator UI). Add a new endpoint or extend the existing one.

Simplest: extend existing /api/settings GET to also return app_settings. Add PUT to update either table based on key prefix or a table parameter.

Actually, keep it clean: existing /api/settings for system_settings. Add /api/settings/app route for app_settings. OR modify the migration to use system_settings instead of a new table (since system_settings already exists and serves the same purpose).

**Final approach:** In migration 062, instead of creating a new app_settings table, INSERT the portal settings (company_name, support_email, notfall_phone) into the existing system_settings table (if it exists). Check the system_settings schema. If system_settings uses JSONB value column, adapt the inserts. If system_settings doesn't exist or has incompatible schema, create app_settings as planned.

For this plan, assume app_settings is created as a separate table (migration 062 handles this). The existing /api/settings route stays untouched. New routes:

**src/app/api/settings/route.ts** - UPDATE the existing file:

Add PUT handler:
- Verify admin role.
- Parse body: { key, value }.
- Try updating in app_settings first (for portal settings).
- Return updated setting.

Also modify GET to include app_settings data alongside system_settings.

**src/app/api/settings/categories/route.ts** - Category management for admin:

GET handler:
- Verify admin role.
- SELECT * FROM ticket_categories ORDER BY sort_order.
- Return { categories } (including inactive ones for admin).

POST handler:
- Verify admin role.
- Parse body: { name, display_name, description?, sort_order? }.
- INSERT into ticket_categories.
- Return { category } with status 201.

**src/app/api/settings/categories/[id]/route.ts** - Single category operations:

PUT handler:
- Verify admin role.
- Parse body: Partial<{ display_name, description, sort_order, is_active }>.
- UPDATE ticket_categories WHERE id = params.id.
- Return { category }.

DELETE handler:
- Verify admin role.
- Soft-delete: UPDATE is_active = false (don't actually delete since tickets reference categories).
- Return { success: true }.
  </action>
  <verify>
Run: `npx tsc --noEmit` -- no TypeScript errors.
Check: PUT /api/settings updates app_settings.
Check: GET /api/settings/categories returns all categories (including inactive) for admin.
Check: POST /api/settings/categories creates new category.
Check: PUT /api/settings/categories/[id] updates category.
Check: DELETE /api/settings/categories/[id] soft-deletes (is_active = false).
  </verify>
  <done>Admin settings route extended for app_settings CRUD. Category management supports full CRUD with soft-delete. Categories are configurable by admin without code changes.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes -- all types resolve
2. `npm run build` succeeds -- no build errors
3. GET /api/portal/tickets returns only the authenticated tenant's tickets
4. POST /api/portal/tickets creates ticket linked to tenant's unit
5. GET /api/portal/tickets/[id]/messages returns threaded messages with attachments
6. POST /api/portal/tickets/[id]/messages creates tenant message
7. POST /api/portal/tickets/[id]/cancel returns 400 if status != 'offen'
8. POST /api/portal/tickets/[id]/attachments enforces 5-photo limit at ticket level
9. GET /api/portal/dashboard returns aggregated portal data
10. Admin category CRUD works for authenticated admin users
11. No cross-tenant data leakage in any endpoint
</verification>

<success_criteria>
- Full ticket CRUD: create, list, detail, cancel
- Message threads: send, list with attachments, read receipts
- Photo attachments: upload with validation, 5-photo ticket limit
- Dashboard data: open count, unread count, recent tickets, unit info
- Admin category management: create, update, soft-delete
- All endpoints enforce tenant data isolation via session-derived user_id
</success_criteria>

<output>
After completion, create `.planning/phases/26-tenant-portal-core/26-03-SUMMARY.md`
</output>
