---
phase: 23-inspection-advanced
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/060_inspection_advanced.sql
  - src/types/inspections.ts
  - src/lib/inspections/re-inspection.ts
  - src/lib/inspections/queries.ts
  - src/app/api/inspections/[id]/re-inspect/route.ts
  - src/app/api/inspections/[id]/history/route.ts
  - src/components/inspections/ReInspectionButton.tsx
  - src/components/inspections/InspectionHistory.tsx
  - src/app/dashboard/abnahmen/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can schedule a re-inspection from a completed inspection"
    - "Re-inspection copies deferred defects from parent inspection"
    - "User can view inspection history chain (parent-child relationships)"
    - "Re-inspection shows badge indicating it's a follow-up inspection"
  artifacts:
    - path: "supabase/migrations/060_inspection_advanced.sql"
      provides: "Inspection portal tokens table and room condition trigger"
      contains: "CREATE TABLE inspection_portal_tokens"
    - path: "src/lib/inspections/re-inspection.ts"
      provides: "Re-inspection scheduling with defect propagation"
      exports: ["scheduleReInspection", "getInspectionHistory"]
    - path: "src/app/api/inspections/[id]/re-inspect/route.ts"
      provides: "API endpoint for scheduling re-inspections"
      exports: ["POST"]
    - path: "src/components/inspections/InspectionHistory.tsx"
      provides: "Timeline view of inspection chain"
      min_lines: 40
  key_links:
    - from: "src/app/api/inspections/[id]/re-inspect/route.ts"
      to: "src/lib/inspections/re-inspection.ts"
      via: "scheduleReInspection function call"
      pattern: "scheduleReInspection"
    - from: "src/app/dashboard/abnahmen/[id]/page.tsx"
      to: "ReInspectionButton, InspectionHistory"
      via: "component imports"
      pattern: "ReInspectionButton|InspectionHistory"
---

<objective>
Create re-inspection scheduling with parent-child tracking and defect propagation.

Purpose: Enable follow-up inspections when initial inspection has deferred defects. Users can track inspection history chain and see which defects were carried forward.

Output:
- Migration with inspection_portal_tokens table (prep for 23-02) and room condition trigger (prep for 23-03)
- Re-inspection scheduling API with deferred defect copy
- Inspection history query returning full parent-child chain
- UI components for scheduling re-inspections and viewing history
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-inspection-core/22-01-SUMMARY.md
@.planning/phases/22-inspection-core/22-03-SUMMARY.md
@.planning/phases/21-change-orders/21-04-SUMMARY.md
@.planning/phases/23-inspection-advanced/23-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration with portal tokens table and room condition trigger</name>
  <files>supabase/migrations/060_inspection_advanced.sql</files>
  <action>
Create migration 060_inspection_advanced.sql with:

1. **inspection_portal_tokens join table**:
```sql
CREATE TABLE inspection_portal_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  token UUID NOT NULL REFERENCES magic_link_tokens(token) ON DELETE CASCADE,
  inspection_id UUID NOT NULL REFERENCES inspections(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(token, inspection_id)
);

CREATE INDEX idx_inspection_portal_tokens_token ON inspection_portal_tokens(token);
CREATE INDEX idx_inspection_portal_tokens_inspection ON inspection_portal_tokens(inspection_id);
```

2. **Room condition update trigger** (fires when inspection status changes to 'signed'):
```sql
CREATE OR REPLACE FUNCTION update_room_condition_from_inspection()
RETURNS TRIGGER AS $$
DECLARE
  v_room_id UUID;
  v_new_condition room_condition;
  v_project_id UUID;
BEGIN
  -- Only process when inspection reaches 'signed' status
  IF NEW.status = 'signed' AND OLD.status != 'signed' THEN
    -- Find project_id
    IF NEW.work_order_id IS NOT NULL THEN
      SELECT project_id, room_id INTO v_project_id, v_room_id
      FROM work_orders WHERE id = NEW.work_order_id;
    ELSE
      v_project_id := NEW.project_id;
    END IF;

    -- Only update if single room identified via work_order
    IF v_room_id IS NOT NULL THEN
      -- Map overall_result to room condition
      CASE NEW.overall_result
        WHEN 'passed' THEN v_new_condition := 'new';
        WHEN 'passed_with_conditions' THEN v_new_condition := 'partial';
        ELSE v_new_condition := NULL; -- failed = no improvement
      END CASE;

      IF v_new_condition IS NOT NULL THEN
        UPDATE rooms SET
          condition = v_new_condition,
          condition_updated_at = NOW(),
          condition_source_project_id = v_project_id
        WHERE id = v_room_id;

        RAISE NOTICE 'Updated room % condition to % from inspection %', v_room_id, v_new_condition, NEW.id;
      END IF;
    ELSE
      RAISE NOTICE 'Inspection % has no direct room link, skipping condition update', NEW.id;
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER inspection_update_room_condition
  AFTER UPDATE OF status ON inspections
  FOR EACH ROW
  WHEN (NEW.status = 'signed' AND OLD.status IS DISTINCT FROM NEW.status)
  EXECUTE FUNCTION update_room_condition_from_inspection();
```

3. **RLS policies** for inspection_portal_tokens (authenticated users can manage, public can read via token).

4. **Comments** documenting each table and function.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify no type errors. Migration SQL syntax validated against existing patterns (057, 058).
  </verify>
  <done>
Migration file exists with portal tokens table, room condition trigger, RLS policies, and comments.
  </done>
</task>

<task type="auto">
  <name>Task 2: Re-inspection library functions and API routes</name>
  <files>
src/lib/inspections/re-inspection.ts
src/lib/inspections/queries.ts
src/types/inspections.ts
src/app/api/inspections/[id]/re-inspect/route.ts
src/app/api/inspections/[id]/history/route.ts
  </files>
  <action>
**src/lib/inspections/re-inspection.ts** - Create re-inspection scheduling logic:

```typescript
import { createClient } from '@/lib/supabase/server'
import { Inspection, InspectionDefect, CreateInspectionInput } from '@/types/inspections'

export async function scheduleReInspection(
  parentInspectionId: string,
  scheduledDate: string,
  inspectorId?: string
): Promise<Inspection> {
  const supabase = await createClient()

  // Fetch parent inspection with defects
  const { data: parent, error: parentError } = await supabase
    .from('inspections')
    .select('*, defects:inspection_defects(*)')
    .eq('id', parentInspectionId)
    .single()

  if (parentError || !parent) throw new Error('Parent inspection not found')

  // Parent must be completed or signed
  if (!['completed', 'signed'].includes(parent.status)) {
    throw new Error('Cannot create re-inspection from incomplete inspection')
  }

  // Create re-inspection with parent link
  const { data: reInspection, error: createError } = await supabase
    .from('inspections')
    .insert({
      parent_inspection_id: parent.id,
      work_order_id: parent.work_order_id,
      project_id: parent.project_id,
      template_id: parent.template_id,
      title: `Nachkontrolle: ${parent.title}`,
      description: `Re-Inspektion von ${new Date(parent.inspection_date).toLocaleDateString('de-CH')}`,
      inspector_id: inspectorId || parent.inspector_id,
      inspection_date: scheduledDate,
      status: 'in_progress',
      checklist_items: parent.checklist_items, // Copy checklist structure
    })
    .select()
    .single()

  if (createError) throw createError

  // Copy deferred defects from parent
  const deferredDefects = (parent.defects || []).filter(d => d.action === 'deferred')

  if (deferredDefects.length > 0) {
    const newDefects = deferredDefects.map(d => ({
      inspection_id: reInspection.id,
      title: d.title,
      description: `(Aus vorheriger Abnahme) ${d.description || ''}`,
      severity: d.severity,
      status: 'open',
      notes: `Original defect ID: ${d.id}`,
    }))

    await supabase.from('inspection_defects').insert(newDefects)
  }

  return reInspection
}

export async function getInspectionHistory(inspectionId: string): Promise<Inspection[]> {
  const supabase = await createClient()

  // Find root inspection by traversing up
  let currentId = inspectionId
  const history: Inspection[] = []

  while (currentId) {
    const { data } = await supabase
      .from('inspections')
      .select('*, defects:inspection_defects(count)')
      .eq('id', currentId)
      .single()

    if (!data) break
    history.unshift(data) // Add at beginning (oldest first)
    currentId = data.parent_inspection_id
  }

  // Now get all children of the current inspection
  const { data: children } = await supabase
    .from('inspections')
    .select('*, defects:inspection_defects(count)')
    .eq('parent_inspection_id', inspectionId)
    .order('created_at', { ascending: true })

  if (children) {
    history.push(...children)
  }

  return history
}
```

**src/types/inspections.ts** - Add re-inspection types (append to existing):
```typescript
export interface InspectionHistoryItem extends Inspection {
  defect_count?: number
  is_current?: boolean
}
```

**src/app/api/inspections/[id]/re-inspect/route.ts** - POST endpoint:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { scheduleReInspection } from '@/lib/inspections/re-inspection'
import { getCurrentUser } from '@/lib/auth'

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const user = await getCurrentUser()
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  const body = await request.json()
  const { scheduled_date, inspector_id } = body

  if (!scheduled_date) {
    return NextResponse.json({ error: 'scheduled_date required' }, { status: 400 })
  }

  try {
    const reInspection = await scheduleReInspection(id, scheduled_date, inspector_id)
    return NextResponse.json(reInspection, { status: 201 })
  } catch (error) {
    return NextResponse.json({ error: (error as Error).message }, { status: 400 })
  }
}
```

**src/app/api/inspections/[id]/history/route.ts** - GET endpoint:
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getInspectionHistory } from '@/lib/inspections/re-inspection'
import { getCurrentUser } from '@/lib/auth'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params
  const user = await getCurrentUser()
  if (!user) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  const history = await getInspectionHistory(id)
  return NextResponse.json(history)
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` and verify no type errors. Check imports resolve correctly.
  </verify>
  <done>
Re-inspection scheduling creates new inspection linked to parent with deferred defects copied. History API returns full chain.
  </done>
</task>

<task type="auto">
  <name>Task 3: Re-inspection UI components and page integration</name>
  <files>
src/components/inspections/ReInspectionButton.tsx
src/components/inspections/InspectionHistory.tsx
src/app/dashboard/abnahmen/[id]/page.tsx
  </files>
  <action>
**src/components/inspections/ReInspectionButton.tsx** - Button + dialog for scheduling:
```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Inspection } from '@/types/inspections'

interface ReInspectionButtonProps {
  inspection: Inspection
}

export function ReInspectionButton({ inspection }: ReInspectionButtonProps) {
  const router = useRouter()
  const [isOpen, setIsOpen] = useState(false)
  const [date, setDate] = useState('')
  const [loading, setLoading] = useState(false)

  // Only show for completed/signed inspections with open or deferred defects
  const canSchedule = ['completed', 'signed'].includes(inspection.status)

  if (!canSchedule) return null

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    if (!date) return

    setLoading(true)
    try {
      const res = await fetch(`/api/inspections/${inspection.id}/re-inspect`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ scheduled_date: date }),
      })

      if (res.ok) {
        const newInspection = await res.json()
        router.push(`/dashboard/abnahmen/${newInspection.id}`)
      }
    } finally {
      setLoading(false)
      setIsOpen(false)
    }
  }

  return (
    <>
      <button
        onClick={() => setIsOpen(true)}
        className="px-4 py-2 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700"
      >
        Nachkontrolle planen
      </button>

      {isOpen && (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 w-full max-w-md">
            <h3 className="text-lg font-semibold mb-4">Nachkontrolle planen</h3>
            <form onSubmit={handleSubmit}>
              <label className="block mb-4">
                <span className="text-sm text-gray-600">Datum</span>
                <input
                  type="date"
                  value={date}
                  onChange={e => setDate(e.target.value)}
                  min={new Date().toISOString().split('T')[0]}
                  className="w-full mt-1 px-3 py-2 border rounded-lg"
                  required
                />
              </label>
              <p className="text-sm text-gray-500 mb-4">
                Die Checkliste und offene Maengel werden uebernommen.
              </p>
              <div className="flex gap-3 justify-end">
                <button
                  type="button"
                  onClick={() => setIsOpen(false)}
                  className="px-4 py-2 text-sm border rounded-lg"
                >
                  Abbrechen
                </button>
                <button
                  type="submit"
                  disabled={loading || !date}
                  className="px-4 py-2 text-sm bg-blue-600 text-white rounded-lg disabled:opacity-50"
                >
                  {loading ? 'Erstelle...' : 'Erstellen'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </>
  )
}
```

**src/components/inspections/InspectionHistory.tsx** - Timeline view:
```typescript
'use client'

import { useEffect, useState } from 'react'
import Link from 'next/link'
import { Inspection } from '@/types/inspections'
import { InspectionStatusBadge } from './InspectionStatusBadge'

interface InspectionHistoryProps {
  inspectionId: string
  currentInspectionId: string
}

export function InspectionHistory({ inspectionId, currentInspectionId }: InspectionHistoryProps) {
  const [history, setHistory] = useState<Inspection[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetch(`/api/inspections/${inspectionId}/history`)
      .then(res => res.json())
      .then(data => {
        setHistory(data)
        setLoading(false)
      })
  }, [inspectionId])

  if (loading) return <div className="text-sm text-gray-500">Lade Verlauf...</div>
  if (history.length <= 1) return null // No history to show

  return (
    <div className="bg-gray-50 rounded-lg p-4">
      <h4 className="text-sm font-semibold mb-3">Inspektionsverlauf</h4>
      <div className="space-y-2">
        {history.map((item, index) => (
          <div
            key={item.id}
            className={`flex items-center gap-3 p-2 rounded ${
              item.id === currentInspectionId ? 'bg-blue-50 border border-blue-200' : ''
            }`}
          >
            <div className="w-6 h-6 rounded-full bg-gray-200 flex items-center justify-center text-xs">
              {index + 1}
            </div>
            <div className="flex-1 min-w-0">
              <Link
                href={`/dashboard/abnahmen/${item.id}`}
                className="text-sm font-medium hover:underline truncate block"
              >
                {item.title}
              </Link>
              <span className="text-xs text-gray-500">
                {new Date(item.inspection_date).toLocaleDateString('de-CH')}
              </span>
            </div>
            <InspectionStatusBadge status={item.status} />
          </div>
        ))}
      </div>
    </div>
  )
}
```

**src/app/dashboard/abnahmen/[id]/page.tsx** - Integrate components:
- Import ReInspectionButton and InspectionHistory
- Add InspectionHistory below inspection details (only if parent_inspection_id exists OR inspection has children)
- Add ReInspectionButton in action buttons section for completed/signed inspections
- Show "Nachkontrolle" badge if inspection.parent_inspection_id is set
  </action>
  <verify>
Run `npm run build` to verify page compiles. Check ReInspectionButton only shows for completed/signed inspections.
  </verify>
  <done>
Re-inspection button schedules follow-up inspection. History timeline shows parent-child chain. Badge indicates follow-up inspection.
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit` passes
2. Build: `npm run build` completes without errors
3. Migration: SQL syntax valid (manual review against 057, 058 patterns)
4. Re-inspection creates new inspection with parent_inspection_id set
5. Deferred defects copied to new inspection
6. History API returns inspection chain from root to current
7. UI shows re-inspection button only for completed/signed inspections
</verification>

<success_criteria>
- User can click "Nachkontrolle planen" on completed inspection
- New re-inspection created with parent link and copied checklist
- Deferred defects from parent appear in re-inspection
- User can view inspection history timeline
- Badge shows "Nachkontrolle" for follow-up inspections
</success_criteria>

<output>
After completion, create `.planning/phases/23-inspection-advanced/23-01-SUMMARY.md`
</output>
