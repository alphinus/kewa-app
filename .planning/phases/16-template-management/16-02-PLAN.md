---
phase: 16-template-management
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/templates/[id]/duplicate/route.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/templates/[id]/duplicate creates deep copy of template"
    - "Duplicated template includes all phases, packages, tasks, dependencies, and quality gates"
    - "Duplicated template has new name and is_active=true"
  artifacts:
    - path: "src/app/api/templates/[id]/duplicate/route.ts"
      provides: "Template duplication endpoint"
      exports: ["POST"]
      min_lines: 100
  key_links:
    - from: "src/app/api/templates/[id]/duplicate/route.ts"
      to: "supabase"
      via: "INSERT queries for all hierarchy levels"
      pattern: "supabase.*insert"
---

<objective>
Create template duplication API endpoint for deep copying templates.

Purpose: Backend for duplicate button added in 16-01. CONTEXT.md specifies duplicate should copy full hierarchy.
Output: POST /api/templates/[id]/duplicate endpoint that creates complete deep copy.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-template-management/16-CONTEXT.md
@.planning/phases/16-template-management/16-RESEARCH.md

# Reference existing template API
@src/app/api/templates/[id]/route.ts
@src/types/templates.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create duplicate template API endpoint</name>
  <files>src/app/api/templates/[id]/duplicate/route.ts</files>
  <action>
    Create POST endpoint that:
    1. Requires kewa role (admin only)
    2. Accepts { name: string } in body (new template name)
    3. Fetches source template with full hierarchy (phases, packages, tasks)
    4. Fetches dependencies and quality_gates for source template
    5. Creates new template with:
       - New UUID
       - Provided name (or "{original name} (Kopie)" if not provided)
       - Same category, scope, target_room_type
       - is_active: true
       - description copied
    6. For each phase: create new phase with new IDs, preserving sort_order, wbs_code
    7. For each package: create new package linked to new phase ID
    8. For each task: create new task linked to new package ID
    9. Build ID mapping: oldTaskId -> newTaskId
    10. For each dependency: create new dependency using mapped task IDs
    11. For each quality_gate: create new gate with mapped phase/package IDs

    Use transaction pattern (insert all or rollback on error):
    - Insert template first
    - Build phase ID map while inserting phases
    - Build package ID map while inserting packages
    - Build task ID map while inserting tasks
    - Remap and insert dependencies
    - Remap and insert quality gates

    Return: { template: Template } with the new template (without hierarchy for response size)

    Error handling:
    - 404 if source template not found
    - 400 if name empty
    - 500 on insert failure with rollback
  </action>
  <verify>
    curl -X POST /api/templates/{id}/duplicate -d '{"name":"Test Copy"}' returns new template
    Verify new template has all phases, packages, tasks copied
  </verify>
  <done>
    Duplicate endpoint creates full deep copy including phases, packages, tasks, dependencies, quality gates
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire duplicate in list page</name>
  <files>src/app/templates/page.tsx</files>
  <action>
    Add handleDuplicate function to TemplatesPage:
    ```typescript
    async function handleDuplicate(id: string) {
      const template = templates.find(t => t.id === id)
      const newName = prompt('Name fuer die Kopie:', template ? `${template.name} (Kopie)` : 'Kopie')
      if (!newName) return

      try {
        const newTemplate = await duplicateTemplate(id, newName)
        // Redirect to edit the new template
        router.push(`/templates/${newTemplate.id}/edit`)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Fehler beim Duplizieren')
      }
    }
    ```

    Pass onDuplicate={handleDuplicate} to TemplateCard components.

    Import duplicateTemplate from @/lib/api/templates and useRouter.
  </action>
  <verify>Click Duplicate on a template, enter name, confirm redirect to edit page of new copy</verify>
  <done>Duplicate button works end-to-end: prompts for name, creates copy, redirects to edit</done>
</task>

</tasks>

<verification>
1. POST /api/templates/[id]/duplicate returns new template
2. New template has unique ID and provided name
3. All phases copied with new IDs
4. All packages copied with new IDs linked to new phases
5. All tasks copied with new IDs linked to new packages
6. Dependencies remapped to new task IDs
7. Quality gates remapped to new phase/package IDs
8. Clicking Duplicate in UI creates copy and redirects to edit
</verification>

<success_criteria>
- Deep copy preserves full WBS hierarchy
- Dependencies and quality gates correctly remapped
- UI workflow: Duplicate -> Name prompt -> Redirect to edit
- Admin-only access
</success_criteria>

<output>
After completion, create `.planning/phases/16-template-management/16-02-SUMMARY.md`
</output>
