---
phase: 14-multi-liegenschaft
plan: 03
type: execute
wave: 2
depends_on: ["14-02"]
files_modified:
  - src/app/api/projects/route.ts
  - src/app/api/tasks/route.ts
autonomous: true

must_haves:
  truths:
    - "GET /api/projects accepts ?building_id= query param to filter projects"
    - "GET /api/tasks accepts ?building_id= query param to filter tasks"
    - "When building_id is 'all' or omitted, returns unfiltered data"
    - "Filtering follows chain: building -> unit -> project (for projects), building -> unit -> project -> task (for tasks)"
  artifacts:
    - path: "src/app/api/projects/route.ts"
      provides: "Project list with building_id filter support"
      exports: ["GET", "POST"]
    - path: "src/app/api/tasks/route.ts"
      provides: "Task list with building_id filter support"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/projects/route.ts"
      to: "projects table via units"
      via: "join query with building filter"
      pattern: "building_id"
    - from: "src/app/api/tasks/route.ts"
      to: "tasks table via projects/units"
      via: "nested filter"
      pattern: "building_id"
---

<objective>
Add building_id filter support to projects and tasks API routes.

Purpose: Enable data scoping by selected building for the projects and tasks pages.
Output: Updated API routes that accept building_id query parameter.
</objective>

<execution_context>
@C:\Users\Mario Giacchino\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Mario Giacchino\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-multi-liegenschaft/14-CONTEXT.md

# Existing API routes to modify
@src/app/api/projects/route.ts
@src/app/api/tasks/route.ts

# Data model reference
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add building_id filter to projects API</name>
  <files>src/app/api/projects/route.ts</files>
  <action>
Modify GET /api/projects:

1. Parse building_id from query params (existing: unit_id, include_archived)
2. If building_id provided and not 'all':
   - Join with units table to filter: projects.unit_id -> units.building_id
   - Use Supabase nested filter or inner join approach:
     ```typescript
     // Option 1: Filter via unit relationship
     query = query.eq('unit.building_id', buildingId)

     // Option 2: If above doesn't work with existing select, use RPC or subquery
     // First get unit IDs for building, then filter projects
     ```
3. If building_id is 'all' or not provided: no additional filter (existing behavior)
4. Keep existing filters (unit_id, include_archived, visible_to_imeri for Imeri role)

The query already includes unit data: `unit:units(id, name, unit_type, floor)`. Need to add building_id filter through this relationship.

Supabase approach for filtering on joined column:
```typescript
if (buildingIdFilter && buildingIdFilter !== 'all') {
  // Get units for this building first
  const { data: unitIds } = await supabase
    .from('units')
    .select('id')
    .eq('building_id', buildingIdFilter)

  if (unitIds && unitIds.length > 0) {
    query = query.in('unit_id', unitIds.map(u => u.id))
  } else {
    // No units in this building = no projects
    return NextResponse.json({ projects: [] })
  }
}
```
  </action>
  <verify>
- `curl /api/projects?building_id={uuid}` returns only projects in that building
- `curl /api/projects?building_id=all` returns all projects
- `curl /api/projects` returns all projects (backward compatible)
  </verify>
  <done>Projects API filters by building_id when provided</done>
</task>

<task type="auto">
  <name>Task 2: Add building_id filter to tasks API</name>
  <files>src/app/api/tasks/route.ts</files>
  <action>
Modify GET /api/tasks:

1. Parse building_id from query params
2. If building_id provided and not 'all':
   - Tasks link to projects, projects link to units, units link to buildings
   - Chain: task.project_id -> project.unit_id -> unit.building_id
   - Approach: First get project IDs for the building, then filter tasks
   ```typescript
   if (buildingIdFilter && buildingIdFilter !== 'all') {
     // Get units for building
     const { data: units } = await supabase
       .from('units')
       .select('id')
       .eq('building_id', buildingIdFilter)

     if (!units || units.length === 0) {
       return NextResponse.json({ tasks: [] })
     }

     // Get projects for those units
     const { data: projects } = await supabase
       .from('projects')
       .select('id')
       .in('unit_id', units.map(u => u.id))

     if (!projects || projects.length === 0) {
       return NextResponse.json({ tasks: [] })
     }

     query = query.in('project_id', projects.map(p => p.id))
   }
   ```
3. If building_id is 'all' or not provided: no additional filter
4. Keep existing filters (project_id, status, visible_to_imeri)

Review existing task query to ensure approach is compatible with current select/joins.
  </action>
  <verify>
- `curl /api/tasks?building_id={uuid}` returns only tasks in that building
- `curl /api/tasks?building_id=all` returns all tasks
- `curl /api/tasks` returns all tasks (backward compatible)
  </verify>
  <done>Tasks API filters by building_id when provided</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - no TypeScript errors
2. Test projects filter: create projects in different buildings, verify filter returns correct subset
3. Test tasks filter: create tasks in different buildings, verify filter returns correct subset
4. Verify backward compatibility: API without building_id param returns all data
</verification>

<success_criteria>
- GET /api/projects?building_id=X returns only projects in building X
- GET /api/tasks?building_id=X returns only tasks in building X
- 'all' and missing building_id return unfiltered data
- Existing query params (unit_id, status, etc.) still work
- No breaking changes to existing API consumers
</success_criteria>

<output>
After completion, create `.planning/phases/14-multi-liegenschaft/14-03-SUMMARY.md`
</output>
