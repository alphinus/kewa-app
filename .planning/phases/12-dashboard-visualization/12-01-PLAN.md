# Plan 12-01: Parking Schema & Basic Display

---
phase: 12
plan: 01
name: Parking Schema & Basic Display
wave: 1
depends_on: []
scope: medium
autonomous: true
files_modified:
  - supabase/migrations/039_parking_spots.sql
  - src/types/index.ts
  - src/types/database.ts
  - src/lib/parking/parking-queries.ts
  - src/components/parking/ParkingSection.tsx
  - src/components/parking/ParkingSpotCard.tsx
  - src/app/api/parking/[id]/route.ts
requirements:
  - PARK-01
  - PARK-02
  - PARK-03
  - PARK-04
---

## Objective

Establish parking data model by extending the units table and create vertical display showing 8 parking spots with status management.

## Context

From 12-RESEARCH.md and 12-CONTEXT.md:
- Parking uses existing units table with new `parking_spot` type (not separate table)
- Status: free | occupied | maintenance (simplified)
- 8 spots displayed vertically alongside building
- Inline assignment/status change from dashboard
- Existing pattern: units table has `tenant_name`, `rent_amount` - reuse for parking

Existing code references:
- `supabase/migrations/001_initial_schema.sql` - units table with unit_type CHECK
- `src/components/building/BuildingGrid.tsx` - building layout pattern
- `src/components/building/UnitCell.tsx` - card display pattern

## Tasks

<task id="01" title="Create parking migration">
Add parking_spot type and parking-specific fields to units table.

**File:** `supabase/migrations/039_parking_spots.sql`

<subtask id="01a">Create parking status type</subtask>
```sql
-- Parking spot status enum
CREATE TYPE parking_status AS ENUM ('free', 'occupied', 'maintenance');
```

<subtask id="01b">Alter units table for parking</subtask>
```sql
-- Add parking_spot to unit_type CHECK constraint
-- Note: PostgreSQL doesn't have native enum extension, use CHECK constraint update
ALTER TABLE units DROP CONSTRAINT IF EXISTS units_unit_type_check;
ALTER TABLE units ADD CONSTRAINT units_unit_type_check
  CHECK (unit_type IN ('apartment', 'common_area', 'building', 'parking_spot'));

-- Add parking-specific fields
ALTER TABLE units
ADD COLUMN IF NOT EXISTS parking_number INTEGER,
ADD COLUMN IF NOT EXISTS parking_status parking_status DEFAULT 'free';

-- Index for parking queries
CREATE INDEX IF NOT EXISTS idx_units_parking_status ON units(parking_status) WHERE unit_type = 'parking_spot';
```

<subtask id="01c">Seed 8 parking spots</subtask>
```sql
-- Insert 8 parking spots for the existing building
INSERT INTO units (building_id, name, unit_type, parking_number, parking_status)
SELECT
  b.id,
  'Parkplatz ' || n,
  'parking_spot',
  n,
  'free'
FROM buildings b
CROSS JOIN generate_series(1, 8) AS n
WHERE b.id = '00000000-0000-0000-0001-000000000001'
  AND NOT EXISTS (
    SELECT 1 FROM units u
    WHERE u.building_id = b.id AND u.unit_type = 'parking_spot'
  );
```
</task>

<task id="02" title="Add TypeScript types" depends_on="01">
Add ParkingStatus type and extend Unit type.

**File:** `src/types/index.ts`

Add after UnitType definition:
```typescript
// Parking spot status
export type ParkingStatus = 'free' | 'occupied' | 'maintenance'
```

**File:** `src/types/database.ts`

Extend Unit interface:
```typescript
export interface Unit {
  // ... existing fields
  parking_number: number | null
  parking_status: ParkingStatus | null
}
```

Add ParkingSpot type alias for clarity:
```typescript
export type ParkingSpot = Unit & {
  unit_type: 'parking_spot'
  parking_number: number
  parking_status: ParkingStatus
}
```
</task>

<task id="03" title="Create parking query module" depends_on="02">
Server-side queries for fetching and updating parking data.

**File:** `src/lib/parking/parking-queries.ts`

```typescript
import { createClient } from '@/lib/supabase/server'
import type { ParkingSpot, ParkingStatus } from '@/types/database'

export async function fetchParkingSpots(buildingId: string): Promise<ParkingSpot[]> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('units')
    .select('*')
    .eq('building_id', buildingId)
    .eq('unit_type', 'parking_spot')
    .order('parking_number', { ascending: true })

  if (error) {
    console.error('Error fetching parking spots:', error)
    return []
  }

  return data as ParkingSpot[]
}

export async function updateParkingStatus(
  spotId: string,
  status: ParkingStatus,
  tenantName?: string | null
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient()

  const { error } = await supabase
    .from('units')
    .update({
      parking_status: status,
      tenant_name: tenantName ?? null
    })
    .eq('id', spotId)
    .eq('unit_type', 'parking_spot')

  if (error) {
    return { success: false, error: error.message }
  }

  return { success: true }
}

export async function getParkingStats(buildingId: string): Promise<{
  total: number
  occupied: number
  free: number
  maintenance: number
}> {
  const spots = await fetchParkingSpots(buildingId)

  return {
    total: spots.length,
    occupied: spots.filter(s => s.parking_status === 'occupied').length,
    free: spots.filter(s => s.parking_status === 'free').length,
    maintenance: spots.filter(s => s.parking_status === 'maintenance').length
  }
}
```
</task>

<task id="04" title="Create ParkingSpotCard component" depends_on="02">
Individual parking spot display with status and tenant info.

**File:** `src/components/parking/ParkingSpotCard.tsx`

```typescript
'use client'

import { cn } from '@/lib/utils'
import type { ParkingSpot, ParkingStatus } from '@/types/database'

const STATUS_STYLES: Record<ParkingStatus, string> = {
  free: 'bg-green-50 border-green-200 dark:bg-green-900/20 dark:border-green-800',
  occupied: 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800',
  maintenance: 'bg-amber-50 border-amber-200 dark:bg-amber-900/20 dark:border-amber-800'
}

const STATUS_LABELS: Record<ParkingStatus, string> = {
  free: 'Frei',
  occupied: 'Belegt',
  maintenance: 'Wartung'
}

const STATUS_BADGE_STYLES: Record<ParkingStatus, string> = {
  free: 'bg-green-100 text-green-800 dark:bg-green-900/40 dark:text-green-300',
  occupied: 'bg-blue-100 text-blue-800 dark:bg-blue-900/40 dark:text-blue-300',
  maintenance: 'bg-amber-100 text-amber-800 dark:bg-amber-900/40 dark:text-amber-300'
}

interface ParkingSpotCardProps {
  spot: ParkingSpot
  onClick?: () => void
  compact?: boolean
}

export function ParkingSpotCard({ spot, onClick, compact = false }: ParkingSpotCardProps) {
  return (
    <button
      type="button"
      onClick={onClick}
      className={cn(
        'w-full text-left rounded-lg border transition-all duration-200',
        'hover:shadow-md hover:scale-[1.02]',
        'active:scale-[0.98]',
        STATUS_STYLES[spot.parking_status],
        compact ? 'p-2' : 'p-3'
      )}
    >
      <div className="flex items-center justify-between">
        <span className={cn(
          'font-medium text-gray-900 dark:text-gray-100',
          compact ? 'text-xs' : 'text-sm'
        )}>
          P{spot.parking_number}
        </span>
        <span className={cn(
          'px-1.5 py-0.5 rounded-full text-[10px] font-medium',
          STATUS_BADGE_STYLES[spot.parking_status]
        )}>
          {STATUS_LABELS[spot.parking_status]}
        </span>
      </div>

      {spot.tenant_name && spot.parking_status === 'occupied' && (
        <p className={cn(
          'text-gray-600 dark:text-gray-400 truncate mt-1',
          compact ? 'text-[10px]' : 'text-xs'
        )}>
          {spot.tenant_name}
        </p>
      )}

      {spot.rent_amount && (
        <p className={cn(
          'text-gray-500 dark:text-gray-500 mt-1',
          compact ? 'text-[9px]' : 'text-xs'
        )}>
          CHF {spot.rent_amount}/Mt.
        </p>
      )}
    </button>
  )
}
```
</task>

<task id="05" title="Create ParkingSection component" depends_on="03,04">
Vertical display of all 8 parking spots.

**File:** `src/components/parking/ParkingSection.tsx`

```typescript
import { fetchParkingSpots } from '@/lib/parking/parking-queries'
import { ParkingSpotCard } from './ParkingSpotCard'
import { cn } from '@/lib/utils'

interface ParkingSectionProps {
  buildingId: string
  onSpotClick?: (spotId: string) => void
  className?: string
}

export async function ParkingSection({
  buildingId,
  onSpotClick,
  className
}: ParkingSectionProps) {
  const spots = await fetchParkingSpots(buildingId)

  if (spots.length === 0) {
    return (
      <div className={cn(
        'p-4 text-center text-gray-500 dark:text-gray-400',
        'bg-gray-50 dark:bg-gray-800/50 rounded-lg',
        className
      )}>
        Keine Parkplaetze konfiguriert.
      </div>
    )
  }

  return (
    <div className={cn('space-y-2', className)}>
      <h3 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
        Parkplaetze
      </h3>
      <div className="flex flex-col gap-2">
        {spots.map((spot) => (
          <ParkingSpotCard
            key={spot.id}
            spot={spot}
            onClick={onSpotClick ? () => onSpotClick(spot.id) : undefined}
            compact
          />
        ))}
      </div>
    </div>
  )
}
```
</task>

<task id="06" title="Create parking API route" depends_on="03">
API endpoint for updating parking status (KEWA only).

**File:** `src/app/api/parking/[id]/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import { updateParkingStatus } from '@/lib/parking/parking-queries'
import type { ParkingStatus } from '@/types'

interface RouteParams {
  params: Promise<{ id: string }>
}

export async function PATCH(request: Request, { params }: RouteParams) {
  const { id } = await params

  // Check KEWA auth
  const cookieStore = await cookies()
  const sessionCookie = cookieStore.get('kewa-session')

  if (!sessionCookie?.value) {
    return NextResponse.json({ error: 'Nicht autorisiert' }, { status: 401 })
  }

  try {
    const session = JSON.parse(sessionCookie.value)
    if (session.role !== 'kewa') {
      return NextResponse.json({ error: 'Keine Berechtigung' }, { status: 403 })
    }
  } catch {
    return NextResponse.json({ error: 'Ungueltige Session' }, { status: 401 })
  }

  // Parse body
  const body = await request.json()
  const { status, tenant_name } = body as {
    status: ParkingStatus
    tenant_name?: string | null
  }

  if (!status || !['free', 'occupied', 'maintenance'].includes(status)) {
    return NextResponse.json(
      { error: 'Ungueltiger Status' },
      { status: 400 }
    )
  }

  const result = await updateParkingStatus(id, status, tenant_name)

  if (!result.success) {
    return NextResponse.json(
      { error: result.error || 'Fehler beim Aktualisieren' },
      { status: 500 }
    )
  }

  return NextResponse.json({ success: true })
}
```
</task>

## Verification

<verification>
- [ ] Migration 039 creates parking_status type
- [ ] Migration 039 adds parking_spot to unit_type constraint
- [ ] Migration 039 seeds 8 parking spots
- [ ] TypeScript types include ParkingStatus and ParkingSpot
- [ ] fetchParkingSpots returns parking data ordered by number
- [ ] ParkingSpotCard displays status with correct colors
- [ ] ParkingSection renders 8 spots vertically
- [ ] API PATCH /api/parking/[id] updates status (KEWA only)
- [ ] No TypeScript errors
- [ ] Build succeeds: `npm run build`
</verification>

## must_haves

- 8 parking spots seeded in database
- Parking spots displayed vertically
- Each spot shows status: free/occupied/maintenance
- KEWA can change parking status
- Status color coding: green=free, blue=occupied, amber=maintenance
