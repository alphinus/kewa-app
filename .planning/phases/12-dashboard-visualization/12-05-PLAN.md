# Plan 12-05: Comments System

---
phase: 12
plan: 05
name: Comments System
wave: 3
depends_on: []
scope: medium
autonomous: true
files_modified:
  - supabase/migrations/041_comments.sql
  - src/types/comments.ts
  - src/lib/comments/comment-queries.ts
  - src/components/comments/CommentList.tsx
  - src/components/comments/CommentForm.tsx
  - src/components/comments/CommentVisibilityBadge.tsx
  - src/app/api/comments/route.ts
requirements:
  - COMM-01
  - COMM-02
  - COMM-03
---

## Objective

Implement polymorphic commenting system for tasks, work orders, projects, and units with visibility control (internal vs shared).

## Context

From 12-RESEARCH.md and 12-CONTEXT.md:
- Polymorphic pattern: entity_type, entity_id (like media table)
- Visibility: internal (KEWA only) vs shared (KEWA + contractor)
- Color coding: yellow = internal, blue = shared
- Text-only for MVP (no attachments)

Existing code references:
- `supabase/migrations/015_media.sql` - Polymorphic entity pattern
- `src/components/admin/work-orders/EventLog.tsx` - Chronological display pattern

## Tasks

<task id="01" title="Create comments migration">
Comments table with polymorphic reference and visibility.

**File:** `supabase/migrations/041_comments.sql`

```sql
-- KEWA Renovations Operations System
-- Migration: 041_comments.sql
-- COMM-01, COMM-02, COMM-03: Comment system with visibility

-- =============================================
-- COMMENT VISIBILITY ENUM
-- =============================================

CREATE TYPE comment_visibility AS ENUM ('internal', 'shared');

-- =============================================
-- COMMENTS TABLE
-- =============================================

CREATE TABLE IF NOT EXISTS comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Polymorphic reference (can attach to any entity)
  entity_type TEXT NOT NULL CHECK (entity_type IN ('task', 'work_order', 'project', 'unit')),
  entity_id UUID NOT NULL,

  -- Content
  content TEXT NOT NULL,
  visibility comment_visibility NOT NULL DEFAULT 'internal',

  -- Author (can be user or contractor)
  author_id UUID REFERENCES users(id),
  author_email TEXT,  -- For contractors without user account
  author_name TEXT,   -- Display name for contractors

  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- =============================================
-- INDEXES
-- =============================================

CREATE INDEX IF NOT EXISTS idx_comments_entity ON comments(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_comments_visibility ON comments(visibility);
CREATE INDEX IF NOT EXISTS idx_comments_author ON comments(author_id);
CREATE INDEX IF NOT EXISTS idx_comments_created ON comments(created_at DESC);

-- =============================================
-- UPDATED_AT TRIGGER
-- =============================================

DROP TRIGGER IF EXISTS comments_updated_at ON comments;
CREATE TRIGGER comments_updated_at
  BEFORE UPDATE ON comments
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- =============================================
-- COMMENTS
-- =============================================

COMMENT ON TABLE comments IS 'Polymorphic comments for tasks, work orders, projects, units';
COMMENT ON COLUMN comments.entity_type IS 'Type of entity: task, work_order, project, unit';
COMMENT ON COLUMN comments.entity_id IS 'UUID of the entity this comment is attached to';
COMMENT ON COLUMN comments.visibility IS 'internal: KEWA only, shared: visible to contractors';
COMMENT ON COLUMN comments.author_email IS 'Email for contractors without user account';
```
</task>

<task id="02" title="Create comment TypeScript types" depends_on="01">
TypeScript types for comments.

**File:** `src/types/comments.ts`

```typescript
export type CommentVisibility = 'internal' | 'shared'
export type CommentEntityType = 'task' | 'work_order' | 'project' | 'unit'

export interface Comment {
  id: string
  entity_type: CommentEntityType
  entity_id: string
  content: string
  visibility: CommentVisibility
  author_id: string | null
  author_email: string | null
  author_name: string | null
  created_at: string
  updated_at: string
}

export interface CommentWithAuthor extends Comment {
  author_display_name: string
  is_own_comment: boolean
}

export interface CreateCommentInput {
  entity_type: CommentEntityType
  entity_id: string
  content: string
  visibility: CommentVisibility
}

export interface CommentListResponse {
  comments: CommentWithAuthor[]
  total: number
}
```
</task>

<task id="03" title="Create comment query module" depends_on="02">
Server-side queries for comments.

**File:** `src/lib/comments/comment-queries.ts`

```typescript
import { createClient } from '@/lib/supabase/server'
import type {
  Comment,
  CommentWithAuthor,
  CreateCommentInput,
  CommentEntityType,
  CommentVisibility
} from '@/types/comments'

export async function fetchComments(
  entityType: CommentEntityType,
  entityId: string,
  viewerRole: 'kewa' | 'contractor',
  viewerEmail?: string
): Promise<CommentWithAuthor[]> {
  const supabase = await createClient()

  // Build query
  let query = supabase
    .from('comments')
    .select(`
      *,
      author:users(display_name)
    `)
    .eq('entity_type', entityType)
    .eq('entity_id', entityId)
    .order('created_at', { ascending: true })

  // Contractors only see shared comments
  if (viewerRole === 'contractor') {
    query = query.eq('visibility', 'shared')
  }

  const { data, error } = await query

  if (error) {
    console.error('Error fetching comments:', error)
    return []
  }

  return (data || []).map(comment => {
    // Handle Supabase array relation
    const authorData = comment.author as unknown as { display_name: string } | null

    return {
      ...comment,
      author_display_name: authorData?.display_name || comment.author_name || comment.author_email || 'Unbekannt',
      is_own_comment: viewerEmail ? comment.author_email === viewerEmail : false
    }
  }) as CommentWithAuthor[]
}

export async function createComment(
  input: CreateCommentInput,
  authorId?: string,
  authorEmail?: string,
  authorName?: string
): Promise<{ success: boolean; comment?: Comment; error?: string }> {
  const supabase = await createClient()

  const { data, error } = await supabase
    .from('comments')
    .insert({
      entity_type: input.entity_type,
      entity_id: input.entity_id,
      content: input.content.trim(),
      visibility: input.visibility,
      author_id: authorId || null,
      author_email: authorEmail || null,
      author_name: authorName || null
    })
    .select()
    .single()

  if (error) {
    return { success: false, error: error.message }
  }

  return { success: true, comment: data as Comment }
}

export async function getCommentCount(
  entityType: CommentEntityType,
  entityId: string
): Promise<number> {
  const supabase = await createClient()

  const { count } = await supabase
    .from('comments')
    .select('id', { count: 'exact', head: true })
    .eq('entity_type', entityType)
    .eq('entity_id', entityId)

  return count || 0
}
```
</task>

<task id="04" title="Create CommentVisibilityBadge component" depends_on="02">
Visual indicator for comment visibility.

**File:** `src/components/comments/CommentVisibilityBadge.tsx`

```typescript
import { cn } from '@/lib/utils'
import type { CommentVisibility } from '@/types/comments'

const VISIBILITY_STYLES: Record<CommentVisibility, string> = {
  internal: 'bg-amber-100 text-amber-800 border-amber-200 dark:bg-amber-900/30 dark:text-amber-300 dark:border-amber-800',
  shared: 'bg-blue-100 text-blue-800 border-blue-200 dark:bg-blue-900/30 dark:text-blue-300 dark:border-blue-800'
}

const VISIBILITY_LABELS: Record<CommentVisibility, string> = {
  internal: 'Intern',
  shared: 'Geteilt'
}

interface CommentVisibilityBadgeProps {
  visibility: CommentVisibility
  size?: 'sm' | 'md'
  className?: string
}

export function CommentVisibilityBadge({
  visibility,
  size = 'sm',
  className
}: CommentVisibilityBadgeProps) {
  return (
    <span
      className={cn(
        'inline-flex items-center font-medium rounded-full border',
        VISIBILITY_STYLES[visibility],
        size === 'sm' ? 'px-1.5 py-0.5 text-[10px]' : 'px-2 py-0.5 text-xs',
        className
      )}
    >
      {visibility === 'internal' && (
        <svg className="w-3 h-3 mr-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
        </svg>
      )}
      {VISIBILITY_LABELS[visibility]}
    </span>
  )
}
```
</task>

<task id="05" title="Create CommentList component" depends_on="03,04">
Display list of comments with author and timestamp.

**File:** `src/components/comments/CommentList.tsx`

```typescript
'use client'

import { useState, useEffect, useCallback } from 'react'
import { cn } from '@/lib/utils'
import { CommentVisibilityBadge } from './CommentVisibilityBadge'
import type { CommentWithAuthor, CommentEntityType } from '@/types/comments'

interface CommentListProps {
  entityType: CommentEntityType
  entityId: string
  className?: string
}

export function CommentList({ entityType, entityId, className }: CommentListProps) {
  const [comments, setComments] = useState<CommentWithAuthor[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const loadComments = useCallback(async () => {
    try {
      setIsLoading(true)
      const response = await fetch(
        `/api/comments?entity_type=${entityType}&entity_id=${entityId}`
      )

      if (!response.ok) throw new Error('Failed to fetch comments')

      const data = await response.json()
      setComments(data.comments)
      setError(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Ein Fehler ist aufgetreten')
    } finally {
      setIsLoading(false)
    }
  }, [entityType, entityId])

  useEffect(() => {
    loadComments()
  }, [loadComments])

  const formatTimestamp = (timestamp: string) => {
    return new Date(timestamp).toLocaleDateString('de-CH', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })
  }

  if (isLoading) {
    return (
      <div className={cn('animate-pulse space-y-3', className)}>
        {[1, 2].map(i => (
          <div key={i} className="h-16 bg-gray-200 dark:bg-gray-700 rounded-lg" />
        ))}
      </div>
    )
  }

  if (error) {
    return (
      <div className={cn('text-sm text-red-500', className)}>
        {error}
      </div>
    )
  }

  if (comments.length === 0) {
    return (
      <div className={cn('text-sm text-gray-500 dark:text-gray-400 text-center py-4', className)}>
        Keine Kommentare vorhanden.
      </div>
    )
  }

  return (
    <div className={cn('space-y-3', className)}>
      {comments.map((comment) => (
        <div
          key={comment.id}
          className={cn(
            'p-3 rounded-lg border',
            comment.visibility === 'internal'
              ? 'bg-amber-50 border-amber-200 dark:bg-amber-900/10 dark:border-amber-800'
              : 'bg-blue-50 border-blue-200 dark:bg-blue-900/10 dark:border-blue-800'
          )}
        >
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-2">
              <span className="text-sm font-medium text-gray-900 dark:text-gray-100">
                {comment.author_display_name}
              </span>
              <CommentVisibilityBadge visibility={comment.visibility} />
            </div>
            <time className="text-xs text-gray-500 dark:text-gray-400">
              {formatTimestamp(comment.created_at)}
            </time>
          </div>
          <p className="text-sm text-gray-700 dark:text-gray-300 whitespace-pre-wrap">
            {comment.content}
          </p>
        </div>
      ))}
    </div>
  )
}
```
</task>

<task id="06" title="Create CommentForm component" depends_on="02">
Form for adding new comments.

**File:** `src/components/comments/CommentForm.tsx`

```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/button'
import { cn } from '@/lib/utils'
import type { CommentEntityType, CommentVisibility } from '@/types/comments'

interface CommentFormProps {
  entityType: CommentEntityType
  entityId: string
  canSetVisibility?: boolean // KEWA can choose visibility
  onCommentAdded?: () => void
  className?: string
}

export function CommentForm({
  entityType,
  entityId,
  canSetVisibility = false,
  onCommentAdded,
  className
}: CommentFormProps) {
  const [content, setContent] = useState('')
  const [visibility, setVisibility] = useState<CommentVisibility>('internal')
  const [isSubmitting, setIsSubmitting] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!content.trim()) return

    try {
      setIsSubmitting(true)
      setError(null)

      const response = await fetch('/api/comments', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          entity_type: entityType,
          entity_id: entityId,
          content: content.trim(),
          visibility: canSetVisibility ? visibility : 'shared'
        })
      })

      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || 'Fehler beim Speichern')
      }

      setContent('')
      onCommentAdded?.()
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Ein Fehler ist aufgetreten')
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className={cn('space-y-3', className)}>
      {error && (
        <div className="p-2 text-sm text-red-600 bg-red-50 dark:bg-red-900/20 rounded">
          {error}
        </div>
      )}

      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Kommentar schreiben..."
        rows={3}
        className={cn(
          'w-full px-3 py-2 rounded-lg border',
          'border-gray-300 dark:border-gray-600',
          'bg-white dark:bg-gray-800',
          'text-gray-900 dark:text-gray-100',
          'placeholder-gray-400 dark:placeholder-gray-500',
          'focus:outline-none focus:ring-2 focus:ring-blue-500',
          'resize-none'
        )}
      />

      <div className="flex items-center justify-between">
        {canSetVisibility && (
          <div className="flex items-center gap-2">
            <label className="flex items-center gap-1.5 cursor-pointer">
              <input
                type="radio"
                name="visibility"
                checked={visibility === 'internal'}
                onChange={() => setVisibility('internal')}
                className="text-amber-600 focus:ring-amber-500"
              />
              <span className="text-sm text-gray-600 dark:text-gray-400">Intern</span>
            </label>
            <label className="flex items-center gap-1.5 cursor-pointer">
              <input
                type="radio"
                name="visibility"
                checked={visibility === 'shared'}
                onChange={() => setVisibility('shared')}
                className="text-blue-600 focus:ring-blue-500"
              />
              <span className="text-sm text-gray-600 dark:text-gray-400">Geteilt</span>
            </label>
          </div>
        )}

        <Button
          type="submit"
          disabled={!content.trim() || isSubmitting}
          loading={isSubmitting}
          size="sm"
        >
          Kommentieren
        </Button>
      </div>
    </form>
  )
}
```
</task>

<task id="07" title="Create comments API route" depends_on="03">
API endpoint for fetching and creating comments.

**File:** `src/app/api/comments/route.ts`

```typescript
import { NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import { fetchComments, createComment } from '@/lib/comments/comment-queries'
import type { CommentEntityType, CommentVisibility } from '@/types/comments'

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const entityType = searchParams.get('entity_type') as CommentEntityType
  const entityId = searchParams.get('entity_id')

  if (!entityType || !entityId) {
    return NextResponse.json(
      { error: 'entity_type and entity_id required' },
      { status: 400 }
    )
  }

  // Get viewer info from session
  const cookieStore = await cookies()
  const sessionCookie = cookieStore.get('kewa-session')
  let viewerRole: 'kewa' | 'contractor' = 'contractor'
  let viewerEmail: string | undefined

  if (sessionCookie?.value) {
    try {
      const session = JSON.parse(sessionCookie.value)
      viewerRole = session.role === 'kewa' ? 'kewa' : 'contractor'
      viewerEmail = session.email
    } catch {
      // Keep default contractor role
    }
  }

  const comments = await fetchComments(entityType, entityId, viewerRole, viewerEmail)

  return NextResponse.json({ comments })
}

export async function POST(request: Request) {
  const cookieStore = await cookies()
  const sessionCookie = cookieStore.get('kewa-session')

  if (!sessionCookie?.value) {
    return NextResponse.json({ error: 'Nicht autorisiert' }, { status: 401 })
  }

  let authorId: string | undefined
  let authorEmail: string | undefined
  let authorName: string | undefined
  let isKewa = false

  try {
    const session = JSON.parse(sessionCookie.value)
    authorId = session.userId
    authorEmail = session.email
    authorName = session.displayName
    isKewa = session.role === 'kewa'
  } catch {
    return NextResponse.json({ error: 'Ungueltige Session' }, { status: 401 })
  }

  const body = await request.json()
  const { entity_type, entity_id, content, visibility } = body as {
    entity_type: CommentEntityType
    entity_id: string
    content: string
    visibility: CommentVisibility
  }

  if (!entity_type || !entity_id || !content?.trim()) {
    return NextResponse.json(
      { error: 'entity_type, entity_id, and content required' },
      { status: 400 }
    )
  }

  // Only KEWA can create internal comments
  const finalVisibility: CommentVisibility =
    visibility === 'internal' && isKewa ? 'internal' : 'shared'

  const result = await createComment(
    { entity_type, entity_id, content, visibility: finalVisibility },
    authorId,
    authorEmail,
    authorName
  )

  if (!result.success) {
    return NextResponse.json(
      { error: result.error || 'Fehler beim Speichern' },
      { status: 500 }
    )
  }

  return NextResponse.json({ success: true, comment: result.comment })
}
```
</task>

## Verification

<verification>
- [ ] Migration 041 creates comments table with visibility enum
- [ ] Comments can be attached to tasks, work_orders, projects, units
- [ ] KEWA sees all comments (internal + shared)
- [ ] Contractors only see shared comments
- [ ] Internal comments have yellow background
- [ ] Shared comments have blue background
- [ ] CommentForm allows visibility toggle (KEWA only)
- [ ] Comments display chronologically with author and timestamp
- [ ] API validates auth and permissions
- [ ] No TypeScript errors
- [ ] Build succeeds: `npm run build`
</verification>

## must_haves

- Comments attachable to tasks, work orders, projects, units
- Chronological display with author and timestamp
- Internal comments visible only to KEWA
- Shared comments visible to KEWA and contractors
- Visual distinction: yellow=internal, blue=shared
- Comment form with visibility toggle for KEWA
