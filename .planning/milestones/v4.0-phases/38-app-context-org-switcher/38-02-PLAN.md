---
phase: 38-app-context-org-switcher
plan: 02
type: execute
wave: 2
depends_on: [38-01]
files_modified:
  - src/contexts/OrganizationContext.tsx
  - src/contexts/MandateContext.tsx
  - src/contexts/BuildingContext.tsx
autonomous: true
requirements: [CTX-01, CTX-02, CTX-04]

must_haves:
  truths:
    - "OrganizationProvider reads organization_id cookie on mount and fetches available orgs from GET /api/organizations"
    - "MandateProvider waits for OrganizationProvider to finish loading before fetching mandates from GET /api/mandates"
    - "BuildingProvider reads building_id cookie on mount and persists selection changes to cookie"
    - "switchOrg() sets organization_id cookie, clears mandate_id and building_id cookies, then navigates via window.location.href (not router.push)"
    - "Building selection is filtered by current mandate when a specific mandate is selected"
  artifacts:
    - path: "src/contexts/OrganizationContext.tsx"
      provides: "OrganizationProvider + useOrganization hook"
      exports: ["OrganizationProvider", "useOrganization"]
    - path: "src/contexts/MandateContext.tsx"
      provides: "MandateProvider + useMandate hook"
      exports: ["MandateProvider", "useMandate"]
    - path: "src/contexts/BuildingContext.tsx"
      provides: "Cookie-persisted BuildingProvider with mandate scoping"
      exports: ["BuildingProvider", "useBuilding"]
  key_links:
    - from: "src/contexts/OrganizationContext.tsx"
      to: "/api/organizations"
      via: "fetch in useEffect on mount"
      pattern: "fetch.*api/organizations"
    - from: "src/contexts/MandateContext.tsx"
      to: "/api/mandates"
      via: "fetch in useEffect when currentOrg changes"
      pattern: "fetch.*api/mandates"
    - from: "src/contexts/MandateContext.tsx"
      to: "src/contexts/OrganizationContext.tsx"
      via: "useOrganization() hook — waits for isLoading=false"
      pattern: "useOrganization"
    - from: "src/contexts/BuildingContext.tsx"
      to: "src/contexts/MandateContext.tsx"
      via: "useMandate() hook — reads currentMandateId for filtering"
      pattern: "useMandate"
---

<objective>
Create the three nested context providers (Organization > Mandate > Building) with cookie persistence, stale validation, and proper loading sequencing.

Purpose: These providers are the core of Phase 38 — they thread org/mandate/building context through the entire dashboard, read/write cookies per D4, and handle switching logic per D5/D6.
Output: Three context files, each with a Provider component and a hook.
</objective>

<execution_context>
@C:/Users/Mario Giacchino/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Mario Giacchino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/38-app-context-org-switcher/38-CONTEXT.md
@.planning/phases/38-app-context-org-switcher/38-RESEARCH.md
@.planning/phases/38-app-context-org-switcher/38-01-SUMMARY.md

@src/contexts/BuildingContext.tsx
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OrganizationProvider and MandateProvider</name>
  <files>src/contexts/OrganizationContext.tsx, src/contexts/MandateContext.tsx</files>
  <action>
**src/contexts/OrganizationContext.tsx** — Create new file.

'use client' directive. Imports: createContext, useContext, useState, useEffect, useMemo, useCallback from 'react'; Cookies from 'js-cookie'; Organization from '@/types'.

Interface `OrganizationContextValue`:
- `currentOrg: Organization | null`
- `availableOrgs: Organization[]`
- `switchOrg: (orgId: string) => void`
- `isLoading: boolean`
- `isMultiOrg: boolean`

Cookie constants (export for reuse):
```typescript
export const COOKIE_OPTIONS = { path: '/', sameSite: 'strict' as const, expires: 365 }
export const ORG_COOKIE = 'organization_id'
export const MANDATE_COOKIE = 'mandate_id'
export const BUILDING_COOKIE = 'building_id'
```

`OrganizationProvider` component:
1. On mount (`useEffect([], [])`), read `organization_id` cookie via `Cookies.get(ORG_COOKIE)`
2. Fetch `GET /api/organizations` — parse response as `{ organizations: Organization[] }`
3. Stale validation: if cookie org ID exists in fetched list, use it; otherwise fall back to the org with `isDefault=true`, otherwise first org
4. Set `currentOrg` state and write cookie if it changed
5. `switchOrg(orgId)`: per D5 — set org cookie, remove mandate and building cookies (both with `{ path: '/' }`), then `window.location.href = '/dashboard'` for full page reload (NOT router.push — Pitfall 7)
6. Memoize context value with `useMemo`
7. Wrap `switchOrg` in `useCallback`

`useOrganization()` hook: standard context consumer with error if used outside provider.

**src/contexts/MandateContext.tsx** — Create new file.

'use client' directive. Imports: createContext, useContext, useState, useEffect, useMemo, useCallback from 'react'; Cookies from 'js-cookie'; Mandate from '@/types'; useOrganization + cookie constants from OrganizationContext.

Interface `MandateContextValue`:
- `currentMandateId: string | 'all'` — 'all' means cross-mandate overview (D8)
- `availableMandates: Mandate[]`
- `switchMandate: (mandateId: string | 'all') => void`
- `isLoading: boolean`
- `isSingleMandate: boolean` — true when org has exactly one mandate (D3)

`MandateProvider` component:
1. Consume `useOrganization()` to get `currentOrg` and org `isLoading`
2. **Race condition prevention (Pitfall 2)**: useEffect depends on `currentOrg?.id`. Only fetch when currentOrg is non-null.
3. Fetch `GET /api/mandates` — response: `{ mandates: Mandate[] }`
4. Read `mandate_id` cookie via `Cookies.get(MANDATE_COOKIE)`
5. Stale validation: if cookie mandate ID exists in fetched list, use it; if cookie is 'all', use 'all'; otherwise default to 'all' (cross-mandate view per D8)
6. `switchMandate(mandateId)`: set mandate cookie, remove building cookie (building may not exist in new mandate per D6), update state in-place (no page navigation). Call a re-fetch trigger or just update the local state.
7. When org is loading, set mandate isLoading=true (cascade loading state)
8. Memoize context value

`useMandate()` hook: standard context consumer with error if used outside provider.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Check exports: `grep -n 'export' src/contexts/OrganizationContext.tsx src/contexts/MandateContext.tsx`</verify>
  <done>OrganizationProvider fetches orgs from API, reads/writes organization_id cookie, exposes switchOrg with full page navigation. MandateProvider waits for org context, fetches mandates from API, reads/writes mandate_id cookie, exposes switchMandate with in-place update. Both providers validate stale cookies.</done>
</task>

<task type="auto">
  <name>Task 2: Modify BuildingProvider for cookie persistence and mandate scoping</name>
  <files>src/contexts/BuildingContext.tsx</files>
  <action>
Modify the existing `BuildingProvider` in `src/contexts/BuildingContext.tsx` to:

1. **Add imports**: `Cookies from 'js-cookie'`, `useMandate` from `./MandateContext`, `BUILDING_COOKIE, COOKIE_OPTIONS` from `./OrganizationContext`, `useEffect` and `useMemo` (add to existing react import)

2. **Keep the existing interface unchanged** (`BuildingContextValue` with `selectedBuildingId`, `selectBuilding`, `isAllSelected`, `isLoading`). This is critical — all consumers (`useBuilding()`) must work without changes.

3. **Cookie persistence on mount**: In the provider body, add a useEffect that runs once on mount to read `Cookies.get(BUILDING_COOKIE)`. If a value exists, call `setSelectedBuildingId(cookieValue)` to restore the previous selection.

4. **Cookie persistence on change**: Modify `selectBuilding` callback to write the cookie: `Cookies.set(BUILDING_COOKIE, buildingId || 'all', COOKIE_OPTIONS)` before or after calling `setSelectedBuildingId`. If buildingId is null, remove the cookie.

5. **Mandate scoping exposure**: Add `currentMandateId` from `useMandate()` to the provider. The provider itself doesn't filter — CombinedSelector (Plan 03) will do the filtering and call `selectBuilding`. But if mandate changes and the current building is no longer valid, the CombinedSelector handles that in Plan 03. The BuildingProvider just needs to expose its selection for consumers.

6. **Memoize context value** with `useMemo` to prevent re-render cascades (Pitfall 1).

7. **Wrap `selectBuilding` in useCallback** (already done, but verify dependency array is correct after adding cookie write).

The key principle: BuildingProvider remains a dumb selection container with cookie persistence. It does NOT fetch properties or buildings — that's CombinedSelector's job (Plan 03). It just holds the selected building ID and persists it.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Grep for `BUILDING_COOKIE` in BuildingContext.tsx to confirm cookie integration. Verify the exported interface is unchanged: `grep 'selectedBuildingId\|selectBuilding\|isAllSelected\|isLoading' src/contexts/BuildingContext.tsx`</verify>
  <done>BuildingProvider reads building_id cookie on mount, writes cookie on selection change, memoizes context value. The useBuilding() hook interface is unchanged — all existing consumers work without modification.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. OrganizationProvider exports: OrganizationProvider, useOrganization, COOKIE_OPTIONS, ORG_COOKIE, MANDATE_COOKIE, BUILDING_COOKIE
3. MandateProvider exports: MandateProvider, useMandate
4. BuildingProvider still exports: BuildingProvider, useBuilding, BuildingSelectionId
5. `grep 'window.location.href' src/contexts/OrganizationContext.tsx` — confirms full page navigation for org switch (not router.push)
6. `grep 'Cookies.remove.*MANDATE_COOKIE' src/contexts/OrganizationContext.tsx` — confirms cascade cookie clear on org switch
7. `grep 'useOrganization' src/contexts/MandateContext.tsx` — confirms MandateProvider depends on OrganizationProvider
</verification>

<success_criteria>
- Three providers form a valid nesting chain: Organization > Mandate > Building
- Organization switch clears mandate and building cookies then does full page navigation
- Mandate switch clears building cookie and updates in-place
- Building selection persists to/from building_id cookie
- Stale cookies are validated against API data on mount
- Context values are memoized to prevent unnecessary re-renders
</success_criteria>

<output>
After completion, create `.planning/phases/38-app-context-org-switcher/38-02-SUMMARY.md`
</output>
