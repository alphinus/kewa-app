# Query Profile Analysis - Phase 32 Database Optimization

**Date:** 2026-02-05
**Phase:** 32-01
**Target:** PERF-03 - p95 query latency < 100ms

## Executive Summary

Analysis performed via static code review of query patterns (Supabase local not available - Docker not running). Query patterns derived from:
- `unit_condition_summary` view definition (027_condition_tracking.sql)
- `heatmap-queries.ts` client code
- `dashboard-queries.ts` client code
- Existing index definitions across 70+ migrations

## Critical Query Patterns Identified

### 1. Unit Condition Summary View (Highest Impact)

**Location:** `supabase/migrations/027_condition_tracking.sql` lines 202-224

**Query Pattern:**
```sql
SELECT
  u.id as unit_id, u.name, u.building_id,
  COUNT(r.id) as total_rooms,
  COUNT(CASE WHEN r.condition = 'new' THEN 1 END) as new_rooms,
  COUNT(CASE WHEN r.condition = 'partial' THEN 1 END) as partial_rooms,
  COUNT(CASE WHEN r.condition = 'old' THEN 1 END) as old_rooms,
  ...
FROM units u
LEFT JOIN rooms r ON r.unit_id = u.id
GROUP BY u.id, u.name, u.building_id;
```

**Current Indexes:**
- `idx_rooms_unit_id ON rooms(unit_id)` - single column
- `idx_rooms_condition ON rooms(condition)` - single column

**Problem:** JOIN and GROUP BY with condition aggregation requires scanning both columns. Two separate single-column indexes less efficient than composite.

**Recommendation:**
```sql
CREATE INDEX idx_rooms_unit_condition ON rooms(unit_id, condition);
```

**Impact:** Covering index for JOIN and COUNT CASE statements. Should eliminate separate index scans.

---

### 2. Heatmap Query - Units by Building and Type

**Location:** `src/lib/dashboard/heatmap-queries.ts` lines 56-64

**Query Pattern:**
```sql
SELECT id, name, floor, position, unit_type, tenant_name, ...
FROM units
WHERE building_id = $1 AND unit_type = 'apartment'
ORDER BY floor DESC;
```

**Current Indexes:**
- `idx_units_building_id ON units(building_id)` - single column

**Problem:** Filter on `building_id` AND `unit_type` requires index scan + filter on non-indexed column.

**Recommendation:**
```sql
CREATE INDEX idx_units_building_type ON units(building_id, unit_type);
```

**Impact:** Both WHERE conditions covered by single index scan.

---

### 3. Dashboard Projects Query - Units with Status Filter

**Location:** `src/lib/dashboard/dashboard-queries.ts` lines 44-50

**Query Pattern:**
```sql
SELECT id, ...
FROM renovation_projects
WHERE unit_id IN ($1, $2, ...) AND status IN ('planned', 'active', 'blocked');
```

**Current Indexes:**
- `idx_renovation_projects_unit_id ON renovation_projects(unit_id)` - single column
- `idx_renovation_projects_status ON renovation_projects(status)` - single column

**Problem:** Filter on `unit_id` array AND `status` array requires combining two separate index scans or index scan + filter.

**Recommendation:**
```sql
CREATE INDEX idx_renovation_projects_unit_status ON renovation_projects(unit_id, status);
```

**Impact:** Composite index handles both IN conditions efficiently.

---

## Existing Index Coverage Analysis

### Tables with Adequate Indexing
- `work_orders` - 8 indexes covering primary access patterns
- `tasks` - 7 indexes covering FK and status patterns
- `tickets` - 6 indexes including partial indexes
- `invoices` - 6 indexes covering FK relationships

### Tables Needing Composite Index Enhancement
| Table | Current | Recommended | Rationale |
|-------|---------|-------------|-----------|
| rooms | 3 single-column | Add (unit_id, condition) | View aggregation |
| units | 1 single-column | Add (building_id, unit_type) | Heatmap filter |
| renovation_projects | 5 single-column | Add (unit_id, status) | Dashboard filter |

---

## Index Recommendations Summary

### Priority 1: Dashboard/Heatmap Performance (This Plan)

```sql
-- 1. Unit condition summary optimization
CREATE INDEX idx_rooms_unit_condition ON rooms(unit_id, condition);

-- 2. Heatmap units filter
CREATE INDEX idx_units_building_type ON units(building_id, unit_type);

-- 3. Dashboard projects query
CREATE INDEX idx_renovation_projects_unit_status ON renovation_projects(unit_id, status);
```

### Priority 2: Future Optimization Candidates

Based on query patterns not yet profiled with real traffic:
- `condition_history(entity_id, entity_type, changed_at)` - Timeline queries
- `work_orders(renovation_project_id, status)` - Project detail queries
- `tasks(renovation_project_id, status)` - Task listing

---

## Expected Performance Gains

| Query | Before | After (Expected) |
|-------|--------|------------------|
| unit_condition_summary | Seq scan + hash join | Index scan + merge |
| Heatmap units | Index + filter | Index only scan |
| Dashboard projects | Bitmap heap | Index scan |

**Note:** Actual gains depend on table size and data distribution. With typical KEWA data (5-20 buildings, 50-200 units, 500-2000 rooms), expect:
- Small datasets: Minimal measurable difference
- Production scale: 2-5x improvement on filtered queries

---

## Implementation Notes

1. Use `CREATE INDEX CONCURRENTLY` to avoid table locks
2. Run `ANALYZE` after index creation to update statistics
3. Verify with `EXPLAIN ANALYZE` after deployment
4. Monitor `pg_stat_user_indexes` for usage validation post-deployment
